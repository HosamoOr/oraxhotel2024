/*!
 * TOAST UI Chart 4th Edition
 * @version 4.0.4 | Thu Feb 04 2021
 * @author NHN. FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Chart"] = factory();
	else
		root["toastui"] = root["toastui"] || {}, root["toastui"]["Chart"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 145);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var global = __webpack_require__(26);
var getBuiltIn = __webpack_require__(58);
var IS_PURE = __webpack_require__(82);
var DESCRIPTORS = __webpack_require__(30);
var NATIVE_SYMBOL = __webpack_require__(98);
var USE_SYMBOL_AS_UID = __webpack_require__(123);
var fails = __webpack_require__(24);
var has = __webpack_require__(31);
var isArray = __webpack_require__(71);
var isObject = __webpack_require__(29);
var anObject = __webpack_require__(32);
var toObject = __webpack_require__(37);
var toIndexedObject = __webpack_require__(44);
var toPrimitive = __webpack_require__(57);
var createPropertyDescriptor = __webpack_require__(56);
var nativeObjectCreate = __webpack_require__(53);
var objectKeys = __webpack_require__(83);
var getOwnPropertyNamesModule = __webpack_require__(59);
var getOwnPropertyNamesExternal = __webpack_require__(151);
var getOwnPropertySymbolsModule = __webpack_require__(122);
var getOwnPropertyDescriptorModule = __webpack_require__(49);
var definePropertyModule = __webpack_require__(33);
var propertyIsEnumerableModule = __webpack_require__(92);
var createNonEnumerableProperty = __webpack_require__(40);
var redefine = __webpack_require__(48);
var shared = __webpack_require__(95);
var sharedKey = __webpack_require__(81);
var hiddenKeys = __webpack_require__(69);
var uid = __webpack_require__(68);
var wellKnownSymbol = __webpack_require__(28);
var wrappedWellKnownSymbolModule = __webpack_require__(124);
var defineWellKnownSymbol = __webpack_require__(125);
var setToStringTag = __webpack_require__(72);
var InternalStateModule = __webpack_require__(51);
var $forEach = __webpack_require__(35).forEach;

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var $stringify = getBuiltIn('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var isSymbol = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);
  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return getInternalState(this).tag;
  });

  redefine($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  // `Symbol.for` method
  // https://tc39.es/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.es/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
$({ target: 'Object', stat: true, forced: fails(function () { getOwnPropertySymbolsModule.f(1); }) }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return getOwnPropertySymbolsModule.f(toObject(it));
  }
});

// `JSON.stringify` method behavior with symbols
// https://tc39.es/ecma262/#sec-json.stringify
if ($stringify) {
  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () {
    var symbol = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    return $stringify([symbol]) != '[null]'
      // WebKit converts symbol values to JSON as null
      || $stringify({ a: symbol }) != '{}'
      // V8 throws on boxed symbols
      || $stringify(Object(symbol)) != '{}';
  });

  $({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
    // eslint-disable-next-line no-unused-vars
    stringify: function stringify(it, replacer, space) {
      var args = [it];
      var index = 1;
      var $replacer;
      while (arguments.length > index) args.push(arguments[index++]);
      $replacer = replacer;
      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
      if (!isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return $stringify.apply(null, args);
    }
  });
}

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
}
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var forEach = __webpack_require__(126);

// `Array.prototype.forEach` method
// https://tc39.es/ecma262/#sec-array.prototype.foreach
$({ target: 'Array', proto: true, forced: [].forEach != forEach }, {
  forEach: forEach
});


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(26);
var DOMIterables = __webpack_require__(131);
var forEach = __webpack_require__(126);
var createNonEnumerableProperty = __webpack_require__(40);

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
}


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(22);
var toObject = __webpack_require__(37);
var nativeKeys = __webpack_require__(83);
var fails = __webpack_require__(24);

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var $filter = __webpack_require__(35).filter;
var arrayMethodHasSpeciesSupport = __webpack_require__(73);
var arrayMethodUsesToLength = __webpack_require__(41);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
// Edge 14- issue
var USES_TO_LENGTH = arrayMethodUsesToLength('filter');

// `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(44);
var addToUnscopables = __webpack_require__(62);
var Iterators = __webpack_require__(74);
var InternalStateModule = __webpack_require__(51);
var defineIterator = __webpack_require__(100);

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(101);
var redefine = __webpack_require__(48);
var toString = __webpack_require__(155);

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__(130).charAt;
var InternalStateModule = __webpack_require__(51);
var defineIterator = __webpack_require__(100);

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(26);
var DOMIterables = __webpack_require__(131);
var ArrayIteratorMethods = __webpack_require__(5);
var createNonEnumerableProperty = __webpack_require__(40);
var wellKnownSymbol = __webpack_require__(28);

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.es/ecma262/#sec-symbol.prototype.description

var $ = __webpack_require__(22);
var DESCRIPTORS = __webpack_require__(30);
var global = __webpack_require__(26);
var has = __webpack_require__(31);
var isObject = __webpack_require__(29);
var defineProperty = __webpack_require__(33).f;
var copyConstructorProperties = __webpack_require__(118);

var NativeSymbol = global.Symbol;

if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;

  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(125);

// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefine = __webpack_require__(48);
var anObject = __webpack_require__(32);
var fails = __webpack_require__(24);
var flags = __webpack_require__(129);

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.es/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var p = String(R.source);
    var rf = R.flags;
    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
    return '/' + p + '/' + f;
  }, { unsafe: true });
}


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(22);
var fails = __webpack_require__(24);
var toIndexedObject = __webpack_require__(44);
var nativeGetOwnPropertyDescriptor = __webpack_require__(49).f;
var DESCRIPTORS = __webpack_require__(30);

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor(1); });
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(22);
var DESCRIPTORS = __webpack_require__(30);
var ownKeys = __webpack_require__(119);
var toIndexedObject = __webpack_require__(44);
var getOwnPropertyDescriptorModule = __webpack_require__(49);
var createProperty = __webpack_require__(75);

// `Object.getOwnPropertyDescriptors` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(30);
var defineProperty = __webpack_require__(33).f;

var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// Function instances `.name` property
// https://tc39.es/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var fails = __webpack_require__(24);
var isArray = __webpack_require__(71);
var isObject = __webpack_require__(29);
var toObject = __webpack_require__(37);
var toLength = __webpack_require__(27);
var createProperty = __webpack_require__(75);
var arraySpeciesCreate = __webpack_require__(84);
var arrayMethodHasSpeciesSupport = __webpack_require__(73);
var wellKnownSymbol = __webpack_require__(28);
var V8_VERSION = __webpack_require__(99);

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, forced: FORCED }, {
  concat: function concat(arg) { // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var $map = __webpack_require__(35).map;
var arrayMethodHasSpeciesSupport = __webpack_require__(73);
var arrayMethodUsesToLength = __webpack_require__(41);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');
// FF49- issue
var USES_TO_LENGTH = arrayMethodUsesToLength('map');

// `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(22);
var fails = __webpack_require__(24);
var toObject = __webpack_require__(37);
var nativeGetPrototypeOf = __webpack_require__(63);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(128);

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});



/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(22);
var setPrototypeOf = __webpack_require__(64);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
$({ target: 'Object', stat: true }, {
  setPrototypeOf: setPrototypeOf
});


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(22);
var getBuiltIn = __webpack_require__(58);
var aFunction = __webpack_require__(61);
var anObject = __webpack_require__(32);
var isObject = __webpack_require__(29);
var create = __webpack_require__(53);
var bind = __webpack_require__(156);
var fails = __webpack_require__(24);

var nativeConstruct = getBuiltIn('Reflect', 'construct');

// `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});
var FORCED = NEW_TARGET_BUG || ARGS_BUG;

$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var isObject = __webpack_require__(29);
var isArray = __webpack_require__(71);
var toAbsoluteIndex = __webpack_require__(52);
var toLength = __webpack_require__(27);
var toIndexedObject = __webpack_require__(44);
var createProperty = __webpack_require__(75);
var wellKnownSymbol = __webpack_require__(28);
var arrayMethodHasSpeciesSupport = __webpack_require__(73);
var arrayMethodUsesToLength = __webpack_require__(41);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
var USES_TO_LENGTH = arrayMethodUsesToLength('slice', { ACCESSORS: true, 0: 0, 1: 2 });

var SPECIES = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(22);
var from = __webpack_require__(158);
var checkCorrectnessOfIteration = __webpack_require__(104);

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(26);
var getOwnPropertyDescriptor = __webpack_require__(49).f;
var createNonEnumerableProperty = __webpack_require__(40);
var redefine = __webpack_require__(48);
var setGlobal = __webpack_require__(93);
var copyConstructorProperties = __webpack_require__(118);
var isForced = __webpack_require__(97);

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var $reduce = __webpack_require__(105).left;
var arrayMethodIsStrict = __webpack_require__(54);
var arrayMethodUsesToLength = __webpack_require__(41);
var CHROME_VERSION = __webpack_require__(99);
var IS_NODE = __webpack_require__(160);

var STRICT_METHOD = arrayMethodIsStrict('reduce');
var USES_TO_LENGTH = arrayMethodUsesToLength('reduce', { 1: 0 });
// Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;

// `Array.prototype.reduce` method
// https://tc39.es/ecma262/#sec-array.prototype.reduce
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH || CHROME_BUG }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var NATIVE_ARRAY_BUFFER = __webpack_require__(142);
var DESCRIPTORS = __webpack_require__(30);
var global = __webpack_require__(26);
var isObject = __webpack_require__(29);
var has = __webpack_require__(31);
var classof = __webpack_require__(85);
var createNonEnumerableProperty = __webpack_require__(40);
var redefine = __webpack_require__(48);
var defineProperty = __webpack_require__(33).f;
var getPrototypeOf = __webpack_require__(63);
var setPrototypeOf = __webpack_require__(64);
var wellKnownSymbol = __webpack_require__(28);
var uid = __webpack_require__(68);

var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var isPrototypeOf = ObjectPrototype.isPrototypeOf;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};

var isView = function isView(it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return klass === 'DataView'
    || has(TypedArrayConstructorsList, klass)
    || has(BigIntArrayConstructorsList, klass);
};

var isTypedArray = function (it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return has(TypedArrayConstructorsList, klass)
    || has(BigIntArrayConstructorsList, klass);
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (setPrototypeOf) {
    if (isPrototypeOf.call(TypedArray, C)) return C;
  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
      return C;
    }
  } throw TypeError('Target is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
      delete TypedArrayConstructor.prototype[KEY];
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    redefine(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
  }
};

var exportTypedArrayStaticMethod = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];
      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
        delete TypedArrayConstructor[KEY];
      }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      redefine(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQIRED = true;
  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () {
    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
  } });
  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

module.exports = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line no-undef
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  // eslint-disable-next-line no-new-func
  (function () { return this; })() || Function('return this')();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(147)))

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(46);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(26);
var shared = __webpack_require__(95);
var has = __webpack_require__(31);
var uid = __webpack_require__(68);
var NATIVE_SYMBOL = __webpack_require__(98);
var USE_SYMBOL_AS_UID = __webpack_require__(123);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name)) {
    if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];
    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(24);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),
/* 31 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(29);

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(30);
var IE8_DOM_DEFINE = __webpack_require__(115);
var anObject = __webpack_require__(32);
var toPrimitive = __webpack_require__(57);

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(30);
var global = __webpack_require__(26);
var isForced = __webpack_require__(97);
var redefine = __webpack_require__(48);
var has = __webpack_require__(31);
var classof = __webpack_require__(50);
var inheritIfRequired = __webpack_require__(106);
var toPrimitive = __webpack_require__(57);
var fails = __webpack_require__(24);
var create = __webpack_require__(53);
var getOwnPropertyNames = __webpack_require__(59).f;
var getOwnPropertyDescriptor = __webpack_require__(49).f;
var defineProperty = __webpack_require__(33).f;
var trim = __webpack_require__(161).trim;

var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var NumberPrototype = NativeNumber.prototype;

// Opera ~12 has broken Object#toString
var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;

// `ToNumber` abstract operation
// https://tc39.es/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = it.charCodeAt(0);
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
        default: return +it;
      }
      digits = it.slice(2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

// `Number` constructor
// https://tc39.es/ecma262/#sec-number-constructor
if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper
      // check on 1..constructor(foo) case
      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classof(dummy) != NUMBER)
        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,' +
    // ESNext
    'fromString,range'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {
      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
    }
  }
  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global, NUMBER, NumberWrapper);
}


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__(60);
var IndexedObject = __webpack_require__(80);
var toObject = __webpack_require__(37);
var toLength = __webpack_require__(27);
var arraySpeciesCreate = __webpack_require__(84);

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_OUT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push.call(target, value); // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push.call(target, value); // filterOut
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterOut` method
  // https://github.com/tc39/proposal-array-filtering
  filterOut: createMethod(7)
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(22);
var isObject = __webpack_require__(29);
var anObject = __webpack_require__(32);
var has = __webpack_require__(31);
var getOwnPropertyDescriptorModule = __webpack_require__(49);
var getPrototypeOf = __webpack_require__(63);

// `Reflect.get` method
// https://tc39.es/ecma262/#sec-reflect.get
function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject(target) === receiver) return target[propertyKey];
  if (descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey)) return has(descriptor, 'value')
    ? descriptor.value
    : descriptor.get === undefined
      ? undefined
      : descriptor.get.call(receiver);
  if (isObject(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
}

$({ target: 'Reflect', stat: true }, {
  get: get
});


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(47);

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var flattenIntoArray = __webpack_require__(157);
var toObject = __webpack_require__(37);
var toLength = __webpack_require__(27);
var aFunction = __webpack_require__(61);
var arraySpeciesCreate = __webpack_require__(84);

// `Array.prototype.flatMap` method
// https://tc39.es/ecma262/#sec-array.prototype.flatmap
$({ target: 'Array', proto: true }, {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A;
    aFunction(callbackfn);
    A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return A;
  }
});


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__(62);

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('flatMap');


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(30);
var definePropertyModule = __webpack_require__(33);
var createPropertyDescriptor = __webpack_require__(56);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(30);
var fails = __webpack_require__(24);
var has = __webpack_require__(31);

var defineProperty = Object.defineProperty;
var cache = {};

var thrower = function (it) { throw it; };

module.exports = function (METHOD_NAME, options) {
  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
  if (!options) options = {};
  var method = [][METHOD_NAME];
  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
  var argument0 = has(options, 0) ? options[0] : thrower;
  var argument1 = has(options, 1) ? options[1] : undefined;

  return cache[METHOD_NAME] = !!method && !fails(function () {
    if (ACCESSORS && !DESCRIPTORS) return true;
    var O = { length: -1 };

    if (ACCESSORS) defineProperty(O, 1, { enumerable: true, get: thrower });
    else O[1] = 1;

    method.call(O, argument0, argument1);
  });
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var $find = __webpack_require__(35).find;
var addToUnscopables = __webpack_require__(62);
var arrayMethodUsesToLength = __webpack_require__(41);

var FIND = 'find';
var SKIPS_HOLES = true;

var USES_TO_LENGTH = arrayMethodUsesToLength(FIND);

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var $some = __webpack_require__(35).some;
var arrayMethodIsStrict = __webpack_require__(54);
var arrayMethodUsesToLength = __webpack_require__(41);

var STRICT_METHOD = arrayMethodIsStrict('some');
var USES_TO_LENGTH = arrayMethodUsesToLength('some');

// `Array.prototype.some` method
// https://tc39.es/ecma262/#sec-array.prototype.some
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(80);
var requireObjectCoercible = __webpack_require__(47);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(22);
var $values = __webpack_require__(163).values;

// `Object.values` method
// https://tc39.es/ecma262/#sec-object.values
$({ target: 'Object', stat: true }, {
  values: function values(O) {
    return $values(O);
  }
});


/***/ }),
/* 46 */
/***/ (function(module, exports) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),
/* 47 */
/***/ (function(module, exports) {

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(26);
var createNonEnumerableProperty = __webpack_require__(40);
var has = __webpack_require__(31);
var setGlobal = __webpack_require__(93);
var inspectSource = __webpack_require__(117);
var InternalStateModule = __webpack_require__(51);

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var state;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) {
      createNonEnumerableProperty(value, 'name', key);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(30);
var propertyIsEnumerableModule = __webpack_require__(92);
var createPropertyDescriptor = __webpack_require__(56);
var toIndexedObject = __webpack_require__(44);
var toPrimitive = __webpack_require__(57);
var has = __webpack_require__(31);
var IE8_DOM_DEFINE = __webpack_require__(115);

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),
/* 50 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__(148);
var global = __webpack_require__(26);
var isObject = __webpack_require__(29);
var createNonEnumerableProperty = __webpack_require__(40);
var objectHas = __webpack_require__(31);
var shared = __webpack_require__(94);
var sharedKey = __webpack_require__(81);
var hiddenKeys = __webpack_require__(69);

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(46);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(32);
var defineProperties = __webpack_require__(149);
var enumBugKeys = __webpack_require__(96);
var hiddenKeys = __webpack_require__(69);
var html = __webpack_require__(150);
var documentCreateElement = __webpack_require__(116);
var sharedKey = __webpack_require__(81);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : defineProperties(result, Properties);
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(24);

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () { throw 1; }, 1);
  });
};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var exec = __webpack_require__(87);

// `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec
$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});


/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(29);

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(120);
var global = __webpack_require__(26);

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(121);
var enumBugKeys = __webpack_require__(96);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(61);

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(28);
var create = __webpack_require__(53);
var definePropertyModule = __webpack_require__(33);

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(31);
var toObject = __webpack_require__(37);
var sharedKey = __webpack_require__(81);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(128);

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(32);
var aPossiblePrototype = __webpack_require__(154);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var $includes = __webpack_require__(70).includes;
var addToUnscopables = __webpack_require__(62);
var arrayMethodUsesToLength = __webpack_require__(41);

var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: !USES_TO_LENGTH }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(32);
var aFunction = __webpack_require__(61);
var wellKnownSymbol = __webpack_require__(28);

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var toAbsoluteIndex = __webpack_require__(52);
var toInteger = __webpack_require__(46);
var toLength = __webpack_require__(27);
var toObject = __webpack_require__(37);
var arraySpeciesCreate = __webpack_require__(84);
var createProperty = __webpack_require__(75);
var arrayMethodHasSpeciesSupport = __webpack_require__(73);
var arrayMethodUsesToLength = __webpack_require__(41);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
var USES_TO_LENGTH = arrayMethodUsesToLength('splice', { ACCESSORS: true, 0: 0, 1: 2 });

var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

// `Array.prototype.splice` method
// https://tc39.es/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
    }
    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});


/***/ }),
/* 68 */
/***/ (function(module, exports) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),
/* 69 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(44);
var toLength = __webpack_require__(27);
var toAbsoluteIndex = __webpack_require__(52);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(50);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(33).f;
var has = __webpack_require__(31);
var wellKnownSymbol = __webpack_require__(28);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(24);
var wellKnownSymbol = __webpack_require__(28);
var V8_VERSION = __webpack_require__(99);

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),
/* 74 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toPrimitive = __webpack_require__(57);
var definePropertyModule = __webpack_require__(33);
var createPropertyDescriptor = __webpack_require__(56);

module.exports = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var collection = __webpack_require__(164);
var collectionStrong = __webpack_require__(165);

// `Set` constructor
// https://tc39.es/ecma262/#sec-set-objects
module.exports = collection('Set', function (init) {
  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var notARegExp = __webpack_require__(166);
var requireObjectCoercible = __webpack_require__(47);
var correctIsRegExpLogic = __webpack_require__(167);

// `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~String(requireObjectCoercible(this))
      .indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var createHTML = __webpack_require__(172);
var forcedStringHTMLMethod = __webpack_require__(173);

// `String.prototype.anchor` method
// https://tc39.es/ecma262/#sec-string.prototype.anchor
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('anchor') }, {
  anchor: function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  }
});


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var $findIndex = __webpack_require__(35).findIndex;
var addToUnscopables = __webpack_require__(62);
var arrayMethodUsesToLength = __webpack_require__(41);

var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;

var USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);

// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

// `Array.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-array.prototype.findindex
$({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(24);
var classof = __webpack_require__(50);

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(95);
var uid = __webpack_require__(68);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(121);
var enumBugKeys = __webpack_require__(96);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(29);
var isArray = __webpack_require__(71);
var wellKnownSymbol = __webpack_require__(28);

var SPECIES = wellKnownSymbol('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(101);
var classofRaw = __webpack_require__(50);
var wellKnownSymbol = __webpack_require__(28);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};


/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var regexpFlags = __webpack_require__(129);
var stickyHelpers = __webpack_require__(168);

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = regexpFlags.call(re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = flags.replace('y', '');
      if (flags.indexOf('g') === -1) {
        flags += 'g';
      }

      strCopy = String(str).slice(re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = nativeExec.call(sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = match.input.slice(charsAdded);
        match[0] = match[0].slice(charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(22);
var fill = __webpack_require__(113);
var addToUnscopables = __webpack_require__(62);

// `Array.prototype.fill` method
// https://tc39.es/ecma262/#sec-array.prototype.fill
$({ target: 'Array', proto: true }, {
  fill: fill
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var toInteger = __webpack_require__(46);
var thisNumberValue = __webpack_require__(169);
var repeat = __webpack_require__(170);
var fails = __webpack_require__(24);

var nativeToFixed = 1.0.toFixed;
var floor = Math.floor;

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

var FORCED = nativeToFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToFixed.call({});
});

// `Number.prototype.toFixed` method
// https://tc39.es/ecma262/#sec-number.prototype.tofixed
$({ target: 'Number', proto: true, forced: FORCED }, {
  // eslint-disable-next-line max-statements
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue(this);
    var fractDigits = toInteger(fractionDigits);
    var data = [0, 0, 0, 0, 0, 0];
    var sign = '';
    var result = '0';
    var e, z, j, k;

    var multiply = function (n, c) {
      var index = -1;
      var c2 = c;
      while (++index < 6) {
        c2 += n * data[index];
        data[index] = c2 % 1e7;
        c2 = floor(c2 / 1e7);
      }
    };

    var divide = function (n) {
      var index = 6;
      var c = 0;
      while (--index >= 0) {
        c += data[index];
        data[index] = floor(c / n);
        c = (c % n) * 1e7;
      }
    };

    var dataToString = function () {
      var index = 6;
      var s = '';
      while (--index >= 0) {
        if (s !== '' || index === 0 || data[index] !== 0) {
          var t = String(data[index]);
          s = s === '' ? t : s + repeat.call('0', 7 - t.length) + t;
        }
      } return s;
    };

    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
    // eslint-disable-next-line no-self-compare
    if (number != number) return 'NaN';
    if (number <= -1e21 || number >= 1e21) return String(number);
    if (number < 0) {
      sign = '-';
      number = -number;
    }
    if (number > 1e-21) {
      e = log(number * pow(2, 69, 1)) - 69;
      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = fractDigits;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        result = dataToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        result = dataToString() + repeat.call('0', fractDigits);
      }
    }
    if (fractDigits > 0) {
      k = result.length;
      result = sign + (k <= fractDigits
        ? '0.' + repeat.call('0', fractDigits - k) + result
        : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
    } else {
      result = sign + result;
    } return result;
  }
});


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var $indexOf = __webpack_require__(70).indexOf;
var arrayMethodIsStrict = __webpack_require__(54);
var arrayMethodUsesToLength = __webpack_require__(41);

var nativeIndexOf = [].indexOf;

var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('indexOf');
var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

// `Array.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.indexof
$({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH }, {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? nativeIndexOf.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var IndexedObject = __webpack_require__(80);
var toIndexedObject = __webpack_require__(44);
var arrayMethodIsStrict = __webpack_require__(54);

var nativeJoin = [].join;

var ES3_STRINGS = IndexedObject != Object;
var STRICT_METHOD = arrayMethodIsStrict('join', ',');

// `Array.prototype.join` method
// https://tc39.es/ecma262/#sec-array.prototype.join
$({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(26);
var createNonEnumerableProperty = __webpack_require__(40);

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(26);
var setGlobal = __webpack_require__(93);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var IS_PURE = __webpack_require__(82);
var store = __webpack_require__(94);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.8.2',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2021 Denis Pushkarev (zloirock.ru)'
});


/***/ }),
/* 96 */
/***/ (function(module, exports) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(24);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(24);

module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(26);
var userAgent = __webpack_require__(152);

var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var createIteratorConstructor = __webpack_require__(153);
var getPrototypeOf = __webpack_require__(63);
var setPrototypeOf = __webpack_require__(64);
var setToStringTag = __webpack_require__(72);
var createNonEnumerableProperty = __webpack_require__(40);
var redefine = __webpack_require__(48);
var wellKnownSymbol = __webpack_require__(28);
var IS_PURE = __webpack_require__(82);
var Iterators = __webpack_require__(74);
var IteratorsCore = __webpack_require__(127);

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(28);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(28);
var Iterators = __webpack_require__(74);

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(85);
var Iterators = __webpack_require__(74);
var wellKnownSymbol = __webpack_require__(28);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(28);

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(61);
var toObject = __webpack_require__(37);
var IndexedObject = __webpack_require__(80);
var toLength = __webpack_require__(27);

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(29);
var setPrototypeOf = __webpack_require__(64);

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    typeof (NewTarget = dummy.constructor) == 'function' &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var hiddenKeys = __webpack_require__(69);
var isObject = __webpack_require__(29);
var has = __webpack_require__(31);
var defineProperty = __webpack_require__(33).f;
var uid = __webpack_require__(68);
var FREEZING = __webpack_require__(135);

var METADATA = uid('meta');
var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + ++id, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
  return it;
};

var meta = module.exports = {
  REQUIRED: false,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var $every = __webpack_require__(35).every;
var arrayMethodIsStrict = __webpack_require__(54);
var arrayMethodUsesToLength = __webpack_require__(41);

var STRICT_METHOD = arrayMethodIsStrict('every');
var USES_TO_LENGTH = arrayMethodUsesToLength('every');

// `Array.prototype.every` method
// https://tc39.es/ecma262/#sec-array.prototype.every
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__(55);
var redefine = __webpack_require__(48);
var fails = __webpack_require__(24);
var wellKnownSymbol = __webpack_require__(28);
var regexpExec = __webpack_require__(87);
var createNonEnumerableProperty = __webpack_require__(40);

var SPECIES = wellKnownSymbol('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  return 'a'.replace(/./, '$0') === '$0';
})();

var REPLACE = wellKnownSymbol('replace');
// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

module.exports = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () { execCalled = true; return null; };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !(
      REPLACE_SUPPORTS_NAMED_GROUPS &&
      REPLACE_KEEPS_$0 &&
      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    )) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
        }
        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
      }
      return { done: false };
    }, {
      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];

    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return regexMethod.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return regexMethod.call(string, this); }
    );
  }

  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__(130).charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(50);
var regexpExec = __webpack_require__(87);

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};



/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__(109);
var isRegExp = __webpack_require__(139);
var anObject = __webpack_require__(32);
var requireObjectCoercible = __webpack_require__(47);
var speciesConstructor = __webpack_require__(66);
var advanceStringIndex = __webpack_require__(110);
var toLength = __webpack_require__(27);
var callRegExpExec = __webpack_require__(111);
var regexpExec = __webpack_require__(87);
var fails = __webpack_require__(24);

var arrayPush = [].push;
var min = Math.min;
var MAX_UINT32 = 0xFFFFFFFF;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

// @@split logic
fixRegExpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'.split(/(b)*/)[1] == 'c' ||
    'test'.split(/(?:)/, -1).length != 4 ||
    'ab'.split(/(?:ab)*/).length != 2 ||
    '.'.split(/(.?)(.?)/).length != 4 ||
    '.'.split(/()()/).length > 1 ||
    ''.split(/.?/).length
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) {
        return nativeSplit.call(string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }
        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output.length > lim ? output.slice(0, lim) : output;
    };
  // Chakra, V8
  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [
    // `String.prototype.split` method
    // https://tc39.es/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = requireObjectCoercible(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
}, !SUPPORTS_Y);


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__(37);
var toAbsoluteIndex = __webpack_require__(52);
var toLength = __webpack_require__(27);

// `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__(109);
var anObject = __webpack_require__(32);
var toLength = __webpack_require__(27);
var toInteger = __webpack_require__(46);
var requireObjectCoercible = __webpack_require__(47);
var advanceStringIndex = __webpack_require__(110);
var getSubstitution = __webpack_require__(171);
var regExpExec = __webpack_require__(111);

var max = Math.max;
var min = Math.min;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
      return replacer !== undefined
        ? replacer.call(searchValue, O, replaceValue)
        : nativeReplace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      if (
        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||
        (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
      ) {
        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
        if (res.done) return res.value;
      }

      var rx = anObject(regexp);
      var S = String(this);

      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);

      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;

        results.push(result);
        if (!global) break;

        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];
});


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(30);
var fails = __webpack_require__(24);
var createElement = __webpack_require__(116);

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(26);
var isObject = __webpack_require__(29);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(94);

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(31);
var ownKeys = __webpack_require__(119);
var getOwnPropertyDescriptorModule = __webpack_require__(49);
var definePropertyModule = __webpack_require__(33);

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(58);
var getOwnPropertyNamesModule = __webpack_require__(59);
var getOwnPropertySymbolsModule = __webpack_require__(122);
var anObject = __webpack_require__(32);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(26);

module.exports = global;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(31);
var toIndexedObject = __webpack_require__(44);
var indexOf = __webpack_require__(70).indexOf;
var hiddenKeys = __webpack_require__(69);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 122 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_SYMBOL = __webpack_require__(98);

module.exports = NATIVE_SYMBOL
  // eslint-disable-next-line no-undef
  && !Symbol.sham
  // eslint-disable-next-line no-undef
  && typeof Symbol.iterator == 'symbol';


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(28);

exports.f = wellKnownSymbol;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(120);
var has = __webpack_require__(31);
var wrappedWellKnownSymbolModule = __webpack_require__(124);
var defineProperty = __webpack_require__(33).f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $forEach = __webpack_require__(35).forEach;
var arrayMethodIsStrict = __webpack_require__(54);
var arrayMethodUsesToLength = __webpack_require__(41);

var STRICT_METHOD = arrayMethodIsStrict('forEach');
var USES_TO_LENGTH = arrayMethodUsesToLength('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach
module.exports = (!STRICT_METHOD || !USES_TO_LENGTH) ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getPrototypeOf = __webpack_require__(63);
var createNonEnumerableProperty = __webpack_require__(40);
var has = __webpack_require__(31);
var wellKnownSymbol = __webpack_require__(28);
var IS_PURE = __webpack_require__(82);

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(24);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__(32);

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(46);
var requireObjectCoercible = __webpack_require__(47);

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING ? S.charAt(position) : first
        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),
/* 131 */
/***/ (function(module, exports) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(32);

module.exports = function (iterator) {
  var returnMethod = iterator['return'];
  if (returnMethod !== undefined) {
    return anObject(returnMethod.call(iterator)).value;
  }
};


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(22);

// `Number.MAX_SAFE_INTEGER` constant
// https://tc39.es/ecma262/#sec-number.max_safe_integer
$({ target: 'Number', stat: true }, {
  MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
});


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(22);

// `Number.MIN_SAFE_INTEGER` constant
// https://tc39.es/ecma262/#sec-number.min_safe_integer
$({ target: 'Number', stat: true }, {
  MIN_SAFE_INTEGER: -0x1FFFFFFFFFFFFF
});


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(24);

module.exports = !fails(function () {
  return Object.isExtensible(Object.preventExtensions({}));
});


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(32);
var isArrayIteratorMethod = __webpack_require__(102);
var toLength = __webpack_require__(27);
var bind = __webpack_require__(60);
var getIteratorMethod = __webpack_require__(103);
var iteratorClose = __webpack_require__(132);

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator);
      throw error;
    }
    if (typeof result == 'object' && result && result instanceof Result) return result;
  } return new Result(false);
};


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(48);

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__(58);
var definePropertyModule = __webpack_require__(33);
var wellKnownSymbol = __webpack_require__(28);
var DESCRIPTORS = __webpack_require__(30);

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(29);
var classof = __webpack_require__(50);
var wellKnownSymbol = __webpack_require__(28);

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__(109);
var anObject = __webpack_require__(32);
var toLength = __webpack_require__(27);
var requireObjectCoercible = __webpack_require__(47);
var advanceStringIndex = __webpack_require__(110);
var regExpExec = __webpack_require__(111);

// @@match logic
fixRegExpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.es/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = requireObjectCoercible(this);
      var matcher = regexp == undefined ? undefined : regexp[MATCH];
      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative(nativeMatch, regexp, this);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);

      if (!rx.global) return regExpExec(rx, S);

      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(26);
var DESCRIPTORS = __webpack_require__(30);
var NATIVE_ARRAY_BUFFER = __webpack_require__(142);
var createNonEnumerableProperty = __webpack_require__(40);
var redefineAll = __webpack_require__(137);
var fails = __webpack_require__(24);
var anInstance = __webpack_require__(86);
var toInteger = __webpack_require__(46);
var toLength = __webpack_require__(27);
var toIndex = __webpack_require__(143);
var IEEE754 = __webpack_require__(175);
var getPrototypeOf = __webpack_require__(63);
var setPrototypeOf = __webpack_require__(64);
var getOwnPropertyNames = __webpack_require__(59).f;
var defineProperty = __webpack_require__(33).f;
var arrayFill = __webpack_require__(113);
var setToStringTag = __webpack_require__(72);
var InternalStateModule = __webpack_require__(51);

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var $DataView = global[DATA_VIEW];
var $DataViewPrototype = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype = Object.prototype;
var RangeError = global.RangeError;

var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function (Constructor, key) {
  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState(this)[key]; } });
};

var get = function (view, count, index, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = bytes.slice(start, start + count);
  return isLittleEndian ? pack : pack.reverse();
};

var set = function (view, count, index, conversion, value, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);
  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};

if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    setInternalState(this, {
      bytes: arrayFill.call(new Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!DESCRIPTORS) this.byteLength = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = getInternalState(buffer).byteLength;
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    setInternalState(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset
    });
    if (!DESCRIPTORS) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, 'byteLength');
    addGetter($DataView, 'buffer');
    addGetter($DataView, 'byteLength');
    addGetter($DataView, 'byteOffset');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
    }
  });
} else {
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new NativeArrayBuffer(); // eslint-disable-line no-new
    new NativeArrayBuffer(1.5); // eslint-disable-line no-new
    new NativeArrayBuffer(NaN); // eslint-disable-line no-new
    return NativeArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new NativeArrayBuffer(toIndex(length));
    };
    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) {
        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
      }
    }
    ArrayBufferPrototype.constructor = $ArrayBuffer;
  }

  // WebKit bug - the same parent prototype for typed arrays and data view
  if (setPrototypeOf && getPrototypeOf($DataViewPrototype) !== ObjectPrototype) {
    setPrototypeOf($DataViewPrototype, ObjectPrototype);
  }

  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var nativeSetInt8 = $DataViewPrototype.setInt8;
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
    setInt8: function setInt8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, { unsafe: true });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);

module.exports = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView
};


/***/ }),
/* 142 */
/***/ (function(module, exports) {

module.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(46);
var toLength = __webpack_require__(27);

// `ToIndex` abstract operation
// https://tc39.es/ecma262/#sec-toindex
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length or index');
  return length;
};


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var toPositiveInteger = __webpack_require__(180);

module.exports = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw RangeError('Wrong offset');
  return offset;
};


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(146);
module.exports = __webpack_require__(207);


/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 147 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(26);
var inspectSource = __webpack_require__(117);

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(30);
var definePropertyModule = __webpack_require__(33);
var anObject = __webpack_require__(32);
var objectKeys = __webpack_require__(83);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(58);

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(44);
var nativeGetOwnPropertyNames = __webpack_require__(59).f;

var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]'
    ? getWindowNames(it)
    : nativeGetOwnPropertyNames(toIndexedObject(it));
};


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(58);

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IteratorPrototype = __webpack_require__(127).IteratorPrototype;
var create = __webpack_require__(53);
var createPropertyDescriptor = __webpack_require__(56);
var setToStringTag = __webpack_require__(72);
var Iterators = __webpack_require__(74);

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(29);

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(101);
var classof = __webpack_require__(85);

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__(61);
var isObject = __webpack_require__(29);

var slice = [].slice;
var factories = {};

var construct = function (C, argsLength, args) {
  if (!(argsLength in factories)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind
module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = slice.call(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = partArgs.concat(slice.call(arguments));
    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
  };
  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
  return boundFunction;
};


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray = __webpack_require__(71);
var toLength = __webpack_require__(27);
var bind = __webpack_require__(60);

// `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg, 3) : false;
  var element;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};

module.exports = flattenIntoArray;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var bind = __webpack_require__(60);
var toObject = __webpack_require__(37);
var callWithSafeIterationClosing = __webpack_require__(159);
var isArrayIteratorMethod = __webpack_require__(102);
var toLength = __webpack_require__(27);
var createProperty = __webpack_require__(75);
var getIteratorMethod = __webpack_require__(103);

// `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    result = new C();
    for (;!(step = next.call(iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = toLength(O.length);
    result = new C(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(32);
var iteratorClose = __webpack_require__(132);

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    iteratorClose(iterator);
    throw error;
  }
};


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(50);
var global = __webpack_require__(26);

module.exports = classof(global.process) == 'process';


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(47);
var whitespaces = __webpack_require__(162);

var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),
/* 162 */
/***/ (function(module, exports) {

// a string of all valid unicode whitespaces
// eslint-disable-next-line max-len
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(30);
var objectKeys = __webpack_require__(83);
var toIndexedObject = __webpack_require__(44);
var propertyIsEnumerable = __webpack_require__(92).f;

// `Object.{ entries, values }` methods implementation
var createMethod = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

module.exports = {
  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values
  values: createMethod(false)
};


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var global = __webpack_require__(26);
var isForced = __webpack_require__(97);
var redefine = __webpack_require__(48);
var InternalMetadataModule = __webpack_require__(107);
var iterate = __webpack_require__(136);
var anInstance = __webpack_require__(86);
var isObject = __webpack_require__(29);
var fails = __webpack_require__(24);
var checkCorrectnessOfIteration = __webpack_require__(104);
var setToStringTag = __webpack_require__(72);
var inheritIfRequired = __webpack_require__(106);

module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function (KEY) {
    var nativeMethod = NativePrototype[KEY];
    redefine(NativePrototype, KEY,
      KEY == 'add' ? function add(value) {
        nativeMethod.call(this, value === 0 ? 0 : value);
        return this;
      } : KEY == 'delete' ? function (key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'get' ? function get(key) {
        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'has' ? function has(key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        nativeMethod.call(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };

  // eslint-disable-next-line max-len
  if (isForced(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
    new NativeConstructor().entries().next();
  })))) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.REQUIRED = true;
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({ global: true, forced: Constructor != NativeConstructor }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var defineProperty = __webpack_require__(33).f;
var create = __webpack_require__(53);
var redefineAll = __webpack_require__(137);
var bind = __webpack_require__(60);
var anInstance = __webpack_require__(86);
var iterate = __webpack_require__(136);
var defineIterator = __webpack_require__(100);
var setSpecies = __webpack_require__(138);
var DESCRIPTORS = __webpack_require__(30);
var fastKey = __webpack_require__(107).fastKey;
var InternalStateModule = __webpack_require__(51);

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;
        else that.size = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;
          else that.size--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    redefineAll(C.prototype, IS_MAP ? {
      // 23.1.3.6 Map.prototype.get(key)
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // 23.1.3.9 Map.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // 23.2.3.1 Set.prototype.add(value)
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineProperty(C.prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return C;
  },
  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return { value: undefined, done: true };
      }
      // return step by kind
      if (kind == 'keys') return { value: entry.key, done: false };
      if (kind == 'values') return { value: entry.value, done: false };
      return { value: [entry.key, entry.value], done: false };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(CONSTRUCTOR_NAME);
  }
};


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var isRegExp = __webpack_require__(139);

module.exports = function (it) {
  if (isRegExp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  } return it;
};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(28);

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) { /* empty */ }
  } return false;
};


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__(24);

// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
// so we use an intermediate function.
function RE(s, f) {
  return RegExp(s, f);
}

exports.UNSUPPORTED_Y = fails(function () {
  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var re = RE('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

exports.BROKEN_CARET = fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = RE('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(50);

// `thisNumberValue` abstract operation
// https://tc39.es/ecma262/#sec-thisnumbervalue
module.exports = function (value) {
  if (typeof value != 'number' && classof(value) != 'Number') {
    throw TypeError('Incorrect invocation');
  }
  return +value;
};


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(46);
var requireObjectCoercible = __webpack_require__(47);

// `String.prototype.repeat` method implementation
// https://tc39.es/ecma262/#sec-string.prototype.repeat
module.exports = ''.repeat || function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var toObject = __webpack_require__(37);

var floor = Math.floor;
var replace = ''.replace;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

// https://tc39.es/ecma262/#sec-getsubstitution
module.exports = function (matched, str, position, captures, namedCaptures, replacement) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== undefined) {
    namedCaptures = toObject(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace.call(replacement, symbols, function (match, ch) {
    var capture;
    switch (ch.charAt(0)) {
      case '$': return '$';
      case '&': return matched;
      case '`': return str.slice(0, position);
      case "'": return str.slice(tailPos);
      case '<':
        capture = namedCaptures[ch.slice(1, -1)];
        break;
      default: // \d\d?
        var n = +ch;
        if (n === 0) return match;
        if (n > m) {
          var f = floor(n / 10);
          if (f === 0) return match;
          if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
          return match;
        }
        capture = captures[n - 1];
    }
    return capture === undefined ? '' : capture;
  });
};


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(47);

var quot = /"/g;

// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
// https://tc39.es/ecma262/#sec-createhtml
module.exports = function (string, tag, attribute, value) {
  var S = String(requireObjectCoercible(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(24);

// check the existence of a method, lowercase
// of a tag and escaping quotes in arguments
module.exports = function (METHOD_NAME) {
  return fails(function () {
    var test = ''[METHOD_NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  });
};


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var fails = __webpack_require__(24);
var ArrayBufferModule = __webpack_require__(141);
var anObject = __webpack_require__(32);
var toAbsoluteIndex = __webpack_require__(52);
var toLength = __webpack_require__(27);
var speciesConstructor = __webpack_require__(66);

var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var nativeArrayBufferSlice = ArrayBuffer.prototype.slice;

var INCORRECT_SLICE = fails(function () {
  return !new ArrayBuffer(2).slice(1, undefined).byteLength;
});

// `ArrayBuffer.prototype.slice` method
// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice
$({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice !== undefined && end === undefined) {
      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
    }
    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new (speciesConstructor(this, ArrayBuffer))(toLength(fin - first));
    var viewSource = new DataView(this);
    var viewTarget = new DataView(result);
    var index = 0;
    while (first < fin) {
      viewTarget.setUint8(index++, viewSource.getUint8(first++));
    } return result;
  }
});


/***/ }),
/* 175 */
/***/ (function(module, exports) {

// IEEE754 conversions based on https://github.com/feross/ieee754
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = 1 / 0;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

var pack = function (number, mantissaLength, bytes) {
  var buffer = new Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare
  if (number != number || number === Infinity) {
    // eslint-disable-next-line no-self-compare
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor(log(number) / LN2);
    if (number * (c = pow(2, -exponent)) < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
  buffer[--index] |= sign * 128;
  return buffer;
};

var unpack = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

module.exports = {
  pack: pack,
  unpack: unpack
};


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(22);
var FREEZING = __webpack_require__(135);
var fails = __webpack_require__(24);
var isObject = __webpack_require__(29);
var onFreeze = __webpack_require__(107).onFreeze;

var nativeFreeze = Object.freeze;
var FAILS_ON_PRIMITIVES = fails(function () { nativeFreeze(1); });

// `Object.freeze` method
// https://tc39.es/ecma262/#sec-object.freeze
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  freeze: function freeze(it) {
    return nativeFreeze && isObject(it) ? nativeFreeze(onFreeze(it)) : it;
  }
});


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var createTypedArrayConstructor = __webpack_require__(178);

// `Uint8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint8', function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(22);
var global = __webpack_require__(26);
var DESCRIPTORS = __webpack_require__(30);
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(179);
var ArrayBufferViewCore = __webpack_require__(25);
var ArrayBufferModule = __webpack_require__(141);
var anInstance = __webpack_require__(86);
var createPropertyDescriptor = __webpack_require__(56);
var createNonEnumerableProperty = __webpack_require__(40);
var toLength = __webpack_require__(27);
var toIndex = __webpack_require__(143);
var toOffset = __webpack_require__(144);
var toPrimitive = __webpack_require__(57);
var has = __webpack_require__(31);
var classof = __webpack_require__(85);
var isObject = __webpack_require__(29);
var create = __webpack_require__(53);
var setPrototypeOf = __webpack_require__(64);
var getOwnPropertyNames = __webpack_require__(59).f;
var typedArrayFrom = __webpack_require__(181);
var forEach = __webpack_require__(35).forEach;
var setSpecies = __webpack_require__(138);
var definePropertyModule = __webpack_require__(33);
var getOwnPropertyDescriptorModule = __webpack_require__(49);
var InternalStateModule = __webpack_require__(51);
var inheritIfRequired = __webpack_require__(106);

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var round = Math.round;
var RangeError = global.RangeError;
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var isTypedArray = ArrayBufferViewCore.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';

var fromList = function (C, list) {
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
};

var addGetter = function (it, key) {
  nativeDefineProperty(it, key, { get: function () {
    return getInternalState(this)[key];
  } });
};

var isArrayBuffer = function (it) {
  var klass;
  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};

var isTypedArrayIndex = function (target, key) {
  return isTypedArray(target)
    && typeof key != 'symbol'
    && key in target
    && String(+key) == String(key);
};

var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
  return isTypedArrayIndex(target, key = toPrimitive(key, true))
    ? createPropertyDescriptor(2, target[key])
    : nativeGetOwnPropertyDescriptor(target, key);
};

var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
  if (isTypedArrayIndex(target, key = toPrimitive(key, true))
    && isObject(descriptor)
    && has(descriptor, 'value')
    && !has(descriptor, 'get')
    && !has(descriptor, 'set')
    // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable
    && (!has(descriptor, 'writable') || descriptor.writable)
    && (!has(descriptor, 'enumerable') || descriptor.enumerable)
  ) {
    target[key] = descriptor.value;
    return target;
  } return nativeDefineProperty(target, key, descriptor);
};

if (DESCRIPTORS) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype, 'buffer');
    addGetter(TypedArrayPrototype, 'byteOffset');
    addGetter(TypedArrayPrototype, 'byteLength');
    addGetter(TypedArrayPrototype, 'length');
  }

  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });

  module.exports = function (TYPE, wrapper, CLAMPED) {
    var BYTES = TYPE.match(/\d+$/)[0] / 8;
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};

    var getter = function (that, index) {
      var data = getInternalState(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };

    var setter = function (that, index, value) {
      var data = getInternalState(that);
      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
    };

    var addElement = function (that, index) {
      nativeDefineProperty(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer(byteLength);
        } else if (isArrayBuffer(data)) {
          buffer = data;
          byteOffset = toOffset(offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray(data)) {
          return fromList(TypedArrayConstructor, data);
        } else {
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }
        setInternalState(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
        return inheritIfRequired(function () {
          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
          if (isArrayBuffer(data)) return $length !== undefined
            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
            : typedArrayOffset !== undefined
              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
              : new NativeTypedArrayConstructor(data);
          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }(), dummy, TypedArrayConstructor);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        }
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }

    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }

    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
    }

    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

    $({
      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS
    }, exported);

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }

    setSpecies(CONSTRUCTOR_NAME);
  };
} else module.exports = function () { /* empty */ };


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-new */
var global = __webpack_require__(26);
var fails = __webpack_require__(24);
var checkCorrectnessOfIteration = __webpack_require__(104);
var NATIVE_ARRAY_BUFFER_VIEWS = __webpack_require__(25).NATIVE_ARRAY_BUFFER_VIEWS;

var ArrayBuffer = global.ArrayBuffer;
var Int8Array = global.Int8Array;

module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
  Int8Array(1);
}) || !fails(function () {
  new Int8Array(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array();
  new Int8Array(null);
  new Int8Array(1.5);
  new Int8Array(iterable);
}, true) || fails(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
});


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(46);

module.exports = function (it) {
  var result = toInteger(it);
  if (result < 0) throw RangeError("The argument can't be less than 0");
  return result;
};


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var toObject = __webpack_require__(37);
var toLength = __webpack_require__(27);
var getIteratorMethod = __webpack_require__(103);
var isArrayIteratorMethod = __webpack_require__(102);
var bind = __webpack_require__(60);
var aTypedArrayConstructor = __webpack_require__(25).aTypedArrayConstructor;

module.exports = function from(source /* , mapfn, thisArg */) {
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator, next;
  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    O = [];
    while (!(step = next.call(iterator)).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind(mapfn, arguments[2], 2);
  }
  length = toLength(O.length);
  result = new (aTypedArrayConstructor(this))(length);
  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }
  return result;
};


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var $copyWithin = __webpack_require__(183);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.copyWithin` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
exportTypedArrayMethod('copyWithin', function copyWithin(target, start /* , end */) {
  return $copyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__(37);
var toAbsoluteIndex = __webpack_require__(52);
var toLength = __webpack_require__(27);

var min = Math.min;

// `Array.prototype.copyWithin` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.copywithin
module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var $every = __webpack_require__(35).every;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.every` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
exportTypedArrayMethod('every', function every(callbackfn /* , thisArg */) {
  return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var $fill = __webpack_require__(113);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.fill` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars
exportTypedArrayMethod('fill', function fill(value /* , start, end */) {
  return $fill.apply(aTypedArray(this), arguments);
});


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var $filter = __webpack_require__(35).filter;
var speciesConstructor = __webpack_require__(66);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.filter` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
exportTypedArrayMethod('filter', function filter(callbackfn /* , thisArg */) {
  var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
});


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var $find = __webpack_require__(35).find;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.find` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
exportTypedArrayMethod('find', function find(predicate /* , thisArg */) {
  return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var $findIndex = __webpack_require__(35).findIndex;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
exportTypedArrayMethod('findIndex', function findIndex(predicate /* , thisArg */) {
  return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var $forEach = __webpack_require__(35).forEach;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.forEach` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
exportTypedArrayMethod('forEach', function forEach(callbackfn /* , thisArg */) {
  $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var $includes = __webpack_require__(70).includes;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.includes` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
exportTypedArrayMethod('includes', function includes(searchElement /* , fromIndex */) {
  return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var $indexOf = __webpack_require__(70).indexOf;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
exportTypedArrayMethod('indexOf', function indexOf(searchElement /* , fromIndex */) {
  return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(26);
var ArrayBufferViewCore = __webpack_require__(25);
var ArrayIterators = __webpack_require__(5);
var wellKnownSymbol = __webpack_require__(28);

var ITERATOR = wellKnownSymbol('iterator');
var Uint8Array = global.Uint8Array;
var arrayValues = ArrayIterators.values;
var arrayKeys = ArrayIterators.keys;
var arrayEntries = ArrayIterators.entries;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR];

var CORRECT_ITER_NAME = !!nativeTypedArrayIterator
  && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

var typedArrayValues = function values() {
  return arrayValues.call(aTypedArray(this));
};

// `%TypedArray%.prototype.entries` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
exportTypedArrayMethod('entries', function entries() {
  return arrayEntries.call(aTypedArray(this));
});
// `%TypedArray%.prototype.keys` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
exportTypedArrayMethod('keys', function keys() {
  return arrayKeys.call(aTypedArray(this));
});
// `%TypedArray%.prototype.values` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
exportTypedArrayMethod('values', typedArrayValues, !CORRECT_ITER_NAME);
// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
exportTypedArrayMethod(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $join = [].join;

// `%TypedArray%.prototype.join` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
// eslint-disable-next-line no-unused-vars
exportTypedArrayMethod('join', function join(separator) {
  return $join.apply(aTypedArray(this), arguments);
});


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var $lastIndexOf = __webpack_require__(195);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
// eslint-disable-next-line no-unused-vars
exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
  return $lastIndexOf.apply(aTypedArray(this), arguments);
});


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(44);
var toInteger = __webpack_require__(46);
var toLength = __webpack_require__(27);
var arrayMethodIsStrict = __webpack_require__(54);
var arrayMethodUsesToLength = __webpack_require__(41);

var min = Math.min;
var nativeLastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });
var FORCED = NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH;

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
module.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;
  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
  return -1;
} : nativeLastIndexOf;


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var $map = __webpack_require__(35).map;
var speciesConstructor = __webpack_require__(66);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.map` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
exportTypedArrayMethod('map', function map(mapfn /* , thisArg */) {
  return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
    return new (aTypedArrayConstructor(speciesConstructor(O, O.constructor)))(length);
  });
});


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var $reduce = __webpack_require__(105).left;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduce` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
exportTypedArrayMethod('reduce', function reduce(callbackfn /* , initialValue */) {
  return $reduce(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var $reduceRight = __webpack_require__(105).right;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduceRicht` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
  return $reduceRight(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var floor = Math.floor;

// `%TypedArray%.prototype.reverse` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
exportTypedArrayMethod('reverse', function reverse() {
  var that = this;
  var length = aTypedArray(that).length;
  var middle = floor(length / 2);
  var index = 0;
  var value;
  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  } return that;
});


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var toLength = __webpack_require__(27);
var toOffset = __webpack_require__(144);
var toObject = __webpack_require__(37);
var fails = __webpack_require__(24);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

var FORCED = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).set({});
});

// `%TypedArray%.prototype.set` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod('set', function set(arrayLike /* , offset */) {
  aTypedArray(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var length = this.length;
  var src = toObject(arrayLike);
  var len = toLength(src.length);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, FORCED);


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var speciesConstructor = __webpack_require__(66);
var fails = __webpack_require__(24);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $slice = [].slice;

var FORCED = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).slice();
});

// `%TypedArray%.prototype.slice` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
exportTypedArrayMethod('slice', function slice(start, end) {
  var list = $slice.call(aTypedArray(this), start, end);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
}, FORCED);


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var $some = __webpack_require__(35).some;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.some` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
exportTypedArrayMethod('some', function some(callbackfn /* , thisArg */) {
  return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $sort = [].sort;

// `%TypedArray%.prototype.sort` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
exportTypedArrayMethod('sort', function sort(comparefn) {
  return $sort.call(aTypedArray(this), comparefn);
});


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(25);
var toLength = __webpack_require__(27);
var toAbsoluteIndex = __webpack_require__(52);
var speciesConstructor = __webpack_require__(66);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.subarray` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
exportTypedArrayMethod('subarray', function subarray(begin, end) {
  var O = aTypedArray(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  return new (speciesConstructor(O, O.constructor))(
    O.buffer,
    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
  );
});


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(26);
var ArrayBufferViewCore = __webpack_require__(25);
var fails = __webpack_require__(24);

var Int8Array = global.Int8Array;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;
var $slice = [].slice;

// iOS Safari 6.x fails here
var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function () {
  $toLocaleString.call(new Int8Array(1));
});

var FORCED = fails(function () {
  return [1, 2].toLocaleString() != new Int8Array([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array.prototype.toLocaleString.call([1, 2]);
});

// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
exportTypedArrayMethod('toLocaleString', function toLocaleString() {
  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this), arguments);
}, FORCED);


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var exportTypedArrayMethod = __webpack_require__(25).exportTypedArrayMethod;
var fails = __webpack_require__(24);
var global = __webpack_require__(26);

var Uint8Array = global.Uint8Array;
var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {};
var arrayToString = [].toString;
var arrayJoin = [].join;

if (fails(function () { arrayToString.call({}); })) {
  arrayToString = function toString() {
    return arrayJoin.call(this);
  };
}

var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

// `%TypedArray%.prototype.toString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);


/***/ }),
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ src_Chart; });
__webpack_require__.d(__webpack_exports__, "LineChart", function() { return /* reexport */ lineChart_LineChart; });
__webpack_require__.d(__webpack_exports__, "AreaChart", function() { return /* reexport */ areaChart_AreaChart; });
__webpack_require__.d(__webpack_exports__, "BarChart", function() { return /* reexport */ barChart_BarChart; });
__webpack_require__.d(__webpack_exports__, "ColumnChart", function() { return /* reexport */ columnChart_ColumnChart; });
__webpack_require__.d(__webpack_exports__, "PieChart", function() { return /* reexport */ pieChart_PieChart; });
__webpack_require__.d(__webpack_exports__, "HeatmapChart", function() { return /* reexport */ heatmapChart_HeatmapChart; });
__webpack_require__.d(__webpack_exports__, "BubbleChart", function() { return /* reexport */ bubbleChart_BubbleChart; });
__webpack_require__.d(__webpack_exports__, "ScatterChart", function() { return /* reexport */ scatterChart_ScatterChart; });
__webpack_require__.d(__webpack_exports__, "BulletChart", function() { return /* reexport */ bulletChart_BulletChart; });
__webpack_require__.d(__webpack_exports__, "RadarChart", function() { return /* reexport */ radarChart_RadarChart; });
__webpack_require__.d(__webpack_exports__, "TreemapChart", function() { return /* reexport */ treemapChart_TreemapChart; });
__webpack_require__.d(__webpack_exports__, "NestedPieChart", function() { return /* reexport */ nestedPieChart_NestedPieChart; });
__webpack_require__.d(__webpack_exports__, "LineAreaChart", function() { return /* reexport */ lineAreaChart_LineAreaChart; });
__webpack_require__.d(__webpack_exports__, "LineScatterChart", function() { return /* reexport */ lineScatterChart_LineScatterChart; });
__webpack_require__.d(__webpack_exports__, "ColumnLineChart", function() { return /* reexport */ columnLineChart_ColumnLineChart; });
__webpack_require__.d(__webpack_exports__, "BoxPlotChart", function() { return /* reexport */ boxPlotChart_BoxPlotChart; });

// NAMESPACE OBJECT: ./src/brushes/basic.ts
var basic_namespaceObject = {};
__webpack_require__.r(basic_namespaceObject);
__webpack_require__.d(basic_namespaceObject, "clipRectArea", function() { return clipRectArea; });
__webpack_require__.d(basic_namespaceObject, "pathRect", function() { return pathRect; });
__webpack_require__.d(basic_namespaceObject, "circle", function() { return basic_circle; });
__webpack_require__.d(basic_namespaceObject, "line", function() { return basic_line; });
__webpack_require__.d(basic_namespaceObject, "rect", function() { return basic_rect; });

// NAMESPACE OBJECT: ./src/brushes/label.ts
var label_namespaceObject = {};
__webpack_require__.r(label_namespaceObject);
__webpack_require__.d(label_namespaceObject, "DEFAULT_LABEL_TEXT", function() { return DEFAULT_LABEL_TEXT; });
__webpack_require__.d(label_namespaceObject, "labelStyle", function() { return labelStyle; });
__webpack_require__.d(label_namespaceObject, "strokeLabelStyle", function() { return strokeLabelStyle; });
__webpack_require__.d(label_namespaceObject, "label", function() { return label_label; });
__webpack_require__.d(label_namespaceObject, "rectLabel", function() { return rectLabel; });
__webpack_require__.d(label_namespaceObject, "bubbleLabel", function() { return bubbleLabel; });

// NAMESPACE OBJECT: ./src/brushes/axis.ts
var axis_namespaceObject = {};
__webpack_require__.r(axis_namespaceObject);
__webpack_require__.d(axis_namespaceObject, "TICK_SIZE", function() { return TICK_SIZE; });
__webpack_require__.d(axis_namespaceObject, "tick", function() { return tick; });

// NAMESPACE OBJECT: ./src/brushes/dataLabel.ts
var dataLabel_namespaceObject = {};
__webpack_require__.r(dataLabel_namespaceObject);
__webpack_require__.d(dataLabel_namespaceObject, "dataLabel", function() { return dataLabel_dataLabel; });
__webpack_require__.d(dataLabel_namespaceObject, "drawBubbleLabel", function() { return drawBubbleLabel; });
__webpack_require__.d(dataLabel_namespaceObject, "getBubbleArrowPoints", function() { return getBubbleArrowPoints; });

// NAMESPACE OBJECT: ./src/brushes/spectrumLegend.ts
var spectrumLegend_namespaceObject = {};
__webpack_require__.r(spectrumLegend_namespaceObject);
__webpack_require__.d(spectrumLegend_namespaceObject, "SPECTRUM_LEGEND_LABEL_HEIGHT", function() { return SPECTRUM_LEGEND_LABEL_HEIGHT; });
__webpack_require__.d(spectrumLegend_namespaceObject, "spectrumLegendBar", function() { return spectrumLegendBar; });
__webpack_require__.d(spectrumLegend_namespaceObject, "spectrumLegendTooltip", function() { return spectrumLegendTooltip; });
__webpack_require__.d(spectrumLegend_namespaceObject, "spectrumLegend", function() { return spectrumLegend; });
__webpack_require__.d(spectrumLegend_namespaceObject, "spectrumTooltip", function() { return spectrumTooltip; });

// NAMESPACE OBJECT: ./src/brushes/polygon.ts
var polygon_namespaceObject = {};
__webpack_require__.r(polygon_namespaceObject);
__webpack_require__.d(polygon_namespaceObject, "polygon", function() { return polygon; });

// NAMESPACE OBJECT: ./src/brushes/scatterSeries.ts
var scatterSeries_namespaceObject = {};
__webpack_require__.r(scatterSeries_namespaceObject);
__webpack_require__.d(scatterSeries_namespaceObject, "scatterSeries", function() { return scatterSeries_scatterSeries; });

// NAMESPACE OBJECT: ./src/brushes/legend.ts
var legend_namespaceObject = {};
__webpack_require__.r(legend_namespaceObject);
__webpack_require__.d(legend_namespaceObject, "LEGEND_ITEM_MARGIN_X", function() { return LEGEND_ITEM_MARGIN_X; });
__webpack_require__.d(legend_namespaceObject, "LEGEND_MARGIN_X", function() { return LEGEND_MARGIN_X; });
__webpack_require__.d(legend_namespaceObject, "LEGEND_MARGIN_Y", function() { return LEGEND_MARGIN_Y; });
__webpack_require__.d(legend_namespaceObject, "LEGEND_CHECKBOX_SIZE", function() { return LEGEND_CHECKBOX_SIZE; });
__webpack_require__.d(legend_namespaceObject, "LEGEND_ICON_SIZE", function() { return LEGEND_ICON_SIZE; });
__webpack_require__.d(legend_namespaceObject, "getLegendItemHeight", function() { return getLegendItemHeight; });
__webpack_require__.d(legend_namespaceObject, "legend", function() { return legend_legend; });

// NAMESPACE OBJECT: ./src/brushes/lineSeries.ts
var brushes_lineSeries_namespaceObject = {};
__webpack_require__.r(brushes_lineSeries_namespaceObject);
__webpack_require__.d(brushes_lineSeries_namespaceObject, "linePoints", function() { return lineSeries_linePoints; });
__webpack_require__.d(brushes_lineSeries_namespaceObject, "areaPoints", function() { return lineSeries_areaPoints; });

// NAMESPACE OBJECT: ./src/brushes/exportMenu.ts
var brushes_exportMenu_namespaceObject = {};
__webpack_require__.r(brushes_exportMenu_namespaceObject);
__webpack_require__.d(brushes_exportMenu_namespaceObject, "exportMenuButton", function() { return exportMenuButton; });

// NAMESPACE OBJECT: ./src/brushes/resetButton.ts
var brushes_resetButton_namespaceObject = {};
__webpack_require__.r(brushes_resetButton_namespaceObject);
__webpack_require__.d(brushes_resetButton_namespaceObject, "backButton", function() { return backButton; });
__webpack_require__.d(brushes_resetButton_namespaceObject, "resetButton", function() { return resetButton_resetButton; });

// NAMESPACE OBJECT: ./src/brushes/sector.ts
var brushes_sector_namespaceObject = {};
__webpack_require__.r(brushes_sector_namespaceObject);
__webpack_require__.d(brushes_sector_namespaceObject, "sector", function() { return sector_sector; });

// NAMESPACE OBJECT: ./src/brushes/circleLegend.ts
var brushes_circleLegend_namespaceObject = {};
__webpack_require__.r(brushes_circleLegend_namespaceObject);
__webpack_require__.d(brushes_circleLegend_namespaceObject, "circleLegend", function() { return circleLegend_circleLegend; });

// NAMESPACE OBJECT: ./src/brushes/boxPlot.ts
var boxPlot_namespaceObject = {};
__webpack_require__.r(boxPlot_namespaceObject);
__webpack_require__.d(boxPlot_namespaceObject, "boxPlot", function() { return boxPlot; });

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.js
var es_symbol = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.description.js
var es_symbol_description = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.iterator.js
var es_symbol_iterator = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.filter.js
var es_array_filter = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.for-each.js
var es_array_for_each = __webpack_require__(1);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.iterator.js
var es_array_iterator = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-own-property-descriptor.js
var es_object_get_own_property_descriptor = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-own-property-descriptors.js
var es_object_get_own_property_descriptors = __webpack_require__(13);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-prototype-of.js
var es_object_get_prototype_of = __webpack_require__(17);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.keys.js
var es_object_keys = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.set-prototype-of.js
var es_object_set_prototype_of = __webpack_require__(18);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.reflect.construct.js
var es_reflect_construct = __webpack_require__(19);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.reflect.get.js
var es_reflect_get = __webpack_require__(36);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js
var es_regexp_to_string = __webpack_require__(11);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
var es_string_iterator = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
var web_dom_collections_for_each = __webpack_require__(2);

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
var es_array_concat = __webpack_require__(15);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.from.js
var es_array_from = __webpack_require__(21);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js
var es_array_map = __webpack_require__(16);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.slice.js
var es_array_slice = __webpack_require__(20);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.some.js
var es_array_some = __webpack_require__(43);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js
var es_function_name = __webpack_require__(14);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.splice.js
var es_array_splice = __webpack_require__(67);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __webpack_require__(55);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.split.js
var es_string_split = __webpack_require__(112);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.find-index.js
var es_array_find_index = __webpack_require__(79);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.includes.js
var es_array_includes = __webpack_require__(65);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.index-of.js
var es_array_index_of = __webpack_require__(90);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.every.js
var es_array_every = __webpack_require__(108);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.find.js
var es_array_find = __webpack_require__(42);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.reduce.js
var es_array_reduce = __webpack_require__(23);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.constructor.js
var es_number_constructor = __webpack_require__(34);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.to-fixed.js
var es_number_to_fixed = __webpack_require__(89);

// CONCATENATED MODULE: ./src/helpers/utils.ts

























function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isExist(value) {
  return !isUndefined(value) && !isNull(value);
}
function isDate(value) {
  return value instanceof Date;
}
function isUndefined(value) {
  return typeof value === 'undefined';
}
function isNull(value) {
  return value === null;
}
function isBoolean(value) {
  return typeof value === 'boolean';
}
function isNumber(value) {
  return typeof value === 'number';
}
function isString(value) {
  return typeof value === 'string';
}
function isInteger(value) {
  return isNumber(value) && isFinite(value) && Math.floor(value) === value;
}
function isObject(obj) {
  return _typeof(obj) === 'object' && obj !== null;
}
function isFunction(value) {
  return typeof value === 'function';
}
function forEach(obj, cb) {
  for (var _key in obj) {
    if (obj.hasOwnProperty(_key)) {
      cb(obj[_key], _key);
    }
  }
}
function utils_range(start, stop, step) {
  if (isUndefined(stop)) {
    stop = start || 0;
    start = 0;
  }

  step = step || 1;
  var arr = [];

  if (stop) {
    var flag = step < 0 ? -1 : 1;
    stop *= flag;

    for (; start * flag < stop; start += step) {
      arr.push(start);
    }
  }

  return arr;
}
function includes(arr, searchItem, searchIndex) {
  if (typeof searchIndex === 'number' && arr[searchIndex] !== searchItem) {
    return false;
  }

  var _iterator = _createForOfIteratorHelper(arr),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _item = _step.value;

      if (_item === searchItem) {
        return true;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return false;
}
function pick(obj) {
  for (var _len = arguments.length, propNames = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
    propNames[_key2 - 1] = arguments[_key2];
  }

  var resultMap = {};
  Object.keys(obj).forEach(function (key) {
    if (includes(propNames, key)) {
      resultMap[key] = obj[key];
    }
  });
  return resultMap;
}
function omit(obj) {
  for (var _len2 = arguments.length, propNames = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
    propNames[_key3 - 1] = arguments[_key3];
  }

  var resultMap = {};
  Object.keys(obj).forEach(function (key) {
    if (!includes(propNames, key)) {
      resultMap[key] = obj[key];
    }
  });
  return resultMap;
}
function pickProperty(target, keys) {
  var length = keys.length;

  if (length) {
    for (var i = 0; i < length; i += 1) {
      if (isUndefined(target) || isNull(target)) {
        return null;
      }

      target = target[keys[i]];
    }
  }

  return target;
}
function pickPropertyWithMakeup(target, args) {
  var length = args.length;

  if (length) {
    for (var i = 0; i < length; i += 1) {
      if (isUndefined(target[args[i]])) {
        target[args[i]] = {};
      }

      target = target[args[i]];
    }
  }

  return target;
}
function debounce(fn) {
  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var timer;

  function debounced() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
      args[_key4] = arguments[_key4];
    }

    window.clearTimeout(timer);
    timer = window.setTimeout(function () {
      fn.apply(void 0, args);
    }, delay);
  }

  return debounced;
}
function merge(target) {
  target = target || {};

  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key5 = 1; _key5 < _len4; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }

  args.forEach(function (obj) {
    if (!obj) {
      return;
    }

    forEach(obj, function (item, key) {
      if (Object.prototype.toString.call(item) === '[object Object]') {
        target[key] = merge(target[key], item);
      } else {
        target[key] = item;
      }
    });
  });
  return target;
}
function throttle(fn) {
  var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var base = null;
  var isLeading = true;

  var tick = function tick() {
    fn.apply(void 0, arguments);
    base = null;
  };

  var stamp = 0;
  var debounced = debounce(tick, interval);

  function throttled() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {
      args[_key6] = arguments[_key6];
    }

    if (isLeading) {
      tick.apply(void 0, args);
      isLeading = false;
      return;
    }

    stamp = Number(new Date());
    base = base || stamp;
    debounced(args);

    if (stamp - base >= interval) {
      tick(args);
    }
  }

  function reset() {
    // eslint-disable-line require-jsdoc
    isLeading = true;
    base = null;
  }

  throttled.reset = reset;
  return throttled;
}
function deepMergedCopy(targetObj, obj) {
  var resultObj = _objectSpread({}, targetObj);

  Object.keys(obj).forEach(function (prop) {
    if (isObject(resultObj[prop])) {
      if (Array.isArray(obj[prop])) {
        resultObj[prop] = deepCopyArray(obj[prop]);
      } else if (resultObj.hasOwnProperty(prop)) {
        resultObj[prop] = deepMergedCopy(resultObj[prop], obj[prop]);
      } else {
        resultObj[prop] = deepCopy(obj[prop]);
      }
    } else {
      resultObj[prop] = obj[prop];
    }
  });
  return resultObj;
}
function deepCopyArray(items) {
  return items.map(function (item) {
    if (isObject(item)) {
      return Array.isArray(item) ? deepCopyArray(item) : deepCopy(item);
    }

    return item;
  });
}
function deepCopy(obj) {
  var resultObj = {};
  var keys = Object.keys(obj);

  if (!keys.length) {
    return obj;
  }

  keys.forEach(function (prop) {
    if (isObject(obj[prop])) {
      resultObj[prop] = Array.isArray(obj[prop]) ? deepCopyArray(obj[prop]) : deepCopy(obj[prop]);
    } else {
      resultObj[prop] = obj[prop];
    }
  });
  return resultObj;
}
function sortCategories(x, y) {
  return isInteger(x) ? Number(x) - Number(y) : new Date(x).getTime() - new Date(y).getTime();
}
function sortNumber(x, y) {
  return x - y;
}
function first(items) {
  // eslint-disable-next-line no-undefined
  return items.length ? items[0] : undefined;
}
function last(items) {
  // eslint-disable-next-line no-undefined
  return items.length ? items[items.length - 1] : undefined;
}
function hasNegative() {
  var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return values.some(function (value) {
    return Number(value) < 0;
  });
}
function sum(items) {
  return items.reduce(function (a, b) {
    return a + b;
  }, 0);
}
function hasPositiveOnly(values) {
  return values.every(function (value) {
    return Number(value) >= 0;
  });
}
function hasNegativeOnly(values) {
  return values.every(function (value) {
    return Number(value) <= 0;
  });
}
function getFirstValidValue(values) {
  return values.find(function (value) {
    return value !== null;
  });
}
function getPercentageValue(text) {
  return Number(text.substr(0, text.length - 1));
}
function calculateSizeWithPercentString(size, value) {
  return isNumber(value) ? value : Number((size * getPercentageValue(value) / 100).toFixed(2));
}
function getInitialSize(size) {
  return isNumber(size) ? size : 0;
}
function isAutoValue(value) {
  return value === 'auto';
}
// CONCATENATED MODULE: ./src/message.ts
var message = {
  SELECT_SERIES_API_SELECTABLE_ERROR: 'It works only when the selectable option is true.',
  SELECT_SERIES_API_INDEX_ERROR: 'The index value is invalid.',
  ALREADY_OBSERVABLE_ERROR: 'Source object is observable already',
  CIRCLE_LEGEND_RENDER_ERROR: 'circleLegend is only possible when bubble series is present',
  noDataError: function noDataError(chartName) {
    return "There's no ".concat(chartName, " data!");
  },
  noBrushError: function noBrushError(brushName) {
    return "Brush don't exist in painter: ".concat(brushName);
  },
  DASH_SEGMENTS_UNAVAILABLE_ERROR: 'DashSegments option is available from IE11 and above.'
};
// CONCATENATED MODULE: ./src/store/reactive.ts

















function reactive_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function reactive_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { reactive_typeof = function _typeof(obj) { return typeof obj; }; } else { reactive_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return reactive_typeof(obj); }



var currentCollectorObserver = null;
var currentRunningObserver = null;
var observerCallCue = [];
var doingInvisibleWork = false;
function reactive_observe(fn) {
  var observer = function observer() {
    if (currentRunningObserver === observer) {
      return;
    } // If there is observer running or doing invisible work


    if (doingInvisibleWork || !isNull(currentRunningObserver)) {
      if (observerCallCue.includes(observer)) {
        observerCallCue.splice(observerCallCue.indexOf(observer), 1);
      } // We use observer call cue because avoid nested observer call.


      observerCallCue.push(observer); // or If there are no observers running. Run the observer and run the next observer in the call queue.
    } else if (isNull(currentRunningObserver)) {
      currentRunningObserver = observer;
      fn();
      currentRunningObserver = null;
      digestObserverCallCue();
    }
  };

  observer.deps = []; // first observer excution for collect dependencies

  currentCollectorObserver = observer;
  currentCollectorObserver();
  currentCollectorObserver = null;
  return function () {
    observer.deps.forEach(function (dep) {
      var index = dep.findIndex(function (ob) {
        return ob === observer;
      });
      dep.splice(index, 1);
    });
    observer.deps = [];
  };
}

function digestObserverCallCue() {
  if (observerCallCue.length) {
    var nextObserver = observerCallCue.shift();

    if (nextObserver) {
      nextObserver();
    }
  }
}

function isObservable(target) {
  return reactive_typeof(target) === 'object' && target.__toastUIChartOb__;
}
function reactive_observable(target) {
  var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : target;

  if (isObservable(source)) {
    throw new Error(message.ALREADY_OBSERVABLE_ERROR);
  }

  if (!isObservable(target)) {
    Object.defineProperty(target, '__toastUIChartOb__', {
      enumerable: false
    });
  }

  var _loop = function _loop(key) {
    if (!source.hasOwnProperty(key)) {
      return "continue";
    }

    var obs = [];
    var value = source[key];
    var descriptor = Object.getOwnPropertyDescriptor(source, key);
    var preGetter = descriptor && descriptor.get;
    var preSetter = descriptor && descriptor.set;
    /* eslint-disable no-loop-func */

    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: true,
      get: function get() {
        // It's some kind a trick to get observable information from closure using getter for notify()
        if (currentCollectorObserver === observableInfo) {
          return {
            target: target,
            key: key,
            value: value,
            obs: obs
          };
        }

        if (!doingInvisibleWork && currentCollectorObserver && !obs.includes(currentCollectorObserver)) {
          // if there is collector observer in running, collect current data as dependency
          obs.push(currentCollectorObserver);
          currentCollectorObserver.deps.push(obs);
        }

        return value;
      },
      set: function set(v) {
        var prevValue = value;

        if (preSetter) {
          preSetter.call(target, v);
          value = preGetter ? preGetter.call(target) : target[key];
        } else {
          value = v;
        }

        if (prevValue !== value) {
          // Run observers
          invokeObs(obs);
        }
      }
    });

    if (reactive_typeof(target[key]) === 'object' && !Array.isArray(target[key])) {
      reactive_observable(target[key]);
    }
    /* eslint-enable no-loop-func */

  };

  for (var key in source) {
    var _ret = _loop(key);

    if (_ret === "continue") continue;
  }

  return target;
}
function setValue(target, key, source) {
  return reactive_observable(target, reactive_defineProperty({}, key, source));
}
function extend(target, source) {
  if (isObservable(source)) {
    throw new Error(message.ALREADY_OBSERVABLE_ERROR);
  }

  return reactive_observable(target, source);
}
function reactive_notify(target, key) {
  var obInfo = observableInfo(target, key);

  if (obInfo) {
    invokeObs(obInfo.obs);
  }
}
function invisibleWork(fn) {
  doingInvisibleWork = true;
  fn();
  doingInvisibleWork = false;
  digestObserverCallCue();
}
function reactive_notifyByPath(holder, namePath) {
  var splited = namePath.split('.');
  var key = splited.splice(splited.length - 1, 1)[0];
  var target = pickProperty(holder, splited);

  if (target) {
    reactive_notify(target, key);
  }
}

function invokeObs(obs) {
  obs.forEach(function (ob) {
    return ob();
  });
}

function observableInfo(target, key) {
  currentCollectorObserver = observableInfo;
  var obInfo = target[key];
  currentCollectorObserver = null;

  if (reactive_typeof(obInfo) === 'object' && obInfo.hasOwnProperty('target') && obInfo.hasOwnProperty('obs')) {
    return obInfo;
  }

  return null;
}

function reactive_computed(target, key, fn) {
  var cachedValue;
  var computedBox = {};
  Object.defineProperty(computedBox, key, {
    configurable: true,
    enumerable: true,
    get: function get() {
      return cachedValue;
    }
  });
  extend(target, computedBox);
  reactive_observe(function () {
    var prevValue = cachedValue;
    cachedValue = fn();

    if (prevValue !== cachedValue) {
      target[key] = cachedValue;
    }
  });
}
function watch(holder, path, fn) {
  var splited = path.split('.');
  var key = splited.splice(splited.length - 1, 1)[0];
  var target = pickProperty(holder, splited);

  if (!target) {
    return null;
  }

  var obInfo = observableInfo(target, key);

  if (!obInfo) {
    return null;
  }

  var watcher = function watcher() {
    fn(target[key]);
  };

  obInfo.obs.push(watcher);
  return function () {
    var index = obInfo.obs.findIndex(function (ob) {
      return ob === watcher;
    });

    if (index > -1) {
      obInfo.obs.splice(index, 1);
    }
  };
}
function makeObservableObjectToNormal(obj) {
  return JSON.parse(JSON.stringify(obj));
}
// CONCATENATED MODULE: ./src/store/store.ts






function store_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { store_typeof = function _typeof(obj) { return typeof obj; }; } else { store_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return store_typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function store_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var store_Store = /*#__PURE__*/function () {
  function Store(initStoreState) {
    _classCallCheck(this, Store);

    store_defineProperty(this, "state", void 0);

    store_defineProperty(this, "initStoreState", void 0);

    store_defineProperty(this, "computed", {});

    store_defineProperty(this, "actions", {});

    this.initStoreState = deepCopy(initStoreState);
    this.setRootState({});
  }

  _createClass(Store, [{
    key: "setRootState",
    value: function setRootState(state) {
      reactive_observable(state);

      this.state = state;
    }
  }, {
    key: "setComputed",
    value: function setComputed(namePath, fn) {
      var holder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.computed;
      var splited = namePath.split('.');
      var key = splited.splice(splited.length - 1, 1)[0];
      var target = pickPropertyWithMakeup(holder, splited);
      reactive_computed(target, key, fn.bind(null, this.state, this.computed));
    }
  }, {
    key: "setWatch",
    value: function setWatch(namePath, fn) {
      return watch(this, namePath, fn);
    }
  }, {
    key: "setAction",
    value: function setAction(name, fn) {
      this.actions[name] = fn;
    }
  }, {
    key: "dispatch",
    value: function dispatch(name, payload, isInvisible) {
      var _this = this;

      // observe.setlayout 안에서 setLayout 액션이 실행되니까 여기서 state.layout getter가 실행되고
      // state.layout의 옵져버로 observe.setLayout이 등록된다. 여기서 무한루프
      // 즉 observe하고 안에서 특정 대상을 쓸때
      // extend(state.layout, layouts); 이런식으로 하게되면 layout의 getter실행되어
      // layout을 업데이트하려고 만든 observe를 옵저버로 등록해서 무한루프
      if (isInvisible) {
        invisibleWork(function () {
          // console.log('dispatch', name, ...args);
          _this.actions[name].call(_this, _this, payload); // console.log('dispatch end', name);

        });
      } else {
        this.actions[name].call(this, this, payload);
      }
    }
  }, {
    key: "observe",
    value: function observe(fn) {
      return reactive_observe(fn.bind(this, this.state, this.computed));
    }
  }, {
    key: "observable",
    value: function observable(target) {
      return reactive_observable(target);
    }
  }, {
    key: "notifyByPath",
    value: function notifyByPath(namePath) {
      reactive_notifyByPath(this, namePath);
    }
  }, {
    key: "notify",
    value: function notify(target, key) {
      reactive_notify(target, key);
    }
  }, {
    key: "setModule",
    value: function setModule(name, param) {
      var _this2 = this;

      if (!param) {
        param = name;
        name = param.name;
      }

      if (param.state) {
        var moduleState = typeof param.state === 'function' ? param.state(this.initStoreState) : param.state;
        store_extend(this.state, moduleState);
      }

      if (param.computed) {
        forEach(param.computed, function (item, key) {
          _this2.setComputed(key, item);
        });
      }

      if (param.watch) {
        forEach(param.watch, function (item, key) {
          _this2.setWatch(key, item);
        });
      }

      if (param.action) {
        forEach(param.action, function (item, key) {
          _this2.setAction(key, item);
        });
      }

      if (param.observe) {
        forEach(param.observe, function (item) {
          _this2.observe(item);
        });
      }
    }
  }, {
    key: "setValue",
    value: function setValue(target, key, source) {
      store_extend(target, store_defineProperty({}, key, source));
    }
  }]);

  return Store;
}();


function store_extend(target, source) {
  var newItems = {};

  for (var k in source) {
    if (!source.hasOwnProperty(k)) {
      continue;
    }

    if (!isUndefined(target[k])) {
      if (store_typeof(source[k]) === 'object' && !Array.isArray(source[k])) {
        store_extend(target[k], source[k]);
      } else {
        target[k] = source[k];
      }
    } else {
      newItems[k] = source[k];
    }
  }

  if (Object.keys(newItems).length) {
    extend(target, newItems);
  }
}
// CONCATENATED MODULE: ./src/store/root.ts








function root_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function root_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { root_ownKeys(Object(source), true).forEach(function (key) { root_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { root_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function root_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



function initialSize(containerEl, _ref) {
  var width = _ref.width,
      height = _ref.height;
  return {
    width: width === 0 ? containerEl.offsetWidth : width,
    height: height === 0 ? containerEl.offsetHeight : height
  };
}

var root = {
  name: 'root',
  state: function state(_ref2) {
    var _options$chart, _options$chart2, _options$chart3, _options$chart4;

    var options = _ref2.options;
    return {
      chart: root_objectSpread(root_objectSpread({}, options.chart), {}, {
        width: getInitialSize(options === null || options === void 0 ? void 0 : (_options$chart = options.chart) === null || _options$chart === void 0 ? void 0 : _options$chart.width),
        height: getInitialSize(options === null || options === void 0 ? void 0 : (_options$chart2 = options.chart) === null || _options$chart2 === void 0 ? void 0 : _options$chart2.height)
      }),
      usingContainerSize: {
        width: isAutoValue(options === null || options === void 0 ? void 0 : (_options$chart3 = options.chart) === null || _options$chart3 === void 0 ? void 0 : _options$chart3.width),
        height: isAutoValue(options === null || options === void 0 ? void 0 : (_options$chart4 = options.chart) === null || _options$chart4 === void 0 ? void 0 : _options$chart4.height)
      },
      container: {}
    };
  },
  action: {
    setChartSize: function setChartSize(_ref3, size) {
      var state = _ref3.state;
      state.chart.width = size.width;
      state.chart.height = size.height;
    },
    initChartSize: function initChartSize(_ref4, containerEl) {
      var _this = this;

      var state = _ref4.state;
      var _state$chart = state.chart,
          width = _state$chart.width,
          height = _state$chart.height;

      if (width === 0 || height === 0) {
        if (containerEl.parentNode) {
          this.dispatch('setChartSize', initialSize(containerEl, {
            width: width,
            height: height
          }));
        } else {
          setTimeout(function () {
            _this.dispatch('setChartSize', initialSize(containerEl, {
              width: width,
              height: height
            }));
          }, 0);
        }
      }
    },
    setUsingContainerSize: function setUsingContainerSize(_ref5, _ref6) {
      var state = _ref5.state;
      var width = _ref6.width,
          height = _ref6.height;
      state.usingContainerSize.width = width;
      state.usingContainerSize.height = height;
    }
  }
};
/* harmony default export */ var store_root = (root);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.js
var es_set = __webpack_require__(76);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.match.js
var es_string_match = __webpack_require__(140);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__(114);

// CONCATENATED MODULE: ./src/helpers/formatDate.ts




// https://github.com/nhn/tui.code-snippet/blob/master/formatDate/formatDate.js

var DEFAULT_DATE_FORMAT = 'YY-MM-DD hh:mm:ss';
function getDateFormat(date) {
  if (!date) {
    return;
  }

  return isObject(date) ? date.format : DEFAULT_DATE_FORMAT;
}
var tokens = /[\\]*YYYY|[\\]*YY|[\\]*MMMM|[\\]*MMM|[\\]*MM|[\\]*M|[\\]*DD|[\\]*D|[\\]*HH|[\\]*H|[\\]*mm|[\\]*m|[\\]*ss|[\\]*s|[\\]*A/gi;
var MONTH_STR = ['Invalid month', 'January', 'February', 'March', 'April', 'May', 'Jun', 'Jul', 'August', 'September', 'October', 'November', 'December'];
var MONTH_DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var replaceMap = {
  M: function M(date) {
    return Number(date.month);
  },
  MM: function MM(date) {
    var month = date.month;
    return Number(month) < 10 ? "0".concat(month) : month;
  },
  MMM: function MMM(date) {
    return MONTH_STR[Number(date.month)].substr(0, 3);
  },
  MMMM: function MMMM(date) {
    return MONTH_STR[Number(date.month)];
  },
  D: function D(date) {
    return Number(date.date);
  },
  d: function d(date) {
    return replaceMap.D(date);
  },
  // eslint-disable-line new-cap
  DD: function DD(date) {
    var dayInMonth = date.date;
    return Number(dayInMonth) < 10 ? "0".concat(dayInMonth) : dayInMonth;
  },
  dd: function dd(date) {
    return replaceMap.DD(date);
  },
  // eslint-disable-line new-cap
  YY: function YY(date) {
    return Number(date.year) % 100;
  },
  yy: function yy(date) {
    return replaceMap.YY(date);
  },
  // eslint-disable-line new-cap
  YYYY: function YYYY(date) {
    var prefix = '20';
    var year = date.year;

    if (year > 69 && year < 100) {
      prefix = '19';
    }

    return Number(year) < 100 ? prefix + String(year) : year;
  },
  yyyy: function yyyy(date) {
    return replaceMap.YYYY(date);
  },
  // eslint-disable-line new-cap
  A: function A(date) {
    return date.meridiem;
  },
  a: function a(date) {
    return date.meridiem;
  },
  hh: function hh(date) {
    var hour = date.hour;
    return Number(hour) < 10 ? '0' + hour : hour;
  },
  HH: function HH(date) {
    return replaceMap.hh(date);
  },
  h: function h(date) {
    return String(Number(date.hour));
  },
  H: function H(date) {
    return replaceMap.h(date);
  },
  m: function m(date) {
    return String(Number(date.minute));
  },
  mm: function mm(date) {
    var minute = date.minute;
    return Number(minute) < 10 ? "0".concat(minute) : minute;
  },
  s: function s(date) {
    return String(Number(date.second));
  },
  ss: function ss(date) {
    var second = date.second;
    return Number(second) < 10 ? "0".concat(second) : second;
  }
};

function isLeapYear(month, year) {
  return month === 2 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}

function isValidDate(y, m, d) {
  var year = Number(y);
  var month = Number(m);
  var date = Number(d);
  var isValidYear = year > -1 && year < 100 || year > 1969 && year < 2070;
  var isValidMonth = month > 0 && month < 13;

  if (!isValidYear || !isValidMonth) {
    return false;
  }

  var lastDayInMonth = isLeapYear(month, year) ? 29 : MONTH_DAYS[month];
  return date > 0 && date <= lastDayInMonth;
}
/*
 * key             | Shorthand
 * --------------- |-----------------------
 * years           | YY / YYYY / yy / yyyy
 * months(n)       | M / MM
 * months(str)     | MMM / MMMM
 * days            | D / DD / d / dd
 * hours           | H / HH / h / hh
 * minutes         | m / mm
 * seconds         | s / ss
 * meridiem(AM,PM) | A / a
 */


function formatDate(form, date, option) {
  var _option$meridiemSet$A;

  var am = (_option$meridiemSet$A = option === null || option === void 0 ? void 0 : option.meridiemSet.AM) !== null && _option$meridiemSet$A !== void 0 ? _option$meridiemSet$A : 'AM';
  var pm = (option === null || option === void 0 ? void 0 : option.meridiemSet.PM) || 'PM';
  var nDate;

  if (isDate(date)) {
    nDate = {
      year: date.getFullYear(),
      month: date.getMonth() + 1,
      date: date.getDate(),
      hour: date.getHours(),
      minute: date.getMinutes(),
      second: date.getSeconds()
    };
  } else {
    var year = date.year,
        month = date.month,
        hour = date.hour,
        minute = date.minute,
        second = date.second;
    nDate = {
      year: year,
      month: month,
      date: date.date,
      hour: hour,
      minute: minute,
      second: second
    };
  }

  if (!isValidDate(nDate.year, nDate.month, nDate.date)) {
    return '';
  }

  nDate.meridiem = '';

  if (/([^\\]|^)[aA]\b/.test(form)) {
    if (nDate.hour > 12) {
      // See the clock system: https://en.wikipedia.org/wiki/12-hour_clock
      nDate.hour %= 12;
    }

    if (nDate.hour === 0) {
      nDate.hour = 12;
    }

    nDate.meridiem = nDate.hour > 11 ? pm : am;
  }

  return form.replace(tokens, function (key) {
    if (key.indexOf('\\') > -1) {
      // escape character
      return key.replace(/\\/, '');
    }

    return replaceMap[key](nDate) || '';
  });
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.fill.js
var es_array_fill = __webpack_require__(88);

// CONCATENATED MODULE: ./src/helpers/style.ts











function style_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function style_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { style_ownKeys(Object(source), true).forEach(function (key) { style_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { style_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function style_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



function makeStyleObj(style, styleSet) {
  return style.reduce(function (acc, curValue) {
    if (isString(curValue)) {
      return style_objectSpread(style_objectSpread({}, acc), styleSet[curValue]);
    }

    return style_objectSpread(style_objectSpread({}, acc), curValue);
  }, {});
}
function getTranslateString(x, y) {
  return "translate(".concat(x, "px,").concat(y, "px)");
}
function getTitleFontString(fontTheme) {
  var fontFamily = fontTheme.fontFamily,
      fontSize = fontTheme.fontSize,
      fontWeight = fontTheme.fontWeight;
  return "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
}
function getFontStyleString(theme) {
  var color = theme.color,
      fontSize = theme.fontSize,
      fontFamily = theme.fontFamily,
      fontWeight = theme.fontWeight;
  return "font-weight: ".concat(fontWeight, "; font-family: ").concat(fontFamily, "; font-size: ").concat(fontSize, "px; color: ").concat(color, ";");
}
function getFont(theme) {
  return getTitleFontString(pick(theme, 'fontFamily', 'fontWeight', 'fontSize'));
}
function setLineDash(ctx, dashSegments) {
  if (ctx.setLineDash) {
    ctx.setLineDash(dashSegments);
  } else {
    console.error(message.DASH_SEGMENTS_UNAVAILABLE_ERROR);
  }
}
function getBoxTypeSeriesPadding(tickDistance) {
  return Math.floor(tickDistance * 0.15);
}
function style_fillStyle(ctx, fillOption) {
  ctx.fillStyle = fillOption;
  ctx.fill();
}
function strokeWithOptions(ctx, style) {
  var lineWidth = style.lineWidth,
      strokeStyle = style.strokeStyle;

  if (strokeStyle) {
    ctx.strokeStyle = strokeStyle;
  }

  if (lineWidth) {
    ctx.lineWidth = lineWidth;
  }

  ctx.stroke();
}
// CONCATENATED MODULE: ./src/helpers/color.ts




















function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || color_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function color_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return color_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return color_arrayLikeToArray(o, minLen); }

function color_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }


var hexRX = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i;
var rgbRX = /rgb\((\d{1,3}), ?(\d{1,3}), ?(\d{1,3})\)/;
var rgbaRX = /rgba\((\d{1,3}), ?(\d{1,3}), ?(\d{1,3}), ?(1|0?\.?\d+)\)/;
/**
 * Color map.
 * http://stackoverflow.com/questions/1573053/javascript-function-to-convert-color-names-to-hex-codes
 * http://www.w3schools.com/HTML/html_colornames.asp
 * @ignore
 */

var colorMap = {
  aliceblue: '#f0f8ff',
  antiquewhite: '#faebd7',
  aqua: '#00ffff',
  aquamarine: '#7fffd4',
  azure: '#f0ffff',
  beige: '#f5f5dc',
  bisque: '#ffe4c4',
  black: '#000000',
  blanchedalmond: '#ffebcd',
  blue: '#0000ff',
  blueviolet: '#8a2be2',
  brown: '#a52a2a',
  burlywood: '#deb887',
  cadetblue: '#5f9ea0',
  chartreuse: '#7fff00',
  chocolate: '#d2691e',
  coral: '#ff7f50',
  cornflowerblue: '#6495ed',
  cornsilk: '#fff8dc',
  crimson: '#dc143c',
  cyan: '#00ffff',
  darkblue: '#00008b',
  darkcyan: '#008b8b',
  darkgoldenrod: '#b8860b',
  darkgray: '#a9a9a9',
  darkgreen: '#006400',
  darkkhaki: '#bdb76b',
  darkmagenta: '#8b008b',
  darkolivegreen: '#556b2f',
  darkorange: '#ff8c00',
  darkorchid: '#9932cc',
  darkred: '#8b0000',
  darksalmon: '#e9967a',
  darkseagreen: '#8fbc8f',
  darkslateblue: '#483d8b',
  darkslategray: '#2f4f4f',
  darkturquoise: '#00ced1',
  darkviolet: '#9400d3',
  deeppink: '#ff1493',
  deepskyblue: '#00bfff',
  dimgray: '#696969',
  dodgerblue: '#1e90ff',
  firebrick: '#b22222',
  floralwhite: '#fffaf0',
  forestgreen: '#228b22',
  fuchsia: '#ff00ff',
  gainsboro: '#dcdcdc',
  ghostwhite: '#f8f8ff',
  gold: '#ffd700',
  goldenrod: '#daa520',
  gray: '#808080',
  green: '#008000',
  greenyellow: '#adff2f',
  honeydew: '#f0fff0',
  hotpink: '#ff69b4',
  indianred: '#cd5c5c',
  indigo: '#4b0082',
  ivory: '#fffff0',
  khaki: '#f0e68c',
  lavender: '#e6e6fa',
  lavenderblush: '#fff0f5',
  lawngreen: '#7cfc00',
  lemonchiffon: '#fffacd',
  lightblue: '#add8e6',
  lightcoral: '#f08080',
  lightcyan: '#e0ffff',
  lightgoldenrodyellow: '#fafad2',
  lightgrey: '#d3d3d3',
  lightgreen: '#90ee90',
  lightpink: '#ffb6c1',
  lightsalmon: '#ffa07a',
  lightseagreen: '#20b2aa',
  lightskyblue: '#87cefa',
  lightslategray: '#778899',
  lightsteelblue: '#b0c4de',
  lightyellow: '#ffffe0',
  lime: '#00ff00',
  limegreen: '#32cd32',
  linen: '#faf0e6',
  magenta: '#ff00ff',
  maroon: '#800000',
  mediumaquamarine: '#66cdaa',
  mediumblue: '#0000cd',
  mediumorchid: '#ba55d3',
  mediumpurple: '#9370d8',
  mediumseagreen: '#3cb371',
  mediumslateblue: '#7b68ee',
  mediumspringgreen: '#00fa9a',
  mediumturquoise: '#48d1cc',
  mediumvioletred: '#c71585',
  midnightblue: '#191970',
  mintcream: '#f5fffa',
  mistyrose: '#ffe4e1',
  moccasin: '#ffe4b5',
  navajowhite: '#ffdead',
  navy: '#000080',
  oldlace: '#fdf5e6',
  olive: '#808000',
  olivedrab: '#6b8e23',
  orange: '#ffa500',
  orangered: '#ff4500',
  orchid: '#da70d6',
  palegoldenrod: '#eee8aa',
  palegreen: '#98fb98',
  paleturquoise: '#afeeee',
  palevioletred: '#d87093',
  papayawhip: '#ffefd5',
  peachpuff: '#ffdab9',
  peru: '#cd853f',
  pink: '#ffc0cb',
  plum: '#dda0dd',
  powderblue: '#b0e0e6',
  purple: '#800080',
  red: '#ff0000',
  rosybrown: '#bc8f8f',
  royalblue: '#4169e1',
  saddlebrown: '#8b4513',
  salmon: '#fa8072',
  sandybrown: '#f4a460',
  seagreen: '#2e8b57',
  seashell: '#fff5ee',
  sienna: '#a0522d',
  silver: '#c0c0c0',
  skyblue: '#87ceeb',
  slateblue: '#6a5acd',
  slategray: '#708090',
  snow: '#fffafa',
  springgreen: '#00ff7f',
  steelblue: '#4682b4',
  tan: '#d2b48c',
  teal: '#008080',
  thistle: '#d8bfd8',
  tomato: '#ff6347',
  turquoise: '#40e0d0',
  violet: '#ee82ee',
  wheat: '#f5deb3',
  white: '#ffffff',
  whitesmoke: '#f5f5f5',
  yellow: '#ffff00',
  yellowgreen: '#9acd32'
};

function leadingZero(number, length) {
  if (number.length > length) {
    return number;
  }

  var res = number;
  utils_range(0, length - 1).forEach(function (_) {
    res = '0' + res;
  });
  return res.slice(length * -1);
}

function isValidRGB(str) {
  return hexRX.test(str);
}

function colorNameToHex(colorName) {
  return colorMap[colorName.toLowerCase()] || colorName;
} // @license RGB <-> HSV conversion utilities based off of http://www.cs.rit.edu/~ncs/color/t_convert.html


function hexToRGB(str) {
  var hexStr = colorNameToHex(str);

  if (!isValidRGB(hexStr)) {
    return false;
  }

  return hexStr.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (m, r, g, b) {
    return '#' + r + r + g + g + b + b;
  }).substring(1).match(/.{2}/g).map(function (x) {
    return parseInt(x, 16);
  });
}
function rgbToHEX(r, g, b) {
  var hexPreFix = '#';
  var hexStr = hexPreFix + leadingZero(r.toString(16), 2) + leadingZero(g.toString(16), 2) + leadingZero(b.toString(16), 2);

  if (isValidRGB(hexStr)) {
    return hexStr;
  }

  return false;
}
function getRGBA(str, opacity) {
  var hexStr = colorNameToHex(str);

  if (isValidRGB(hexStr)) {
    var _ref = hexToRGB(hexStr),
        _ref2 = _slicedToArray(_ref, 3),
        r = _ref2[0],
        g = _ref2[1],
        b = _ref2[2];

    return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(opacity, ")");
  }

  if (rgbRX.test(str)) {
    var match = rgbRX.exec(str);
    return "rgba(".concat(match[1], ", ").concat(match[2], ", ").concat(match[3], ", ").concat(opacity, ")");
  }

  if (rgbaRX.test(str)) {
    var _match = rgbaRX.exec(str);

    return "rgba(".concat(_match[1], ", ").concat(_match[2], ", ").concat(_match[3], ", ").concat(opacity, ")");
  }

  return str;
}
function getAlpha(str) {
  if (rgbaRX.test(str)) {
    var match = rgbaRX.exec(str);
    return Number(match[4]);
  }

  return 1;
}
function rgba(color) {
  var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var alpha = getAlpha(color) * opacity;
  return getRGBA(color, alpha);
}
// CONCATENATED MODULE: ./src/brushes/basic.ts





var circleStyle = {
  default: {
    strokeStyle: '#ffffff',
    lineWidth: 2
  },
  plot: {
    lineWidth: 1,
    strokeStyle: 'rgba(0, 0, 0, 0.05)'
  }
};
var rectStyle = {
  shadow: {
    shadowColor: 'rgba(0, 0, 0, 0.3)',
    shadowOffsetX: 2,
    shadowOffsetY: 2,
    shadowBlur: 6
  }
};
function clipRectArea(ctx, clipRectAreaModel) {
  var x = clipRectAreaModel.x,
      y = clipRectAreaModel.y,
      width = clipRectAreaModel.width,
      height = clipRectAreaModel.height;
  ctx.beginPath();
  ctx.rect(x, y, width, height);
  ctx.clip();
}
function pathRect(ctx, pathRectModel) {
  var x = pathRectModel.x,
      y = pathRectModel.y,
      width = pathRectModel.width,
      height = pathRectModel.height,
      _pathRectModel$radius = pathRectModel.radius,
      radius = _pathRectModel$radius === void 0 ? 0 : _pathRectModel$radius,
      _pathRectModel$stroke = pathRectModel.stroke,
      strokeStyle = _pathRectModel$stroke === void 0 ? 'black' : _pathRectModel$stroke,
      _pathRectModel$fill = pathRectModel.fill,
      fill = _pathRectModel$fill === void 0 ? '' : _pathRectModel$fill,
      _pathRectModel$lineWi = pathRectModel.lineWidth,
      lineWidth = _pathRectModel$lineWi === void 0 ? 1 : _pathRectModel$lineWi;
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();

  if (fill) {
    style_fillStyle(ctx, fill);
  }

  strokeWithOptions(ctx, {
    lineWidth: lineWidth,
    strokeStyle: strokeStyle
  });
}
function basic_circle(ctx, circleModel) {
  var x = circleModel.x,
      y = circleModel.y,
      style = circleModel.style,
      radius = circleModel.radius,
      color = circleModel.color,
      _circleModel$angle = circleModel.angle,
      angle = _circleModel$angle === void 0 ? {
    start: 0,
    end: Math.PI * 2
  } : _circleModel$angle,
      lineWidth = circleModel.borderWidth,
      strokeStyle = circleModel.borderColor;
  ctx.beginPath();

  if (style) {
    var styleObj = makeStyleObj(style, circleStyle);
    Object.keys(styleObj).forEach(function (key) {
      ctx[key] = styleObj[key];
    });
  }

  ctx.arc(x, y, radius, angle.start, angle.end, true);
  style_fillStyle(ctx, color);
  strokeWithOptions(ctx, {
    lineWidth: lineWidth,
    strokeStyle: strokeStyle
  });
  ctx.closePath();
}
function basic_line(ctx, lineModel) {
  var x = lineModel.x,
      y = lineModel.y,
      x2 = lineModel.x2,
      y2 = lineModel.y2,
      strokeStyle = lineModel.strokeStyle,
      lineWidth = lineModel.lineWidth,
      dashSegments = lineModel.dashSegments;
  ctx.beginPath();

  if (dashSegments) {
    setLineDash(ctx, dashSegments);
  }

  ctx.moveTo(x, y);
  ctx.lineTo(x2, y2);
  strokeWithOptions(ctx, {
    strokeStyle: strokeStyle,
    lineWidth: lineWidth
  });
  ctx.closePath();
}
function basic_rect(ctx, model) {
  var x = model.x,
      y = model.y,
      width = model.width,
      height = model.height,
      style = model.style,
      _model$thickness = model.thickness,
      thickness = _model$thickness === void 0 ? 0 : _model$thickness,
      color = model.color,
      _model$borderColor = model.borderColor,
      borderColor = _model$borderColor === void 0 ? '#ffffff' : _model$borderColor;
  ctx.beginPath();

  if (style) {
    var styleObj = makeStyleObj(style, rectStyle);
    Object.keys(styleObj).forEach(function (key) {
      ctx[key] = styleObj[key];
    });
  }

  if (thickness) {
    ctx.fillStyle = borderColor;
    ctx.fillRect(x - thickness, y - thickness, width + thickness * 2, height + thickness * 2);
    ctx.shadowColor = 'rgba(0, 0, 0, 0)'; // reset shadow color
  }

  ctx.rect(x, y, width, height);
  style_fillStyle(ctx, color);
}
// CONCATENATED MODULE: ./src/brushes/label.ts








var DEFAULT_LABEL_TEXT = 'normal 11px Arial';
var labelStyle = {
  default: {
    font: DEFAULT_LABEL_TEXT,
    fillStyle: '#333333',
    textAlign: 'left',
    textBaseline: 'middle'
  },
  title: {
    textBaseline: 'top'
  },
  axisTitle: {
    textBaseline: 'top'
  },
  rectLabel: {
    font: DEFAULT_LABEL_TEXT,
    fillStyle: 'rgba(0, 0, 0, 0.3)',
    textAlign: 'center',
    textBaseline: 'middle'
  }
};
var strokeLabelStyle = {
  none: {
    lineWidth: 1,
    strokeStyle: 'rgba(255, 255, 255, 0)'
  },
  stroke: {
    lineWidth: 4,
    strokeStyle: 'rgba(255, 255, 255, 0.5)'
  }
};
function label_label(ctx, labelModel) {
  var x = labelModel.x,
      y = labelModel.y,
      text = labelModel.text,
      style = labelModel.style,
      stroke = labelModel.stroke,
      opacity = labelModel.opacity,
      radian = labelModel.radian;

  if (style) {
    var styleObj = makeStyleObj(style, labelStyle);
    Object.keys(styleObj).forEach(function (key) {
      ctx[key] = key === 'fillStyle' && isNumber(opacity) ? rgba(styleObj[key], opacity) : styleObj[key];
    });
  }

  ctx.save();

  if (radian) {
    ctx.translate(x, y);
    ctx.rotate(radian);
    ctx.translate(-x, -y);
  }

  if (stroke) {
    var strokeStyleObj = makeStyleObj(stroke, strokeLabelStyle);
    var strokeStyleKeys = Object.keys(strokeStyleObj);
    strokeStyleKeys.forEach(function (key) {
      ctx[key] = key === 'strokeStyle' && isNumber(opacity) ? rgba(strokeStyleObj[key], opacity) : strokeStyleObj[key];
    });

    if (strokeStyleKeys.length) {
      ctx.strokeText(text, x, y);
    }
  }

  ctx.fillText(text, x, y);
  ctx.restore();
}
function rectLabel(ctx, model) {
  var x = model.x,
      y = model.y,
      style = model.style,
      text = model.text,
      width = model.width,
      height = model.height,
      _model$borderRadius = model.borderRadius,
      borderRadius = _model$borderRadius === void 0 ? 0 : _model$borderRadius,
      backgroundColor = model.backgroundColor;
  pathRect(ctx, {
    type: 'pathRect',
    x: x - width / 2,
    y: y - height / 2,
    width: width,
    height: height,
    radius: borderRadius,
    fill: backgroundColor,
    stroke: 'rgba(0, 0, 0, 0)'
  });
  label_label(ctx, {
    type: 'label',
    x: x,
    y: y,
    style: style,
    text: text
  });
}
var textBubbleStyle = {
  shadow: {
    shadowColor: 'rgba(0, 0, 0, 0.3)',
    shadowOffsetY: 2,
    shadowBlur: 4
  }
};
function bubbleLabel(ctx, model) {
  var x = model.x,
      y = model.y,
      width = model.width,
      height = model.height,
      _model$radius = model.radius,
      radius = _model$radius === void 0 ? 0 : _model$radius,
      points = model.points,
      direction = model.direction,
      _model$lineWidth = model.lineWidth,
      lineWidth = _model$lineWidth === void 0 ? 1 : _model$lineWidth,
      _model$fill = model.fill,
      fill = _model$fill === void 0 ? '#ffffff' : _model$fill,
      stroke = model.stroke,
      _model$bubbleStyle = model.bubbleStyle,
      bubbleStyle = _model$bubbleStyle === void 0 ? null : _model$bubbleStyle,
      textStyle = model.labelStyle,
      labelStrokeStyle = model.labelStrokeStyle,
      text = model.text;
  drawBubble(ctx, {
    x: x,
    y: y,
    radius: radius,
    width: width,
    height: height,
    style: bubbleStyle,
    fill: fill,
    stroke: stroke,
    lineWidth: lineWidth,
    direction: direction,
    points: points
  });

  if (text) {
    ctx.shadowColor = 'rgba(0, 0, 0, 0)';
    label_label(ctx, {
      type: 'label',
      x: x + width / 2,
      y: y + height / 2 + 1,
      text: text,
      style: textStyle,
      stroke: labelStrokeStyle
    });
  }
}

function drawBubbleArrow(ctx, points) {
  if (!points.length) {
    return;
  }

  ctx.lineTo(points[0].x, points[0].y);
  ctx.lineTo(points[1].x, points[1].y);
  ctx.lineTo(points[2].x, points[2].y);
}

function drawBubble(ctx, model) {
  var x = model.x,
      y = model.y,
      _model$radius2 = model.radius,
      radius = _model$radius2 === void 0 ? 0 : _model$radius2,
      width = model.width,
      height = model.height,
      style = model.style,
      strokeStyle = model.stroke,
      fill = model.fill,
      _model$lineWidth2 = model.lineWidth,
      lineWidth = _model$lineWidth2 === void 0 ? 1 : _model$lineWidth2,
      _model$points = model.points,
      points = _model$points === void 0 ? [] : _model$points,
      _model$direction = model.direction,
      direction = _model$direction === void 0 ? '' : _model$direction;
  var right = x + width;
  var bottom = y + height;
  ctx.beginPath();
  ctx.moveTo(x + radius, y);

  if (direction === 'top') {
    drawBubbleArrow(ctx, points);
  }

  ctx.lineTo(right - radius, y);
  ctx.quadraticCurveTo(right, y, right, y + radius);

  if (direction === 'right') {
    drawBubbleArrow(ctx, points);
  }

  ctx.lineTo(right, y + height - radius);
  ctx.quadraticCurveTo(right, bottom, right - radius, bottom);

  if (direction === 'bottom') {
    drawBubbleArrow(ctx, points);
  }

  ctx.lineTo(x + radius, bottom);
  ctx.quadraticCurveTo(x, bottom, x, bottom - radius);

  if (direction === 'left') {
    drawBubbleArrow(ctx, points);
  }

  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);

  if (style) {
    var styleObj = makeStyleObj(style, textBubbleStyle);
    Object.keys(styleObj).forEach(function (key) {
      ctx[key] = styleObj[key];
    });
  }

  if (fill) {
    style_fillStyle(ctx, fill);
  }

  if (strokeStyle) {
    strokeWithOptions(ctx, {
      strokeStyle: strokeStyle,
      lineWidth: lineWidth
    });
  }
}
// CONCATENATED MODULE: ./src/brushes/axis.ts

var TICK_SIZE = 5;
function tick(ctx, tickModel) {
  var x = tickModel.x,
      y = tickModel.y,
      isYAxis = tickModel.isYAxis,
      _tickModel$tickSize = tickModel.tickSize,
      tickSize = _tickModel$tickSize === void 0 ? TICK_SIZE : _tickModel$tickSize,
      strokeStyle = tickModel.strokeStyle,
      lineWidth = tickModel.lineWidth;
  var lineModel = {
    type: 'line',
    x: x,
    y: y,
    x2: x,
    y2: y,
    strokeStyle: strokeStyle,
    lineWidth: lineWidth
  };

  if (isYAxis) {
    lineModel.x2 += tickSize;
  } else {
    lineModel.y2 += tickSize;
  }

  basic_line(ctx, lineModel);
}
// CONCATENATED MODULE: ./src/helpers/calculator.ts


















function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || calculator_unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function calculator_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return calculator_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return calculator_arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return calculator_arrayLikeToArray(arr); }

function calculator_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





var LINE_HEIGHT_NORMAL = 1.2;
var calculator_ctx = document.createElement('canvas').getContext('2d');
function getTextWidth(text) {
  var font = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_LABEL_TEXT;
  calculator_ctx.font = font;
  return Math.ceil(calculator_ctx.measureText(text).width);
}
/*
 * Calculate height of canvas text
 * https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics
 * */

function getTextHeight(text) {
  var font = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_LABEL_TEXT;
  calculator_ctx.font = font;

  var _ctx$measureText = calculator_ctx.measureText(text),
      actualBoundingBoxAscent = _ctx$measureText.actualBoundingBoxAscent,
      actualBoundingBoxDescent = _ctx$measureText.actualBoundingBoxDescent;

  var validActualBoundingBox = isNumber(actualBoundingBoxAscent) && isNumber(actualBoundingBoxDescent);
  return validActualBoundingBox ? Math.ceil(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent)) + 1 : getFontHeight(font);
}
function getFontHeight() {
  var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_LABEL_TEXT;
  var fontSize = font.match(/\d+(?=px)/);
  return parseInt(String(Number(fontSize) * LINE_HEIGHT_NORMAL), 10);
}
function getAxisLabelAnchorPoint(labelHeight) {
  return crispPixel(TICK_SIZE * 2 + labelHeight / 2);
}

function getDecimalLength(value) {
  var _String$split$1$lengt, _String$split$;

  return (_String$split$1$lengt = (_String$split$ = String(value).split('.')[1]) === null || _String$split$ === void 0 ? void 0 : _String$split$.length) !== null && _String$split$1$lengt !== void 0 ? _String$split$1$lengt : 0;
}

function findMultipleNum() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var underPointLens = args.map(function (value) {
    return getDecimalLength(value);
  });
  var underPointLen = Math.max.apply(Math, _toConsumableArray(underPointLens));
  return Math.pow(10, underPointLen);
}

function calculator_add(a, b) {
  var multipleNum = findMultipleNum(a, b);
  return (a * multipleNum + b * multipleNum) / multipleNum;
}
function multiply(a, b) {
  var multipleNum = findMultipleNum(a, b);
  return a * multipleNum * (b * multipleNum) / (multipleNum * multipleNum);
}
function divide(a, b) {
  var multipleNum = findMultipleNum(a, b);
  return a * multipleNum / (b * multipleNum);
}
function calculator_sum(values) {
  var copyArr = values.slice();
  copyArr.unshift(0);
  return copyArr.reduce(function (base, value) {
    return calculator_add(parseFloat(String(base)), parseFloat(String(value)));
  });
}
function divisors(value) {
  var result = [];

  for (var a = 2, b; a * a <= value; a += 1) {
    if (value % a === 0) {
      b = value / a;
      result.push(a);

      if (b !== a) {
        result.push(b);
      }
    }
  }

  return result.sort(function (prev, next) {
    return prev - next;
  });
}
function makeLabelsFromLimit(limit, stepSize, options) {
  var _options$xAxis;

  var multipleNum = findMultipleNum(stepSize);
  var min = Math.round(limit.min * multipleNum);
  var max = Math.round(limit.max * multipleNum);
  var labels = utils_range(min, max + 1, stepSize * multipleNum);
  var format = getDateFormat(options === null || options === void 0 ? void 0 : (_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : _options$xAxis.date);
  return labels.map(function (label) {
    return format ? formatDate(format, new Date(label)) : String(label / multipleNum);
  });
}
function makeTickPixelPositions(size, count) {
  var additionalPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var remainLastBlockIntervalPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var positions = [];

  if (count > 0) {
    positions = utils_range(0, count).map(function (index) {
      var ratio = index === 0 ? 0 : index / (count - 1);
      return ratio * size + additionalPosition;
    });
  }

  if (remainLastBlockIntervalPosition) {
    positions.push(remainLastBlockIntervalPosition);
  }

  return positions;
}
function crispPixel(pixel) {
  var thickness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var halfThickness = thickness / 2;
  return thickness % 2 ? (isInteger(pixel) ? pixel : Math.round(pixel - halfThickness)) + halfThickness : Math.round(pixel);
}

function getControlPoints(prev, cur, next) {
  // http://scaledinnovation.com/analytics/splines/aboutSplines.html
  var TENSION = 0.333;
  var x0 = prev.x,
      y0 = prev.y;
  var x1 = cur.x,
      y1 = cur.y;
  var x2 = next.x,
      y2 = next.y;
  var d12 = getDistance(next, cur);
  var d01 = getDistance(cur, prev);
  var fa = TENSION * d01 / (d01 + d12) || 0; // scaling factor for triangle Ta

  var fb = TENSION * d12 / (d01 + d12) || 0; // ditto for Tb, simplifies to fb=t-fa

  return {
    prev: {
      x: x1 - fa * (x2 - x0),
      // x2-x0 is the width of triangle T
      y: y1 - fa * (y2 - y0) // y2-y0 is the height of T

    },
    next: {
      x: x1 + fb * (x2 - x0),
      y: y1 + fb * (y2 - y0)
    }
  };
}

function setSplineControlPoint(points) {
  for (var i = 0, pointsSize = points.length, prev = points[0]; i < pointsSize; i += 1) {
    var point = points[i];

    if (isNull(point)) {
      prev = points[i + 1];
      continue;
    }

    var next = points[Math.min(i + 1, pointsSize - 1) % pointsSize];

    if (prev && next) {
      point.controlPoint = getControlPoints(prev, point, next);
    }

    prev = point;
  }
}
function getValueRatio(value, _ref) {
  var min = _ref.min,
      max = _ref.max;
  return (value - min) / (max - min);
}
function getDistance(point1, point2) {
  return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
}
function getMaxLengthLabelWidth(labels) {
  var maxLengthLabel = labels.reduce(function (acc, cur) {
    return acc.length > cur.length ? acc : cur;
  }, '');
  return getTextWidth(maxLengthLabel);
}
function getXPosition(axisData, offsetSize, xAxisLimit, value, dataIndex) {
  var pointOnColumn = axisData.pointOnColumn,
      tickDistance = axisData.tickDistance,
      labelDistance = axisData.labelDistance;
  var x;

  if (xAxisLimit) {
    var xValue = isString(value) ? Number(new Date(value)) : Number(value);
    var xValueRatio = getValueRatio(xValue, xAxisLimit);
    x = xValueRatio * (offsetSize - (pointOnColumn ? labelDistance : 0)) + (pointOnColumn ? labelDistance / 2 : 0);
  } else {
    x = tickDistance * dataIndex + (pointOnColumn ? tickDistance / 2 : 0);
  }

  return x;
}
// CONCATENATED MODULE: ./src/helpers/arrayUtil.ts

















function arrayUtil_slicedToArray(arr, i) { return arrayUtil_arrayWithHoles(arr) || arrayUtil_iterableToArrayLimit(arr, i) || arrayUtil_unsupportedIterableToArray(arr, i) || arrayUtil_nonIterableRest(); }

function arrayUtil_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function arrayUtil_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function arrayUtil_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function arrayUtil_toConsumableArray(arr) { return arrayUtil_arrayWithoutHoles(arr) || arrayUtil_iterableToArray(arr) || arrayUtil_unsupportedIterableToArray(arr) || arrayUtil_nonIterableSpread(); }

function arrayUtil_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function arrayUtil_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return arrayUtil_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayUtil_arrayLikeToArray(o, minLen); }

function arrayUtil_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function arrayUtil_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return arrayUtil_arrayLikeToArray(arr); }

function arrayUtil_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function arrayUtil_max(arr, condition, context) {
  var result;

  if (!condition) {
    result = Math.max.apply(Math, arrayUtil_toConsumableArray(arr));
  } else {
    var _arr2 = arrayUtil_slicedToArray(arr, 1);

    result = _arr2[0];
    var rest = arr.slice(1);
    var maxValue = condition.call(context, result, 0);
    rest.forEach(function (item, index) {
      var compareValue = condition.call(context, item, index + 1);

      if (compareValue > maxValue) {
        maxValue = compareValue;
        result = item;
      }
    });
  }

  return result;
}
/**
 * Array pivot.
 * @memberOf module:arrayUtil
 * @param {Array.<Array>} arr2d target 2d array
 * @returns {Array.<Array>} pivoted 2d array
 */

function pivot(arr2d) {
  var result = [];
  var len = arrayUtil_max(arr2d.map(function (arr) {
    return arr.length;
  }));
  arr2d.forEach(function (arr) {
    for (var index = 0; index < len; index += 1) {
      if (!result[index]) {
        result[index] = [];
      }

      result[index].push(arr[index]);
    }
  });
  return result;
}
function isSameArray(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }

  for (var i = 0; i < arr1.length; i += 1) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
}
function pluck(arr, property) {
  return arr.reduce(function (acc, cur) {
    return [].concat(arrayUtil_toConsumableArray(acc), [cur[property]]);
  }, []);
}
// CONCATENATED MODULE: ./src/component/component.ts























function component_toConsumableArray(arr) { return component_arrayWithoutHoles(arr) || component_iterableToArray(arr) || component_unsupportedIterableToArray(arr) || component_nonIterableSpread(); }

function component_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function component_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return component_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return component_arrayLikeToArray(o, minLen); }

function component_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function component_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return component_arrayLikeToArray(arr); }

function component_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function component_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function component_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { component_ownKeys(Object(source), true).forEach(function (key) { component_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { component_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function component_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function component_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function component_createClass(Constructor, protoProps, staticProps) { if (protoProps) component_defineProperties(Constructor.prototype, protoProps); if (staticProps) component_defineProperties(Constructor, staticProps); return Constructor; }

function component_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var component_Component = /*#__PURE__*/function () {
  function Component(_ref) {
    var store = _ref.store,
        eventBus = _ref.eventBus;

    component_classCallCheck(this, Component);

    component_defineProperty(this, "name", 'Component');

    component_defineProperty(this, "type", 'component');

    component_defineProperty(this, "rect", {
      x: 0,
      y: 0,
      height: 0,
      width: 0
    });

    component_defineProperty(this, "isShow", true);

    component_defineProperty(this, "selectable", void 0);

    component_defineProperty(this, "store", void 0);

    component_defineProperty(this, "eventBus", void 0);

    component_defineProperty(this, "models", void 0);

    component_defineProperty(this, "drawModels", void 0);

    component_defineProperty(this, "responders", void 0);

    component_defineProperty(this, "activeSeriesMap", void 0);

    this.store = store;
    this.eventBus = eventBus;
  }

  component_createClass(Component, [{
    key: "update",
    value: function update(delta) {
      var _this = this;

      if (!this.drawModels) {
        return;
      }

      if (Array.isArray(this.models)) {
        this.updateModels(this.drawModels, this.models, delta);
      } else {
        Object.keys(this.models).forEach(function (type) {
          var currentModels = _this.drawModels[type];
          var targetModels = _this.models[type];

          _this.updateModels(currentModels, targetModels, delta);
        });
      }
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      this.update(delta);
    }
  }, {
    key: "updateModels",
    value: function updateModels(currentModels, targetModels, delta) {
      var _this2 = this;

      currentModels.forEach(function (current, index) {
        var target = targetModels[index];
        Object.keys(current).forEach(function (key) {
          if (!current || !target) {
            return;
          }

          if (key[0] !== '_') {
            if (isNumber(current[key])) {
              current[key] = current[key] + (target[key] - current[key]) * delta;
            } else if (key === 'points') {
              var _ref2;

              var matchedModel = _this2.getCurrentModelToMatchTargetModel(current[key], current[key], target[key]);

              var newPoints = matchedModel.map(function (curPoint, idx) {
                var next = target[key][idx];

                if (curPoint && next) {
                  var x = curPoint.x,
                      y = curPoint.y;
                  var nextX = next.x,
                      nextY = next.y;
                  return component_objectSpread(component_objectSpread({}, next), {}, {
                    x: x + (nextX - x) * delta,
                    y: y + (nextY - y) * delta
                  });
                }

                return next;
              });

              if ((_ref2 = _this2.store.state.options.series) === null || _ref2 === void 0 ? void 0 : _ref2.spline) {
                setSplineControlPoint(newPoints);
              }

              current[key] = newPoints;
            } else {
              current[key] = target[key];
            }
          }
        });
      });
    }
  }, {
    key: "sync",
    value: function sync() {
      var _this3 = this;

      if (!this.drawModels) {
        return;
      }

      if (Array.isArray(this.models)) {
        this.syncModels(this.drawModels, this.models);
      } else {
        Object.keys(this.models).forEach(function (type) {
          var currentModels = _this3.drawModels[type];
          var targetModels = _this3.models[type];

          _this3.syncModels(currentModels, targetModels, type);
        });
      }
    }
  }, {
    key: "getCurrentModelToMatchTargetModel",
    value: function getCurrentModelToMatchTargetModel(models, currentModels, targetModels) {
      var _getFirstValidValue;

      if ((_getFirstValidValue = getFirstValidValue(targetModels)) === null || _getFirstValidValue === void 0 ? void 0 : _getFirstValidValue.name) {
        var modelNames = component_toConsumableArray(new Set(models.map(function (_ref3) {
          var name = _ref3.name;
          return name;
        })));

        var targetNames = component_toConsumableArray(new Set(targetModels.map(function (_ref4) {
          var name = _ref4.name;
          return name;
        })));

        var same = isSameArray(modelNames, targetNames);

        if (!same) {
          return this.getCurrentModelWithDifferentModel(models, currentModels, targetModels, modelNames, targetNames);
        }
      }

      var currentLength = currentModels.length;
      var targetLength = targetModels.length;

      if (currentLength < targetLength) {
        return [].concat(component_toConsumableArray(currentModels), component_toConsumableArray(targetModels.slice(currentLength, targetLength)));
      }

      if (currentLength > targetLength) {
        return currentModels.slice(0, targetLength);
      }

      return models;
    }
  }, {
    key: "getCurrentModelWithDifferentModel",
    value: function getCurrentModelWithDifferentModel(models, currentModels, targetModels, modelNames, targetNames) {
      var currentLength = currentModels.length;
      var targetLength = targetModels.length;

      if (currentLength > targetLength) {
        var newModels = models.filter(function (_ref5) {
          var name = _ref5.name;
          return includes(targetNames, name);
        });
        return newModels.length !== targetModels.length ? targetModels : newModels;
      }

      if (currentLength < targetLength) {
        var notIncludedModels = targetModels.reduce(function (acc, cur, idx) {
          var notIncluded = !includes(modelNames, cur.name);
          return notIncluded ? {
            models: [].concat(component_toConsumableArray(acc.models), [cur]),
            modelIdx: [].concat(component_toConsumableArray(acc.modelIdx), [idx])
          } : acc;
        }, {
          models: [],
          modelIdx: []
        });

        if (models.length + notIncludedModels.models.length === targetLength) {
          var _newModels = component_toConsumableArray(models);

          notIncludedModels.models.forEach(function (model, idx) {
            _newModels.splice(notIncludedModels.modelIdx[idx], 0, model);
          });
          return _newModels;
        }

        return targetModels;
      }

      return models;
    }
  }, {
    key: "syncModels",
    value: function syncModels(currentModels, targetModels, type) {
      var drawModels = type ? this.drawModels[type] : this.drawModels;
      var model = this.getCurrentModelToMatchTargetModel(drawModels, currentModels, targetModels);

      if (type) {
        this.drawModels[type] = model;
      } else {
        this.drawModels = model;
      }
    }
  }, {
    key: "getSelectableOption",
    value: function getSelectableOption(options) {
      var _options$series$selec, _options$series;

      return (_options$series$selec = options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.selectable) !== null && _options$series$selec !== void 0 ? _options$series$selec : false;
    }
  }, {
    key: "renderDataLabels",
    value: function renderDataLabels(data, name) {
      var _this4 = this;

      setTimeout(function () {
        _this4.eventBus.emit('renderDataLabels', {
          data: data,
          name: name !== null && name !== void 0 ? name : _this4.name
        });
      }, 0);
    }
  }, {
    key: "draw",
    value: function draw(painter) {
      var models = this.drawModels ? this.drawModels : this.models;

      if (Array.isArray(models)) {
        painter.paintForEach(models);
      } else if (models) {
        Object.keys(models).forEach(function (item) {
          painter.paintForEach(models[item]);
        });
      }
    }
  }]);

  return Component;
}();


// CONCATENATED MODULE: ./src/component/axis.ts
























function axis_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { axis_typeof = function _typeof(obj) { return typeof obj; }; } else { axis_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return axis_typeof(obj); }

function axis_toConsumableArray(arr) { return axis_arrayWithoutHoles(arr) || axis_iterableToArray(arr) || axis_unsupportedIterableToArray(arr) || axis_nonIterableSpread(); }

function axis_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function axis_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return axis_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return axis_arrayLikeToArray(o, minLen); }

function axis_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function axis_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return axis_arrayLikeToArray(arr); }

function axis_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function axis_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function axis_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { axis_ownKeys(Object(source), true).forEach(function (key) { axis_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { axis_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function axis_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function axis_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function axis_createClass(Constructor, protoProps, staticProps) { if (protoProps) axis_defineProperties(Constructor.prototype, protoProps); if (staticProps) axis_defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (axis_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function axis_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var AxisType;

(function (AxisType) {
  AxisType["X"] = "xAxis";
  AxisType["Y"] = "yAxis";
  AxisType["SECONDARY_Y"] = "secondaryYAxis";
})(AxisType || (AxisType = {}));

function getOffsetAndAnchorKey(hasBasedYAxis) {
  return {
    offsetKey: hasBasedYAxis ? 'y' : 'x',
    anchorKey: hasBasedYAxis ? 'x' : 'y'
  };
}

var axis_Axis = /*#__PURE__*/function (_Component) {
  _inherits(Axis, _Component);

  var _super = _createSuper(Axis);

  function Axis() {
    var _this;

    axis_classCallCheck(this, Axis);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    axis_defineProperty(_assertThisInitialized(_this), "models", {
      label: [],
      tick: [],
      axisLine: []
    });

    axis_defineProperty(_assertThisInitialized(_this), "drawModels", void 0);

    axis_defineProperty(_assertThisInitialized(_this), "yAxisComponent", void 0);

    axis_defineProperty(_assertThisInitialized(_this), "theme", void 0);

    axis_defineProperty(_assertThisInitialized(_this), "axisSize", 0);

    return _this;
  }

  axis_createClass(Axis, [{
    key: "initialize",
    value: function initialize(_ref) {
      var name = _ref.name;
      this.type = 'axis';
      this.name = name;
      this.yAxisComponent = includes([AxisType.Y, AxisType.SECONDARY_Y], name);
    }
  }, {
    key: "render",
    value: function render(_ref2) {
      var _this2 = this;

      var layout = _ref2.layout,
          axes = _ref2.axes,
          theme = _ref2.theme;

      if (axes.centerYAxis || !axes[this.name]) {
        return;
      }

      this.theme = getAxisTheme(theme, this.name);
      this.rect = layout[this.name];
      this.axisSize = this.yAxisComponent ? this.rect.height : this.rect.width;
      var viewLabels = axes[this.name].viewLabels;

      var _getOffsetAndAnchorKe = getOffsetAndAnchorKey(this.yAxisComponent),
          offsetKey = _getOffsetAndAnchorKe.offsetKey,
          anchorKey = _getOffsetAndAnchorKe.anchorKey;

      var renderOptions = this.makeRenderOptions(axes[this.name]);
      var hasOnlyAxisLine = this.hasOnlyAxisLine();

      if (!hasOnlyAxisLine) {
        this.models.label = this.renderLabelModels(viewLabels, offsetKey, anchorKey, renderOptions);
        this.models.tick = this.renderTickModels(offsetKey, anchorKey, renderOptions);
      }

      this.models.axisLine = [this.renderAxisLineModel()];

      if (!this.drawModels) {
        this.drawModels = {
          tick: [],
          label: [],
          axisLine: this.models.axisLine
        };
        ['tick', 'label'].forEach(function (type) {
          _this2.drawModels[type] = _this2.models[type].map(function (m) {
            var drawModel = axis_objectSpread({}, m);

            if (_this2.yAxisComponent) {
              drawModel.y = 0;
            } else {
              drawModel.x = 0;
            }

            return drawModel;
          });
        });
      }
    }
  }, {
    key: "renderAxisLineModel",
    value: function renderAxisLineModel() {
      var zeroPixel = crispPixel(0);
      var lineModel;
      var _this$theme = this.theme,
          strokeStyle = _this$theme.color,
          lineWidth = _this$theme.width;

      if (this.yAxisComponent) {
        var x = this.getYAxisXPoint();
        lineModel = {
          type: 'line',
          x: x,
          y: zeroPixel,
          x2: x,
          y2: crispPixel(this.axisSize),
          strokeStyle: strokeStyle,
          lineWidth: lineWidth
        };
      } else {
        lineModel = {
          type: 'line',
          x: zeroPixel,
          y: zeroPixel,
          x2: crispPixel(this.axisSize),
          y2: zeroPixel,
          strokeStyle: strokeStyle,
          lineWidth: lineWidth
        };
      }

      return lineModel;
    }
  }, {
    key: "renderTickModels",
    value: function renderTickModels(offsetKey, anchorKey, renderOptions) {
      var _this3 = this;

      var tickAnchorPoint = this.yAxisComponent ? this.getYAxisXPoint() : crispPixel(0);
      var tickInterval = renderOptions.tickInterval,
          relativePositions = renderOptions.relativePositions;
      var tickSize = includes([AxisType.SECONDARY_Y, AxisType.X], this.name) ? TICK_SIZE : -TICK_SIZE;
      return relativePositions.reduce(function (positions, position, index) {
        var _ref3;

        return index % tickInterval ? positions : [].concat(axis_toConsumableArray(positions), [(_ref3 = {
          type: 'tick',
          isYAxis: _this3.yAxisComponent,
          tickSize: tickSize
        }, axis_defineProperty(_ref3, offsetKey, crispPixel(position)), axis_defineProperty(_ref3, anchorKey, tickAnchorPoint), axis_defineProperty(_ref3, "strokeStyle", _this3.theme.color), axis_defineProperty(_ref3, "lineWidth", _this3.theme.width), _ref3)]);
      }, []);
    }
  }, {
    key: "renderLabelModels",
    value: function renderLabelModels(labels, offsetKey, anchorKey, renderOptions) {
      var needRotateLabel = renderOptions.needRotateLabel,
          radian = renderOptions.radian,
          offsetY = renderOptions.offsetY;
      var labelTheme = this.theme.label;
      var font = getTitleFontString(labelTheme);
      var textAlign = this.getLabelTextAlign(needRotateLabel);
      var style = ['default', {
        textAlign: textAlign,
        font: font,
        fillStyle: labelTheme.color
      }];
      var labelAnchorPoint = this.yAxisComponent ? this.getYAxisAnchorPoint() : offsetY;
      return labels.map(function (_ref4) {
        var _ref5;

        var text = _ref4.text,
            offsetPos = _ref4.offsetPos;
        return _ref5 = {
          type: 'label',
          text: text,
          style: style,
          radian: radian
        }, axis_defineProperty(_ref5, offsetKey, crispPixel(offsetPos)), axis_defineProperty(_ref5, anchorKey, labelAnchorPoint), _ref5;
      });
    }
  }, {
    key: "makeRenderOptions",
    value: function makeRenderOptions(axisData) {
      var tickCount = axisData.tickCount,
          tickInterval = axisData.tickInterval;
      var relativePositions = makeTickPixelPositions(this.axisSize, tickCount);

      if (this.yAxisComponent) {
        return {
          relativePositions: relativePositions,
          tickInterval: tickInterval
        };
      }

      var needRotateLabel = axisData.needRotateLabel,
          radian = axisData.radian,
          offsetY = axisData.offsetY;
      return {
        relativePositions: relativePositions,
        tickInterval: tickInterval,
        needRotateLabel: needRotateLabel,
        radian: radian,
        offsetY: offsetY
      };
    }
  }, {
    key: "getYAxisAnchorPoint",
    value: function getYAxisAnchorPoint() {
      return this.isRightSide() ? crispPixel(this.rect.width) : crispPixel(0);
    }
  }, {
    key: "getLabelTextAlign",
    value: function getLabelTextAlign(needRotateLabel) {
      var yAxisTextAlign = this.isRightSide() ? 'right' : 'left';
      var xAxisTextAlign = needRotateLabel ? 'left' : 'center';
      return this.yAxisComponent ? yAxisTextAlign : xAxisTextAlign;
    }
  }, {
    key: "isRightSide",
    value: function isRightSide() {
      return this.name === AxisType.SECONDARY_Y;
    }
  }, {
    key: "getYAxisXPoint",
    value: function getYAxisXPoint() {
      return this.isRightSide() ? crispPixel(0) : crispPixel(this.rect.width);
    }
  }, {
    key: "hasOnlyAxisLine",
    value: function hasOnlyAxisLine() {
      return this.yAxisComponent && !this.rect.width || this.name === AxisType.X && !this.rect.height;
    }
  }]);

  return Axis;
}(component_Component);


// CONCATENATED MODULE: ./src/helpers/geometric.ts
var RAD = Math.PI / 180;
var ANGLE_90 = 90;
var ANGLE_CANDIDATES = [0, 25, 45, 65, 85, 90];
/**
 * Calculate adjacent.
 *
 *   H : Hypotenuse
 *   A : Adjacent
 *   O : Opposite
 *   D : Degree
 *
 *        /|
 *       / |
 *    H /  | O
 *     /   |
 *    /\ D |
 *    -----
 *       A
 */

function calculateAdjacent(degree, hypotenuse) {
  return Math.cos(degree * RAD) * hypotenuse;
}

function calculateOpposite(degree, hypotenuse) {
  return Math.sin(degree * RAD) * hypotenuse;
}

function calculateRotatedWidth(degree, width, height) {
  var centerHalf = calculateAdjacent(degree, width / 2);
  var sideHalf = calculateAdjacent(ANGLE_90 - degree, height / 2);
  return (centerHalf + sideHalf) * 2;
}
function calculateRotatedHeight(degree, width, height) {
  var centerHalf = calculateOpposite(degree, width / 2);
  var sideHalf = calculateOpposite(ANGLE_90 - degree, height / 2);
  return (centerHalf + sideHalf) * 2;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.anchor.js
var es_string_anchor = __webpack_require__(78);

// CONCATENATED MODULE: ./src/helpers/sector.ts









function sector_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function sector_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { sector_ownKeys(Object(source), true).forEach(function (key) { sector_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { sector_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function sector_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


function makeAnchorPositionParam(anchor, model) {
  return sector_objectSpread({
    anchor: anchor
  }, pick(model, 'x', 'y', 'radius', 'degree', 'drawingStartAngle'));
}
function calculateDegreeToRadian(degree) {
  var drawingStartAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -90;
  var result = 0;

  if (degree % 360 === 0) {
    result = Math.PI / 180 * drawingStartAngle;
  } else if (degree >= 0 && degree < 360) {
    result = Math.PI / 180 * (degree + drawingStartAngle);
  }

  return result;
}
function calculateRadianToDegree(radian) {
  var drawingStartAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -90;
  return (radian * 180 / Math.PI - drawingStartAngle + 360) % 360;
}
function getRadialAnchorPosition(param) {
  var anchor = param.anchor,
      x = param.x,
      y = param.y,
      _param$radius = param.radius,
      inner = _param$radius.inner,
      outer = _param$radius.outer,
      _param$degree = param.degree,
      start = _param$degree.start,
      end = _param$degree.end,
      drawingStartAngle = param.drawingStartAngle;
  var halfDegree = start + (end - start) / 2;
  var radian = calculateDegreeToRadian(halfDegree, drawingStartAngle);
  var r = anchor === 'center' ? (outer - inner) / 2 + inner : outer;
  return getRadialPosition(x, y, r, radian);
}
function getRadialPosition(x, y, r, radian) {
  return {
    x: Math.round(x + r * Math.cos(radian)),
    y: Math.round(y + r * Math.sin(radian))
  };
}
function withinRadian(clockwise, startDegree, endDegree, currentDegree) {
  return clockwise ? startDegree <= currentDegree && endDegree >= currentDegree : startDegree >= currentDegree && endDegree <= currentDegree;
}
// CONCATENATED MODULE: ./src/helpers/axes.ts























function axes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function axes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { axes_ownKeys(Object(source), true).forEach(function (key) { axes_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { axes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function axes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function axes_toConsumableArray(arr) { return axes_arrayWithoutHoles(arr) || axes_iterableToArray(arr) || axes_unsupportedIterableToArray(arr) || axes_nonIterableSpread(); }

function axes_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function axes_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return axes_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return axes_arrayLikeToArray(o, minLen); }

function axes_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function axes_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return axes_arrayLikeToArray(arr); }

function axes_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }









function makeAdjustingIntervalInfo(blockCount, axisWidth, blockSize) {
  var remainBlockCount;
  var newBlockCount = Math.floor(axisWidth / blockSize);
  var intervalInfo = null;
  var interval = newBlockCount ? Math.floor(blockCount / newBlockCount) : blockCount;

  if (interval > 1) {
    // remainBlockCount : remaining block count after filling new blocks
    // | | | | | | | | | | | |  - previous block interval
    // |     |     |     |      - new block interval
    //                   |*|*|  - remaining block
    remainBlockCount = blockCount - interval * newBlockCount;

    if (remainBlockCount >= interval) {
      newBlockCount += Math.floor(remainBlockCount / interval);
      remainBlockCount = remainBlockCount % interval;
    }

    intervalInfo = {
      blockCount: newBlockCount,
      remainBlockCount: remainBlockCount,
      interval: interval
    };
  }

  return intervalInfo;
}

function getAutoAdjustingInterval(count, axisWidth, categories) {
  var autoInterval = {
    MIN_WIDTH: 90,
    MAX_WIDTH: 121,
    STEP_SIZE: 5
  };
  var LABEL_MARGIN = 5;

  if (categories === null || categories === void 0 ? void 0 : categories[0]) {
    var categoryMinWidth = getTextWidth(categories[0]);

    if (categoryMinWidth < axisWidth / count - LABEL_MARGIN) {
      return 1;
    }
  }

  var candidates = [];
  divisors(count).forEach(function (interval) {
    var intervalWidth = interval / count * axisWidth;

    if (intervalWidth >= autoInterval.MIN_WIDTH && intervalWidth <= autoInterval.MAX_WIDTH) {
      candidates.push({
        interval: interval,
        blockCount: Math.floor(count / interval),
        remainBlockCount: 0
      });
    }
  });

  if (!candidates.length) {
    var blockSizeRange = utils_range(autoInterval.MIN_WIDTH, autoInterval.MAX_WIDTH, autoInterval.STEP_SIZE);
    candidates = blockSizeRange.reduce(function (acc, blockSize) {
      var candidate = makeAdjustingIntervalInfo(count, axisWidth, blockSize);
      return candidate ? [].concat(axes_toConsumableArray(acc), [candidate]) : acc;
    }, []);
  }

  var tickInterval = 1;

  if (candidates.length) {
    var candidate = candidates.reduce(function (acc, cur) {
      return cur.blockCount > acc.blockCount ? cur : acc;
    }, {
      blockCount: 0,
      interval: 1
    });
    tickInterval = candidate.interval;
  }

  return tickInterval;
}
function isLabelAxisOnYAxis(series, options) {
  var _ref, _ref$series;

  return !!series.bar || !!series.bullet && !((_ref = options) === null || _ref === void 0 ? void 0 : (_ref$series = _ref.series) === null || _ref$series === void 0 ? void 0 : _ref$series.vertical);
}
function hasBoxTypeSeries(series) {
  return !!series.column || !!series.bar || !!series.boxPlot || !!series.bullet;
}
function isPointOnColumn(series, options) {
  if (hasBoxTypeSeries(series)) {
    return true;
  }

  if (series.line || series.area) {
    var _ref2;

    return Boolean((_ref2 = options.xAxis) === null || _ref2 === void 0 ? void 0 : _ref2.pointOnColumn);
  }

  return false;
}
function getAxisName(labelAxisOnYAxis) {
  return {
    valueAxisName: labelAxisOnYAxis ? 'xAxis' : 'yAxis',
    labelAxisName: labelAxisOnYAxis ? 'yAxis' : 'xAxis'
  };
}
function getSizeKey(labelAxisOnYAxis) {
  return {
    valueSizeKey: labelAxisOnYAxis ? 'width' : 'height',
    labelSizeKey: labelAxisOnYAxis ? 'height' : 'width'
  };
}
function getLimitOnAxis(labels) {
  var values = labels.map(function (label) {
    return Number(label);
  });
  return {
    min: Math.min.apply(Math, axes_toConsumableArray(values)),
    max: Math.max.apply(Math, axes_toConsumableArray(values))
  };
}
function hasSecondaryYAxis(options) {
  return Array.isArray(options === null || options === void 0 ? void 0 : options.yAxis) && options.yAxis.length === 2;
}
function getYAxisOption(options) {
  var secondaryYAxis = hasSecondaryYAxis(options);
  return {
    yAxis: secondaryYAxis ? options.yAxis[0] : options === null || options === void 0 ? void 0 : options.yAxis,
    secondaryYAxis: secondaryYAxis ? options.yAxis[1] : null
  };
}
function getValueAxisName(options, seriesName, valueAxisName) {
  var _getYAxisOption = getYAxisOption(options),
      secondaryYAxis = _getYAxisOption.secondaryYAxis;

  return (secondaryYAxis === null || secondaryYAxis === void 0 ? void 0 : secondaryYAxis.chartType) === seriesName ? 'secondaryYAxis' : valueAxisName;
}
function getValueAxisNames(options, valueAxisName) {
  var _getYAxisOption2 = getYAxisOption(options),
      yAxis = _getYAxisOption2.yAxis,
      secondaryYAxis = _getYAxisOption2.secondaryYAxis;

  return valueAxisName !== 'xAxis' && secondaryYAxis ? [yAxis.chartType, secondaryYAxis.chartType].map(function (seriesName, index) {
    return seriesName ? getValueAxisName(options, seriesName, valueAxisName) : ['yAxis', 'secondaryYAxis'][index];
  }) : [valueAxisName];
}
function getAxisTheme(theme, name) {
  var xAxis = theme.xAxis,
      yAxis = theme.yAxis;
  var axisTheme;

  if (name === AxisType.X) {
    axisTheme = xAxis;
  } else if (Array.isArray(yAxis)) {
    axisTheme = name === AxisType.Y ? yAxis[0] : yAxis[1];
  } else {
    axisTheme = yAxis;
  }

  return axisTheme;
}

function getRotationDegree(distance, labelWidth, labelHeight) {
  var degree = 0;
  ANGLE_CANDIDATES.every(function (angle) {
    var compareWidth = calculateRotatedWidth(angle, labelWidth, labelHeight);
    degree = angle;
    return compareWidth > distance;
  });
  return distance < labelWidth ? degree : 0;
}

function hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, field) {
  var prevYAxis = previousAxes[field];
  var yAxis = currentAxes[field];

  if (!prevYAxis && !yAxis) {
    return false;
  }

  return (prevYAxis === null || prevYAxis === void 0 ? void 0 : prevYAxis.maxLabelWidth) !== (yAxis === null || yAxis === void 0 ? void 0 : yAxis.maxLabelWidth);
}

function hasYAxisTypeMaxLabelChanged(previousAxes, currentAxes) {
  return hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, 'yAxis') || hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, 'secondaryYAxis');
}

function hasXAxisSizeChanged(previousAxes, currentAxes) {
  var prevMaxHeight = previousAxes.xAxis.maxHeight;
  var maxHeight = currentAxes.xAxis.maxHeight;
  return prevMaxHeight !== maxHeight;
}

function hasAxesLayoutChanged(previousAxes, currentAxes) {
  return hasYAxisTypeMaxLabelChanged(previousAxes, currentAxes) || hasXAxisSizeChanged(previousAxes, currentAxes);
}
function getRotatableOption(options) {
  var _options$xAxis$label$, _options$xAxis, _options$xAxis$label;

  return (_options$xAxis$label$ = options === null || options === void 0 ? void 0 : (_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : (_options$xAxis$label = _options$xAxis.label) === null || _options$xAxis$label === void 0 ? void 0 : _options$xAxis$label.rotatable) !== null && _options$xAxis$label$ !== void 0 ? _options$xAxis$label$ : true;
}
function getViewAxisLabels(axisData, axisSize) {
  var labels = axisData.labels,
      pointOnColumn = axisData.pointOnColumn,
      labelDistance = axisData.labelDistance,
      tickDistance = axisData.tickDistance,
      labelInterval = axisData.labelInterval,
      tickInterval = axisData.tickInterval,
      tickCount = axisData.tickCount;
  var relativePositions = makeTickPixelPositions(axisSize, tickCount);
  var interval = labelInterval === tickInterval ? labelInterval : 1;
  var labelAdjustment = pointOnColumn ? (labelDistance !== null && labelDistance !== void 0 ? labelDistance : tickDistance * interval) / 2 : 0;
  return labels.reduce(function (acc, text, index) {
    var offsetPos = relativePositions[index] + labelAdjustment;
    var needRender = !(index % labelInterval) && offsetPos <= axisSize;
    return needRender ? [].concat(axes_toConsumableArray(acc), [{
      offsetPos: offsetPos,
      text: text
    }]) : acc;
  }, []);
}
function makeTitleOption(title) {
  if (isUndefined(title)) {
    return title;
  }

  var defaultOption = {
    text: '',
    offsetX: 0,
    offsetY: 0
  };
  return isString(title) ? axes_objectSpread(axes_objectSpread({}, defaultOption), {}, {
    text: title
  }) : axes_objectSpread(axes_objectSpread({}, defaultOption), title);
}
function makeFormattedCategory(categories, date) {
  var format = getDateFormat(date);
  return categories.map(function (category) {
    return format ? formatDate(format, new Date(category)) : category;
  });
}
function makeRotationData(maxLabelWidth, maxLabelHeight, distance, rotatable) {
  var degree = getRotationDegree(distance, maxLabelWidth, maxLabelHeight);

  if (!rotatable || degree === 0) {
    return {
      needRotateLabel: false,
      radian: 0,
      rotationHeight: maxLabelHeight
    };
  }

  return {
    needRotateLabel: degree > 0,
    radian: calculateDegreeToRadian(degree, 0),
    rotationHeight: calculateRotatedHeight(degree, maxLabelWidth, maxLabelHeight)
  };
}
function getMaxLabelSize(labels, xMargin) {
  var font = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_LABEL_TEXT;
  var maxLengthLabel = labels.reduce(function (acc, cur) {
    return acc.length > cur.length ? acc : cur;
  }, '');
  return {
    maxLabelWidth: getTextWidth(maxLengthLabel, font) + xMargin,
    maxLabelHeight: getTextHeight(maxLengthLabel, font)
  };
}
function getLabelXMargin(axisName, options) {
  var _axisOptions$axisName, _axisOptions$axisName2, _axisOptions$axisName3;

  if (axisName === 'xAxis') {
    return 0;
  }

  var axisOptions = getYAxisOption(options);
  return Math.abs((_axisOptions$axisName = axisOptions === null || axisOptions === void 0 ? void 0 : (_axisOptions$axisName2 = axisOptions[axisName]) === null || _axisOptions$axisName2 === void 0 ? void 0 : (_axisOptions$axisName3 = _axisOptions$axisName2.label) === null || _axisOptions$axisName3 === void 0 ? void 0 : _axisOptions$axisName3.margin) !== null && _axisOptions$axisName !== void 0 ? _axisOptions$axisName : 0);
}
// CONCATENATED MODULE: ./src/helpers/range.ts


function isRangeValue(value) {
  return Array.isArray(value) && value.length === 2;
}
function isRangeData(data) {
  return Array.isArray(data) && isRangeValue(getFirstValidValue(data));
}
function isZooming(categories, zoomRange) {
  return !!(zoomRange && (zoomRange[0] !== 0 || zoomRange[1] !== categories.length - 1));
}
function getDataInRange(data, range) {
  if (!range) {
    return data;
  }

  return data.slice(range[0], range[1] + 1);
}
// CONCATENATED MODULE: ./src/helpers/coordinate.ts



function getCoordinateYValue(datum) {
  if (isNumber(datum)) {
    return datum;
  }

  return Array.isArray(datum) ? datum[1] : datum.y;
}
function getCoordinateXValue(datum) {
  return Array.isArray(datum) ? datum[0] : datum.x;
}
function isValueAfterLastCategory(value, categories) {
  var category = last(categories);

  if (!category) {
    return false;
  }

  return isNumber(value) ? value >= Number(category) : new Date(value) >= new Date(category);
}
function getCoordinateDataIndex(datum, categories, dataIndex, startIndex) {
  if (isNumber(datum)) {
    return dataIndex - startIndex;
  }

  var value = getCoordinateXValue(datum);
  var index = categories.findIndex(function (category) {
    return category === String(value);
  });

  if (index === -1 && isValueAfterLastCategory(value, categories)) {
    index = categories.length;
  }

  return index;
}

function isLineCoordinateSeries(series) {
  if (!series.line || !series.line.data.length) {
    return false;
  }

  var firstData = getFirstValidValue(series.line.data[0].data);
  return firstData && (Array.isArray(firstData) || isObject(firstData));
}

function isCoordinateSeries(series) {
  return isLineCoordinateSeries(series) || !!series.scatter || !!series.bubble;
}
function isModelExistingInRect(rect, point) {
  var height = rect.height,
      width = rect.width;
  var x = point.x,
      y = point.y;
  return x >= 0 && x <= width && y >= 0 && y <= height;
}
// CONCATENATED MODULE: ./src/store/axes.ts




















function store_axes_toConsumableArray(arr) { return store_axes_arrayWithoutHoles(arr) || store_axes_iterableToArray(arr) || store_axes_unsupportedIterableToArray(arr) || store_axes_nonIterableSpread(); }

function store_axes_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function store_axes_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return store_axes_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return store_axes_arrayLikeToArray(o, minLen); }

function store_axes_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function store_axes_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return store_axes_arrayLikeToArray(arr); }

function store_axes_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function store_axes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function store_axes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { store_axes_ownKeys(Object(source), true).forEach(function (key) { store_axes_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { store_axes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function store_axes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








function isCenterYAxis(options, isBar) {
  var _ref;

  var diverging = !!pickProperty(options, ['series', 'diverging']);
  var alignCenter = ((_ref = options.yAxis) === null || _ref === void 0 ? void 0 : _ref.align) === 'center';
  return isBar && diverging && alignCenter;
}

function isDivergingBoxSeries(series, options) {
  var _ref2;

  return hasBoxTypeSeries(series) && !!((_ref2 = options.series) === null || _ref2 === void 0 ? void 0 : _ref2.diverging);
}

function getZeroPosition(limit, axisSize, labelAxisOnYAxis, isDivergingSeries) {
  var min = limit.min,
      max = limit.max;
  var hasZeroValue = min <= 0 && max >= 0;

  if (!hasZeroValue || isDivergingSeries) {
    return null;
  }

  var position = (0 - min) / (max - min) * axisSize;
  return labelAxisOnYAxis ? position : axisSize - position;
}

function getAxisFormatter(options, axisName) {
  var _axisOptions$axisName, _axisOptions$axisName2, _axisOptions$axisName3;

  var axisOptions = store_axes_objectSpread(store_axes_objectSpread({}, getYAxisOption(options)), {}, {
    xAxis: options.xAxis
  });

  return (_axisOptions$axisName = (_axisOptions$axisName2 = axisOptions[axisName]) === null || _axisOptions$axisName2 === void 0 ? void 0 : (_axisOptions$axisName3 = _axisOptions$axisName2.label) === null || _axisOptions$axisName3 === void 0 ? void 0 : _axisOptions$axisName3.formatter) !== null && _axisOptions$axisName !== void 0 ? _axisOptions$axisName : function (value) {
    return value;
  };
}

function getLabelAxisData(stateProp) {
  var _options$xAxis;

  var axisSize = stateProp.axisSize,
      categories = stateProp.categories,
      series = stateProp.series,
      options = stateProp.options,
      theme = stateProp.theme,
      scale = stateProp.scale,
      zoomRange = stateProp.zoomRange,
      rawCategories = stateProp.rawCategories,
      initialAxisData = stateProp.initialAxisData,
      isCoordinateTypeChart = stateProp.isCoordinateTypeChart,
      axisName = stateProp.axisName;
  var pointOnColumn = isPointOnColumn(series, options);
  var labelsBeforeFormatting = !isZooming(rawCategories, zoomRange) && isCoordinateTypeChart ? makeLabelsFromLimit(scale.limit, scale.stepSize, options) : makeFormattedCategory(categories, options === null || options === void 0 ? void 0 : (_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : _options$xAxis.date);
  var formatter = getAxisFormatter(options, axisName); // @TODO: regenerate label when exceeding max width

  var labels = labelsBeforeFormatting.map(function (label, index) {
    return formatter(label, {
      index: index,
      labels: labelsBeforeFormatting,
      axisName: axisName
    });
  });
  var tickIntervalCount = categories.length - (pointOnColumn ? 0 : 1);
  var tickDistance = tickIntervalCount ? axisSize / tickIntervalCount : axisSize;
  var labelDistance = axisSize / (labels.length - (pointOnColumn ? 0 : 1));
  var tickCount = labels.length + (pointOnColumn ? 1 : 0);
  var viewLabels = getViewAxisLabels(store_axes_objectSpread({
    labels: labels,
    pointOnColumn: pointOnColumn,
    tickDistance: tickDistance,
    tickCount: tickCount
  }, initialAxisData), axisSize);
  var axisLabelMargin = getLabelXMargin(axisName, options);
  return store_axes_objectSpread(store_axes_objectSpread({
    labels: labels,
    viewLabels: viewLabels,
    pointOnColumn: pointOnColumn,
    labelDistance: labelDistance,
    tickDistance: tickDistance,
    tickCount: tickCount,
    isLabelAxis: true
  }, initialAxisData), getMaxLabelSize(labels, axisLabelMargin, getTitleFontString(theme.label)));
}

function getValueAxisData(stateProp) {
  var scale = stateProp.scale,
      axisSize = stateProp.axisSize,
      series = stateProp.series,
      options = stateProp.options,
      centerYAxis = stateProp.centerYAxis,
      initialAxisData = stateProp.initialAxisData,
      theme = stateProp.theme,
      labelOnYAxis = stateProp.labelOnYAxis,
      axisName = stateProp.axisName;
  var limit = scale.limit,
      stepSize = scale.stepSize;
  var size = centerYAxis ? centerYAxis === null || centerYAxis === void 0 ? void 0 : centerYAxis.xAxisHalfSize : axisSize;
  var divergingBoxSeries = isDivergingBoxSeries(series, options);
  var formatter = getAxisFormatter(options, axisName);
  var zeroPosition = getZeroPosition(limit, axisSize, isLabelAxisOnYAxis(series, options), divergingBoxSeries);
  var valueLabels = makeLabelsFromLimit(limit, stepSize);

  if (!centerYAxis && divergingBoxSeries) {
    valueLabels = getDivergingValues(valueLabels);
  }

  var labels = valueLabels.map(function (label, index) {
    return formatter(label, {
      index: index,
      labels: valueLabels,
      axisName: axisName
    });
  });
  var tickDistance = size / Math.max(valueLabels.length, 1);
  var tickCount = valueLabels.length;
  var pointOnColumn = false;
  var viewLabels = getViewAxisLabels(store_axes_objectSpread({
    labels: labelOnYAxis ? labels : store_axes_toConsumableArray(labels).reverse(),
    pointOnColumn: pointOnColumn,
    tickDistance: tickDistance,
    tickCount: tickCount
  }, initialAxisData), size);
  var axisLabelMargin = getLabelXMargin(axisName, options);

  var axisData = store_axes_objectSpread(store_axes_objectSpread({
    labels: labels,
    viewLabels: viewLabels,
    pointOnColumn: pointOnColumn,
    isLabelAxis: false,
    tickCount: tickCount,
    tickDistance: tickDistance
  }, initialAxisData), getMaxLabelSize(labels, axisLabelMargin, getTitleFontString(theme.label)));

  if (isNumber(zeroPosition)) {
    axisData.zeroPosition = zeroPosition;
  }

  return axisData;
}

function getDivergingValues(valueLabels) {
  return hasNegativeOnly(valueLabels) ? valueLabels.reverse().slice(1).concat(valueLabels) : valueLabels.slice(1).reverse().concat(valueLabels);
}

function getRadialAxis(scale, plot, theme, _ref3, options) {
  var labelInterval = _ref3.labelInterval;
  var limit = scale.limit,
      stepSize = scale.stepSize;
  var width = plot.width,
      height = plot.height;
  var valueLabels = makeLabelsFromLimit(limit, stepSize);
  var formatter = getAxisFormatter(options, 'yAxis');
  var labels = valueLabels.map(function (label) {
    return formatter(label);
  });
  var axisSize = Math.min(width, height) / 2 - 50;
  return store_axes_objectSpread({
    labels: labels,
    axisSize: axisSize,
    centerX: width / 2,
    centerY: height / 2,
    labelInterval: labelInterval
  }, getMaxLabelSize(labels, 0, getTitleFontString(theme.label)));
}

function getInitTickInterval(categories, layout) {
  if (!categories || !layout) {
    return 1;
  }

  var width = layout.xAxis.width;
  var count = categories.length;
  return getAutoAdjustingInterval(count, width, categories);
}

function getInitAxisIntervalData(isLabelAxis, params) {
  var _axis$tick, _axis$label, _axis$scale;

  var axis = params.axis,
      categories = params.categories,
      layout = params.layout,
      isCoordinateTypeChart = params.isCoordinateTypeChart;
  var tickInterval = axis === null || axis === void 0 ? void 0 : (_axis$tick = axis.tick) === null || _axis$tick === void 0 ? void 0 : _axis$tick.interval;
  var labelInterval = axis === null || axis === void 0 ? void 0 : (_axis$label = axis.label) === null || _axis$label === void 0 ? void 0 : _axis$label.interval;
  var existIntervalOptions = isNumber(tickInterval) || isNumber(labelInterval);
  var needAdjustInterval = isLabelAxis && !isNumber(axis === null || axis === void 0 ? void 0 : (_axis$scale = axis.scale) === null || _axis$scale === void 0 ? void 0 : _axis$scale.stepSize) && !params.shift && !existIntervalOptions && !isCoordinateTypeChart;
  var initTickInterval = needAdjustInterval ? getInitTickInterval(categories, layout) : 1;
  var initLabelInterval = needAdjustInterval ? initTickInterval : 1;
  var axisData = {
    tickInterval: tickInterval !== null && tickInterval !== void 0 ? tickInterval : initTickInterval,
    labelInterval: labelInterval !== null && labelInterval !== void 0 ? labelInterval : initLabelInterval
  };
  return axisData;
}

function makeDefaultAxisData(isLabelAxis, params) {
  var _params$axis;

  var axisData = getInitAxisIntervalData(isLabelAxis, params);
  var title = makeTitleOption(params === null || params === void 0 ? void 0 : (_params$axis = params.axis) === null || _params$axis === void 0 ? void 0 : _params$axis.title);

  if (title) {
    axisData.title = title;
  }

  return axisData;
}

function getInitialAxisData(options, labelOnYAxis, categories, layout, isCoordinateTypeChart) {
  var _ref4;

  var _getYAxisOption = getYAxisOption(options),
      yAxis = _getYAxisOption.yAxis,
      secondaryYAxis = _getYAxisOption.secondaryYAxis;

  var shift = (_ref4 = options === null || options === void 0 ? void 0 : options.series) === null || _ref4 === void 0 ? void 0 : _ref4.shift;
  return {
    xAxis: makeDefaultAxisData(!labelOnYAxis, {
      categories: categories,
      axis: options === null || options === void 0 ? void 0 : options.xAxis,
      layout: layout,
      shift: shift,
      isCoordinateTypeChart: isCoordinateTypeChart
    }),
    yAxis: makeDefaultAxisData(labelOnYAxis, {
      axis: yAxis
    }),
    secondaryYAxis: secondaryYAxis ? makeDefaultAxisData(labelOnYAxis, {
      axis: secondaryYAxis
    }) : null
  };
}

function getSecondaryYAxisData(_ref5) {
  var _getYAxisOption$secon, _getYAxisOption$secon2;

  var state = _ref5.state,
      labelOnYAxis = _ref5.labelOnYAxis,
      valueAxisSize = _ref5.valueAxisSize,
      labelAxisSize = _ref5.labelAxisSize,
      initialAxisData = _ref5.initialAxisData,
      isCoordinateTypeChart = _ref5.isCoordinateTypeChart;
  var scale = state.scale,
      options = state.options,
      series = state.series,
      zoomRange = state.zoomRange,
      theme = state.theme;
  var categories = state.categories;
  var rawCategories = state.rawCategories;
  return labelOnYAxis ? getLabelAxisData({
    scale: scale.secondaryYAxis,
    axisSize: labelAxisSize,
    categories: (_getYAxisOption$secon = (_getYAxisOption$secon2 = getYAxisOption(options).secondaryYAxis) === null || _getYAxisOption$secon2 === void 0 ? void 0 : _getYAxisOption$secon2.categories) !== null && _getYAxisOption$secon !== void 0 ? _getYAxisOption$secon : categories,
    rawCategories: rawCategories,
    options: options,
    series: series,
    theme: getAxisTheme(theme, AxisType.SECONDARY_Y),
    zoomRange: zoomRange,
    initialAxisData: initialAxisData,
    isCoordinateTypeChart: isCoordinateTypeChart,
    axisName: AxisType.SECONDARY_Y
  }) : getValueAxisData({
    scale: scale.secondaryYAxis,
    axisSize: valueAxisSize,
    options: options,
    series: series,
    theme: getAxisTheme(theme, AxisType.SECONDARY_Y),
    centerYAxis: null,
    initialAxisData: initialAxisData,
    axisName: AxisType.SECONDARY_Y
  });
}

function makeXAxisData(_ref6) {
  var axisData = _ref6.axisData,
      axisSize = _ref6.axisSize,
      centerYAxis = _ref6.centerYAxis,
      rotatable = _ref6.rotatable,
      _ref6$labelMargin = _ref6.labelMargin,
      labelMargin = _ref6$labelMargin === void 0 ? 0 : _ref6$labelMargin;
  var viewLabels = axisData.viewLabels,
      pointOnColumn = axisData.pointOnColumn,
      maxLabelWidth = axisData.maxLabelWidth,
      maxLabelHeight = axisData.maxLabelHeight;
  var offsetY = getAxisLabelAnchorPoint(maxLabelHeight) + labelMargin;
  var size = centerYAxis ? centerYAxis.xAxisHalfSize : axisSize;
  var distance = size / (viewLabels.length - (pointOnColumn ? 0 : 1));
  var rotationData = makeRotationData(maxLabelWidth, maxLabelHeight, distance, rotatable);
  var needRotateLabel = rotationData.needRotateLabel,
      rotationHeight = rotationData.rotationHeight;
  var maxHeight = (needRotateLabel ? rotationHeight : maxLabelHeight) + offsetY;
  return store_axes_objectSpread(store_axes_objectSpread(store_axes_objectSpread({}, axisData), rotationData), {}, {
    maxHeight: maxHeight,
    offsetY: offsetY
  });
}

function getAxisInfo(labelOnYAxis, plot) {
  var _getAxisName = getAxisName(labelOnYAxis),
      valueAxisName = _getAxisName.valueAxisName,
      labelAxisName = _getAxisName.labelAxisName;

  var _getSizeKey = getSizeKey(labelOnYAxis),
      valueSizeKey = _getSizeKey.valueSizeKey,
      labelSizeKey = _getSizeKey.labelSizeKey;

  var valueAxisSize = plot[valueSizeKey];
  var labelAxisSize = plot[labelSizeKey];
  return {
    valueAxisName: valueAxisName,
    valueAxisSize: valueAxisSize,
    labelAxisName: labelAxisName,
    labelAxisSize: labelAxisSize
  };
}

function getCategoriesWithTypes(categories, rawCategories) {
  var _ref7, _ref8;

  return {
    categories: (_ref7 = categories) !== null && _ref7 !== void 0 ? _ref7 : [],
    rawCategories: (_ref8 = rawCategories) !== null && _ref8 !== void 0 ? _ref8 : []
  };
}

var axes_axes = {
  name: 'axes',
  state: function state(_ref9) {
    var series = _ref9.series,
        options = _ref9.options;

    var _getYAxisOption2 = getYAxisOption(options),
        secondaryYAxis = _getYAxisOption2.secondaryYAxis;

    var axesState = {
      xAxis: {},
      yAxis: {}
    };

    if (isCenterYAxis(options, !!series.bar)) {
      axesState.centerYAxis = {};
    }

    if (series.radar) {
      axesState.radialAxis = {};
    }

    if (secondaryYAxis) {
      axesState.secondaryYAxis = {};
    }

    return {
      axes: axesState
    };
  },
  action: {
    setAxesData: function setAxesData(_ref10) {
      var _options$xAxis2, _options$xAxis2$label;

      var state = _ref10.state;
      var scale = state.scale,
          options = state.options,
          series = state.series,
          layout = state.layout,
          zoomRange = state.zoomRange,
          theme = state.theme;
      var xAxis = layout.xAxis,
          yAxis = layout.yAxis,
          plot = layout.plot;
      var labelOnYAxis = isLabelAxisOnYAxis(series, options);

      var _getCategoriesWithTyp = getCategoriesWithTypes(state.categories, state.rawCategories),
          categories = _getCategoriesWithTyp.categories,
          rawCategories = _getCategoriesWithTyp.rawCategories;

      var _getAxisInfo = getAxisInfo(labelOnYAxis, plot),
          valueAxisName = _getAxisInfo.valueAxisName,
          valueAxisSize = _getAxisInfo.valueAxisSize,
          labelAxisName = _getAxisInfo.labelAxisName,
          labelAxisSize = _getAxisInfo.labelAxisSize;

      var hasCenterYAxis = state.axes.centerYAxis;
      var isCoordinateTypeChart = isCoordinateSeries(series);
      var initialAxisData = getInitialAxisData(options, labelOnYAxis, categories, layout, isCoordinateTypeChart);
      var valueAxisData = getValueAxisData({
        scale: scale[valueAxisName],
        axisSize: valueAxisSize,
        options: options,
        series: series,
        theme: getAxisTheme(theme, valueAxisName),
        centerYAxis: hasCenterYAxis ? {
          xAxisHalfSize: (xAxis.width - yAxis.width) / 2
        } : null,
        initialAxisData: initialAxisData[valueAxisName],
        labelOnYAxis: labelOnYAxis,
        axisName: valueAxisName
      });
      var labelAxisData = getLabelAxisData({
        scale: scale[labelAxisName],
        axisSize: labelAxisSize,
        categories: categories,
        rawCategories: rawCategories,
        options: options,
        series: series,
        theme: getAxisTheme(theme, labelAxisName),
        zoomRange: zoomRange,
        initialAxisData: initialAxisData[labelAxisName],
        isCoordinateTypeChart: isCoordinateTypeChart,
        labelOnYAxis: labelOnYAxis,
        axisName: labelAxisName
      });
      var secondaryYAxis, centerYAxis, radialAxis;

      if (state.axes.secondaryYAxis) {
        secondaryYAxis = getSecondaryYAxisData({
          state: state,
          labelOnYAxis: labelOnYAxis,
          valueAxisSize: valueAxisSize,
          labelAxisSize: labelAxisSize,
          labelAxisName: labelAxisName,
          valueAxisName: valueAxisName,
          initialAxisData: initialAxisData.secondaryYAxis,
          isCoordinateTypeChart: isCoordinateTypeChart
        });
      }

      if (hasCenterYAxis) {
        var xAxisHalfSize = (xAxis.width - yAxis.width) / 2;
        centerYAxis = deepMergedCopy(valueAxisData, {
          x: xAxis.x + xAxisHalfSize,
          xAxisHalfSize: xAxisHalfSize,
          secondStartX: (xAxis.width + yAxis.width) / 2,
          yAxisLabelAnchorPoint: yAxis.width / 2,
          yAxisHeight: yAxis.height
        });
      }

      if (state.axes.radialAxis) {
        radialAxis = getRadialAxis(scale[valueAxisName], plot, getAxisTheme(theme, valueAxisName), initialAxisData.yAxis, options);
      }

      var axesState = {
        xAxis: makeXAxisData({
          axisData: labelOnYAxis ? valueAxisData : labelAxisData,
          axisSize: labelOnYAxis ? valueAxisSize : labelAxisSize,
          centerYAxis: centerYAxis,
          rotatable: getRotatableOption(options),
          labelMargin: (_options$xAxis2 = options.xAxis) === null || _options$xAxis2 === void 0 ? void 0 : (_options$xAxis2$label = _options$xAxis2.label) === null || _options$xAxis2$label === void 0 ? void 0 : _options$xAxis2$label.margin
        }),
        yAxis: labelOnYAxis ? labelAxisData : valueAxisData,
        secondaryYAxis: secondaryYAxis,
        centerYAxis: centerYAxis,
        radialAxis: radialAxis
      };

      if (hasAxesLayoutChanged(state.axes, axesState)) {
        this.notify(state, 'layout');
      }

      state.axes = axesState;
    }
  },
  computed: {},
  observe: {
    updateAxes: function updateAxes() {
      this.dispatch('setAxesData');
    }
  }
};
/* harmony default export */ var store_axes = (axes_axes);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.join.js
var es_array_join = __webpack_require__(91);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array-buffer.slice.js
var es_array_buffer_slice = __webpack_require__(174);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.freeze.js
var es_object_freeze = __webpack_require__(176);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.uint8-array.js
var es_typed_array_uint8_array = __webpack_require__(177);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.copy-within.js
var es_typed_array_copy_within = __webpack_require__(182);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.every.js
var es_typed_array_every = __webpack_require__(184);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.fill.js
var es_typed_array_fill = __webpack_require__(185);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.filter.js
var es_typed_array_filter = __webpack_require__(186);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.find.js
var es_typed_array_find = __webpack_require__(187);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.find-index.js
var es_typed_array_find_index = __webpack_require__(188);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.for-each.js
var es_typed_array_for_each = __webpack_require__(189);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.includes.js
var es_typed_array_includes = __webpack_require__(190);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.index-of.js
var es_typed_array_index_of = __webpack_require__(191);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.iterator.js
var es_typed_array_iterator = __webpack_require__(192);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.join.js
var es_typed_array_join = __webpack_require__(193);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.last-index-of.js
var es_typed_array_last_index_of = __webpack_require__(194);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.map.js
var es_typed_array_map = __webpack_require__(196);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reduce.js
var es_typed_array_reduce = __webpack_require__(197);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reduce-right.js
var es_typed_array_reduce_right = __webpack_require__(198);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reverse.js
var es_typed_array_reverse = __webpack_require__(199);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.set.js
var es_typed_array_set = __webpack_require__(200);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.slice.js
var es_typed_array_slice = __webpack_require__(201);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.some.js
var es_typed_array_some = __webpack_require__(202);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.sort.js
var es_typed_array_sort = __webpack_require__(203);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.subarray.js
var es_typed_array_subarray = __webpack_require__(204);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.to-locale-string.js
var es_typed_array_to_locale_string = __webpack_require__(205);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.to-string.js
var es_typed_array_to_string = __webpack_require__(206);

// CONCATENATED MODULE: ./src/helpers/downloader.ts

















































function _templateObject() {
  var data = _taggedTemplateLiteral(["<html xmlns:o=\"urn:schemas-microsoft-com:office:office\"\n        xmlns:x=\"urn:schemas-microsoft-com:office:excel\"\n        xmlns=\"http://www.w3.org/TR/REC-html40\">\n        <head>\n            <!--[if gte mso 9]>\n                <xml>\n                    <x:ExcelWorkbook>\n                        <x:ExcelWorksheets>\n                            <x:ExcelWorksheet>\n                                <x:Name>Ark1</x:Name>\n                                <x:WorksheetOptions>\n                                    <x:DisplayGridlines/>\n                                </x:WorksheetOptions>\n                            </x:ExcelWorksheet>\n                        </x:ExcelWorksheets>\n                        </x:ExcelWorkbook>\n                </xml>\n            <![endif]-->\n            <meta name=ProgId content=Excel.Sheet>\n            <meta charset=UTF-8>\n        </head>\n        <body>\n            ", "\n        </body>\n        </html>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function downloader_toConsumableArray(arr) { return downloader_arrayWithoutHoles(arr) || downloader_iterableToArray(arr) || downloader_unsupportedIterableToArray(arr) || downloader_nonIterableSpread(); }

function downloader_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function downloader_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return downloader_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return downloader_arrayLikeToArray(o, minLen); }

function downloader_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function downloader_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return downloader_arrayLikeToArray(arr); }

function downloader_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



var DATA_URI_HEADERS = {
  xls: 'data:application/vnd.ms-excel;base64,',
  csv: 'data:text/csv;charset=utf-8,%EF%BB%BF'
  /* BOM for utf-8 */

};

function getDownloadMethod() {
  var method;
  var isDownloadAttributeSupported = !isUndefined(document.createElement('a').download);
  var isMSSaveOrOpenBlobSupported = !isUndefined(window.Blob && window.navigator.msSaveOrOpenBlob);

  if (isMSSaveOrOpenBlobSupported) {
    method = downloadWithMSSaveOrOpenBlob;
  } else if (isDownloadAttributeSupported) {
    method = downloadWithAnchorElementDownloadAttribute;
  }

  return method;
}
/**
 * Base64 string to blob
 * original source ref: https://github.com/miguelmota/base64toblob/blob/master/base64toblob.js
 * Licence: MIT Licence
 */


function base64toBlob(base64String) {
  var contentType = base64String.substr(0, base64String.indexOf(';base64,')).substr(base64String.indexOf(':') + 1);
  var sliceSize = 1024;
  var byteCharacters = atob(base64String.substr(base64String.indexOf(',') + 1));
  var byteArrays = [];

  for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
    var slice = byteCharacters.slice(offset, offset + sliceSize);
    var byteNumbers = new Array(slice.length);

    for (var i = 0; i < slice.length; i += 1) {
      byteNumbers[i] = slice.charCodeAt(i);
    }

    byteArrays.push(new window.Uint8Array(byteNumbers));
  }

  try {
    // for IE 11
    return new Blob(byteArrays, {
      type: contentType
    });
  } catch (e) {
    // for IE 10
    return new Blob(byteArrays.map(function (byteArr) {
      return byteArr.buffer;
    }), {
      type: contentType
    });
  }
}

function isImageExtension(extension) {
  return extension === 'jpeg' || extension === 'png';
}

function downloadWithMSSaveOrOpenBlob(fileName, extension, content, contentType) {
  var blobObject = isImageExtension(extension) ? base64toBlob(content) : new Blob([content], {
    type: contentType
  });
  window.navigator.msSaveOrOpenBlob(blobObject, "".concat(fileName, ".").concat(extension));
}

function downloadWithAnchorElementDownloadAttribute(fileName, extension, content) {
  if (content) {
    var anchorElement = document.createElement('a');
    anchorElement.href = content;
    anchorElement.target = '_blank';
    anchorElement.download = "".concat(fileName, ".").concat(extension);
    document.body.appendChild(anchorElement);
    anchorElement.click();
    anchorElement.remove();
  }
}

function oneLineTrim() {
  var normalTag = function normalTag(template) {
    for (var _len = arguments.length, expressions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      expressions[_key - 1] = arguments[_key];
    }

    return template.reduce(function (accumulator, part, i) {
      return accumulator + expressions[i - 1] + part;
    });
  };

  return normalTag.apply(void 0, arguments).replace(/\n\s*/g, '');
}

function isNeedDataEncoding() {
  var isDownloadAttributeSupported = !isUndefined(document.createElement('a').download);
  var isMSSaveOrOpenBlobSupported = !isUndefined(window.Blob && window.navigator.msSaveOrOpenBlob);
  return !isMSSaveOrOpenBlobSupported && isDownloadAttributeSupported;
}

function getBulletLongestArrayLength(arr, field) {
  return arr.reduce(function (acc, cur, idx) {
    var _cur$field;

    return !idx || acc < (cur === null || cur === void 0 ? void 0 : (_cur$field = cur[field]) === null || _cur$field === void 0 ? void 0 : _cur$field.length) ? cur[field].length : acc;
  }, 0);
}

function makeBulletExportData(_ref) {
  var series = _ref.series;
  var seriesData = series.bullet.data;
  var markerCount = getBulletLongestArrayLength(seriesData, 'markers');
  var rangeCount = getBulletLongestArrayLength(seriesData, 'ranges');
  var rangesHeaders = utils_range(0, rangeCount).map(function (idx) {
    return "Range ".concat(idx + 1);
  });
  var markerHeaders = utils_range(0, markerCount).map(function (idx) {
    return "Marker ".concat(idx + 1);
  });
  return seriesData.reduce(function (acc, _ref2) {
    var data = _ref2.data,
        markers = _ref2.markers,
        name = _ref2.name,
        ranges = _ref2.ranges;
    var rangeDatum = rangesHeaders.map(function (_, index) {
      var rangeData = ranges === null || ranges === void 0 ? void 0 : ranges[index];
      return rangeData ? "".concat(rangeData[0], " ~ ").concat(rangeData[1]) : '';
    });
    var markerDatum = markerHeaders.map(function (_, index) {
      var _markers$index;

      return (_markers$index = markers === null || markers === void 0 ? void 0 : markers[index]) !== null && _markers$index !== void 0 ? _markers$index : '';
    });
    return [].concat(downloader_toConsumableArray(acc), [[name, data !== null && data !== void 0 ? data : ''].concat(downloader_toConsumableArray(rangeDatum), downloader_toConsumableArray(markerDatum))]);
  }, [['', 'Actual'].concat(downloader_toConsumableArray(rangesHeaders), downloader_toConsumableArray(markerHeaders))]);
}

function makeHeatmapExportData(_ref3) {
  var categories = _ref3.categories,
      series = _ref3.series;
  var xCategories = categories.x;
  return series.heatmap.data.reduce(function (acc, _ref4) {
    var data = _ref4.data,
        yCategory = _ref4.yCategory;
    return [].concat(downloader_toConsumableArray(acc), [[yCategory].concat(downloader_toConsumableArray(data.map(function (datum) {
      return isNull(datum) ? '' : datum;
    })))]);
  }, [[''].concat(downloader_toConsumableArray(xCategories))]);
}

function recursiveTreemapData(_ref5, result) {
  var label = _ref5.label,
      data = _ref5.data,
      _ref5$children = _ref5.children,
      children = _ref5$children === void 0 ? [] : _ref5$children;

  if (data) {
    result.push([label, data]);
  }

  children.forEach(function (childrenData) {
    return recursiveTreemapData(childrenData, result);
  });
  return result;
}

function makeTreemapExportData(exportData) {
  var series = exportData.series;
  var result = [['Label', 'Data']];
  series.treemap.data.forEach(function (datum) {
    recursiveTreemapData(datum, result);
  });
  return result;
}

function makeBubbleExportData(exportData) {
  var series = exportData.series;
  return series.bubble.data.reduce(function (acc, _ref6) {
    var name = _ref6.name,
        data = _ref6.data;
    return [].concat(downloader_toConsumableArray(acc), downloader_toConsumableArray(data.map(function (datum) {
      return isNull(datum) ? [] : [name, datum.label, String(datum.x), datum.y, datum.r];
    })));
  }, [['Name', 'Label', 'X', 'Y', 'Radius']]);
}

function makeBoxPlotExportData(exportData) {
  var _exportData$categorie;

  var series = exportData.series;
  var categories = (_exportData$categorie = exportData.categories) !== null && _exportData$categorie !== void 0 ? _exportData$categorie : [];
  return series.boxPlot.data.reduce(function (acc, _ref7) {
    var name = _ref7.name,
        data = _ref7.data,
        outliers = _ref7.outliers;
    var values = (data !== null && data !== void 0 ? data : []).map(function (rawData, index) {
      var _find;

      var outlierValue = (_find = (outliers !== null && outliers !== void 0 ? outliers : []).find(function (outlier) {
        return outlier[0] === index;
      })) === null || _find === void 0 ? void 0 : _find[1];
      var value = outlierValue ? [].concat(downloader_toConsumableArray(rawData), [outlierValue]) : downloader_toConsumableArray(rawData);
      return value.join();
    });
    return [].concat(downloader_toConsumableArray(acc), [[name].concat(downloader_toConsumableArray(values))]);
  }, [[''].concat(downloader_toConsumableArray(categories))]);
}

function makePieExportData(exportData) {
  var _exportData$categorie2;

  var series = exportData.series;
  var categories = (_exportData$categorie2 = exportData.categories) !== null && _exportData$categorie2 !== void 0 ? _exportData$categorie2 : [];
  return series.pie.data.reduce(function (acc, _ref8) {
    var name = _ref8.name,
        data = _ref8.data;
    var values = Array.isArray(data) ? (data !== null && data !== void 0 ? data : []).reduce(function (accNestedPieValue, value) {
      var _value$data;

      return [].concat(downloader_toConsumableArray(accNestedPieValue), [[value.name, (_value$data = value.data) !== null && _value$data !== void 0 ? _value$data : '']]);
    }, []) : [[name, data !== null && data !== void 0 ? data : '']];
    return [].concat(downloader_toConsumableArray(acc), downloader_toConsumableArray(values));
  }, categories.length ? [[''].concat(downloader_toConsumableArray(categories))] : []);
}

function makeCoordinateExportDataValues(type, categories, data) {
  return categories.map(function (category, index) {
    if (type === 'area' && Array.isArray(data[index])) {
      return data[index].join();
    }

    var foundItem = data.find(function (value) {
      return category === String(getCoordinateXValue(value));
    });
    return foundItem ? getCoordinateYValue(foundItem) : '';
  });
}

function makeExportData(exportData) {
  var series = exportData.series;
  var categories = exportData.categories;
  return Object.keys(series).reduce(function (acc, type) {
    var result = series[type].map(function (_ref9) {
      var name = _ref9.name,
          data = _ref9.data;
      var values = !isNumber(data[0]) && includes(['line', 'area', 'scatter'], type) ? makeCoordinateExportDataValues(type, categories, data) : data.map(function (value) {
        return Array.isArray(value) ? value.join() : value;
      });
      return [name].concat(downloader_toConsumableArray(values));
    });
    return [].concat(downloader_toConsumableArray(acc), downloader_toConsumableArray(result));
  }, [[''].concat(downloader_toConsumableArray(categories))]);
}

function get2DArrayFromRawData(exportData) {
  var result;
  var series = exportData.series;

  if (series.bullet) {
    result = makeBulletExportData(exportData);
  } else if (series.heatmap) {
    result = makeHeatmapExportData(exportData);
  } else if (series.bubble) {
    result = makeBubbleExportData(exportData);
  } else if (series.boxPlot) {
    result = makeBoxPlotExportData(exportData);
  } else if (series.pie) {
    result = makePieExportData(exportData);
  } else if (series.treemap) {
    result = makeTreemapExportData(exportData);
  } else {
    result = makeExportData(exportData);
  }

  return result;
}

function getTableElementStringForXLS(chartData2DArray) {
  var tableElementString = '<table>';
  chartData2DArray.forEach(function (row, rowIndex) {
    var cellTagName = rowIndex === 0 ? 'th' : 'td';
    tableElementString += '<tr>';
    row.forEach(function (cell, cellIndex) {
      var cellNumberClass = rowIndex !== 0 || cellIndex === 0 ? ' class="number"' : '';
      var cellString = "<".concat(cellTagName).concat(cellNumberClass, ">").concat(cell, "</").concat(cellTagName, ">");
      tableElementString += cellString;
    });
    tableElementString += '</tr>';
  });
  tableElementString += '</table>';
  return tableElementString;
}

function makeXLSBodyWithRawData(chartData2DArray) {
  return oneLineTrim(_templateObject(), getTableElementStringForXLS(chartData2DArray));
}

function makeCSVBodyWithRawData(chartData2DArray) {
  var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _option$lineDelimiter = option.lineDelimiter,
      lineDelimiter = _option$lineDelimiter === void 0 ? "\n" : _option$lineDelimiter,
      _option$itemDelimiter = option.itemDelimiter,
      itemDelimiter = _option$itemDelimiter === void 0 ? ',' : _option$itemDelimiter;
  var lastRowIndex = chartData2DArray.length - 1;
  var csvText = '';
  chartData2DArray.forEach(function (row, rowIndex) {
    var lastCellIndex = row.length - 1;
    row.forEach(function (cell, cellIndex) {
      var cellContent = isNumber(cell) ? cell : "\"".concat(cell, "\"");
      csvText += cellContent;

      if (cellIndex < lastCellIndex) {
        csvText += itemDelimiter;
      }
    });

    if (rowIndex < lastRowIndex) {
      csvText += lineDelimiter;
    }
  });
  return csvText;
}

function execDownload(fileName, extension, content, contentType) {
  var downloadMethod = getDownloadMethod();

  if (!isString(content) || !downloadMethod) {
    return;
  }

  downloadMethod(fileName, extension, content, contentType);
}
function downloadSpreadSheet(fileName, extension, data) {
  var chartData2DArray = get2DArrayFromRawData(data);
  var contentType = DATA_URI_HEADERS[extension].replace(/(data:|;base64,|,%EF%BB%BF)/g, '');
  var content = '';

  if (extension === 'csv') {
    content = makeCSVBodyWithRawData(chartData2DArray);
  } else {
    content = makeXLSBodyWithRawData(chartData2DArray);
  }

  if (isNeedDataEncoding()) {
    if (extension !== 'csv') {
      // base64 encoding for data URI scheme.
      content = window.btoa(unescape(encodeURIComponent(content)));
    }

    content = DATA_URI_HEADERS[extension] + content;
  }

  execDownload(fileName, extension, content, contentType);
}
// CONCATENATED MODULE: ./src/component/exportMenu.ts

















function exportMenu_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { exportMenu_typeof = function _typeof(obj) { return typeof obj; }; } else { exportMenu_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return exportMenu_typeof(obj); }

function exportMenu_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function exportMenu_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function exportMenu_createClass(Constructor, protoProps, staticProps) { if (protoProps) exportMenu_defineProperties(Constructor.prototype, protoProps); if (staticProps) exportMenu_defineProperties(Constructor, staticProps); return Constructor; }

function exportMenu_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) exportMenu_setPrototypeOf(subClass, superClass); }

function exportMenu_setPrototypeOf(o, p) { exportMenu_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return exportMenu_setPrototypeOf(o, p); }

function exportMenu_createSuper(Derived) { var hasNativeReflectConstruct = exportMenu_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = exportMenu_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = exportMenu_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return exportMenu_possibleConstructorReturn(this, result); }; }

function exportMenu_possibleConstructorReturn(self, call) { if (call && (exportMenu_typeof(call) === "object" || typeof call === "function")) { return call; } return exportMenu_assertThisInitialized(self); }

function exportMenu_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function exportMenu_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function exportMenu_getPrototypeOf(o) { exportMenu_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return exportMenu_getPrototypeOf(o); }

function exportMenu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var EXPORT_MENU_WIDTH = 140;
var BUTTON_RECT_SIZE = 24;

var exportMenu_ExportMenu = /*#__PURE__*/function (_Component) {
  exportMenu_inherits(ExportMenu, _Component);

  var _super = exportMenu_createSuper(ExportMenu);

  function ExportMenu() {
    var _this;

    exportMenu_classCallCheck(this, ExportMenu);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "responders", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "models", {
      exportMenuButton: []
    });

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "opened", false);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "fileName", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "data", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "chartEl", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "exportMenuEl", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "theme", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "chartBackgroundColor", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "toggleExportMenu", function () {
      _this.opened = !_this.opened;
      _this.models.exportMenuButton[0].opened = _this.opened;

      _this.eventBus.emit('needDraw');

      if (_this.opened) {
        _this.chartEl.appendChild(_this.exportMenuEl);
      } else {
        _this.chartEl.removeChild(_this.exportMenuEl);
      }
    });

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "getCanvasExportBtnRemoved", function () {
      var canvas = _this.chartEl.getElementsByTagName('canvas')[0];

      var ctx = canvas.getContext('2d');
      var _this$rect = _this.rect,
          x = _this$rect.x,
          y = _this$rect.y,
          h = _this$rect.height,
          w = _this$rect.width;
      ['#fff', _this.chartBackgroundColor].forEach(function (color) {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, w, h);
      });
      return canvas;
    });

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "onClickExportButton", function (ev) {
      var id = ev.target.id;

      if (id === 'png' || id === 'jpeg') {
        var canvas = _this.getCanvasExportBtnRemoved();

        execDownload(_this.fileName, id, canvas.toDataURL("image/".concat(id), 1));
      } else {
        downloadSpreadSheet(_this.fileName, id, _this.data);
      }

      _this.toggleExportMenu();
    });

    return _this;
  }

  exportMenu_createClass(ExportMenu, [{
    key: "applyExportButtonPanelStyle",
    value: function applyExportButtonPanelStyle(chartWidth) {
      var exportMenu = this.exportMenuEl.querySelector('.toastui-chart-export-menu');
      var exportMenuTitle = this.exportMenuEl.querySelector('.toastui-chart-export-menu-title');
      var menuBtnWrapper = this.exportMenuEl.querySelector('.toastui-chart-export-menu-btn-wrapper');
      exportMenu.setAttribute('style', this.makePanelWrapperStyle(chartWidth));
      exportMenuTitle.setAttribute('style', this.makePanelStyle('header'));
      menuBtnWrapper.setAttribute('style', this.makePanelStyle('body'));
    }
  }, {
    key: "makeExportMenuButton",
    value: function makeExportMenuButton() {
      var el = document.createElement('div');
      el.onclick = this.onClickExportButton;
      el.innerHTML = "\n        <div class=\"toastui-chart-export-menu\">\n          <p class=\"toastui-chart-export-menu-title\">Export to</p>\n          <div class=\"toastui-chart-export-menu-btn-wrapper\">\n            <button class=\"toastui-chart-export-menu-btn\" id=\"xls\">xls</button>\n            <button class=\"toastui-chart-export-menu-btn\" id=\"csv\">csv</button>\n            <button class=\"toastui-chart-export-menu-btn\" id=\"png\">png</button>\n            <button class=\"toastui-chart-export-menu-btn\" id=\"jpeg\">jpeg</button>\n          </div>\n        </div>\n      ";
      return el;
    }
  }, {
    key: "initialize",
    value: function initialize(_ref) {
      var chartEl = _ref.chartEl;
      this.chartEl = chartEl;
      this.type = 'exportMenu';
      this.name = 'exportMenu';
      this.exportMenuEl = this.makeExportMenuButton();
    }
  }, {
    key: "onClick",
    value: function onClick(_ref2) {
      var responders = _ref2.responders;

      if (responders.length) {
        this.toggleExportMenu();
      }
    }
  }, {
    key: "getFileName",
    value: function getFileName(title) {
      var _title$text;

      return isString(title) ? title : (_title$text = title === null || title === void 0 ? void 0 : title.text) !== null && _title$text !== void 0 ? _title$text : 'toast-ui-chart';
    }
  }, {
    key: "render",
    value: function render(_ref3) {
      var _options$exportMenu;

      var options = _ref3.options,
          layout = _ref3.layout,
          chart = _ref3.chart,
          series = _ref3.series,
          rawCategories = _ref3.rawCategories,
          theme = _ref3.theme;
      this.isShow = isExportMenuVisible(options);

      if (!this.isShow) {
        return;
      }

      this.chartBackgroundColor = theme.chart.backgroundColor;
      this.theme = theme.exportMenu;
      this.data = {
        series: series,
        categories: rawCategories
      };
      this.fileName = this.getFileName((options === null || options === void 0 ? void 0 : (_options$exportMenu = options.exportMenu) === null || _options$exportMenu === void 0 ? void 0 : _options$exportMenu.filename) || chart.title);
      this.applyExportButtonPanelStyle(chart.width);
      this.rect = layout.exportMenu;
      this.models.exportMenuButton = [{
        type: 'exportMenuButton',
        x: 0,
        y: 0,
        opened: this.opened,
        theme: this.theme.button
      }];
      this.responders = [{
        type: 'rect',
        width: BUTTON_RECT_SIZE,
        height: BUTTON_RECT_SIZE,
        x: 0,
        y: 0
      }];
    }
  }, {
    key: "makePanelWrapperStyle",
    value: function makePanelWrapperStyle(chartWidth) {
      var _this$chartEl$getBoun = this.chartEl.getBoundingClientRect(),
          top = _this$chartEl$getBoun.top,
          left = _this$chartEl$getBoun.left;

      var topPosition = top + layout_padding.Y + BUTTON_RECT_SIZE + 5;
      var leftPosition = left + chartWidth - EXPORT_MENU_WIDTH - layout_padding.X;
      var _this$theme$panel = this.theme.panel,
          borderRadius = _this$theme$panel.borderRadius,
          borderWidth = _this$theme$panel.borderWidth,
          borderColor = _this$theme$panel.borderColor;
      return "top: ".concat(topPosition, "px; left: ").concat(leftPosition, "px; border: ").concat(borderWidth, "px solid ").concat(borderColor, "; border-radius: ").concat(borderRadius, "px;");
    }
  }, {
    key: "makePanelStyle",
    value: function makePanelStyle(type) {
      var sectionTheme = this.theme.panel[type];
      var direction = type === 'header' ? 'top' : 'bottom';
      var _ref4 = this.theme.panel,
          borderRadius = _ref4.borderRadius,
          borderWidth = _ref4.borderWidth;
      var borderRadiusPx = "".concat(borderRadius - borderWidth, "px");
      return ["".concat(getFontStyleString(sectionTheme)), "border-".concat(direction, "-left-radius: ").concat(borderRadiusPx, ";"), "border-".concat(direction, "-right-radius: ").concat(borderRadiusPx, ";"), "background-color: ".concat(sectionTheme.backgroundColor, ";")].join('');
    }
  }]);

  return ExportMenu;
}(component_Component);


// CONCATENATED MODULE: ./src/brushes/dataLabel.ts








function dataLabel_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function dataLabel_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { dataLabel_ownKeys(Object(source), true).forEach(function (key) { dataLabel_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { dataLabel_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function dataLabel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






function dataLabel_dataLabel(ctx, model) {
  var x = model.x,
      y = model.y,
      text = model.text,
      textAlign = model.textAlign,
      textBaseline = model.textBaseline,
      opacity = model.opacity,
      callout = model.callout,
      theme = model.theme;
  var color = theme.color,
      textBubble = theme.textBubble;
  var font = getFont(theme);
  var textStyle = {
    textAlign: textAlign,
    textBaseline: textBaseline,
    font: font,
    fillStyle: color
  };
  var textStrokeStyle = getTextStrokeStyle(theme);

  if (callout) {
    var _callout$theme = callout.theme,
        lineWidth = _callout$theme.lineWidth,
        lineColor = _callout$theme.lineColor;
    basic_line(ctx, dataLabel_objectSpread(dataLabel_objectSpread({
      type: 'line'
    }, pick(callout, 'x', 'y', 'x2', 'y2')), {}, {
      strokeStyle: lineColor,
      lineWidth: lineWidth
    }));
  }

  if (textBubble === null || textBubble === void 0 ? void 0 : textBubble.visible) {
    drawBubbleLabel(ctx, model);
    return;
  }

  label_label(ctx, {
    type: 'label',
    x: x,
    y: y,
    text: text,
    style: [textStyle],
    stroke: [textStrokeStyle],
    opacity: opacity
  });
}
function drawBubbleLabel(ctx, model) {
  var text = model.text,
      theme = model.theme;
  var _ref = theme,
      color = _ref.color,
      textStrokeColor = _ref.textStrokeColor;
  var font = getFont(theme);
  var textStyle = {
    textAlign: 'center',
    textBaseline: 'middle',
    font: font,
    fillStyle: color
  };
  var textStrokeStyle = {};

  if (textStrokeColor) {
    textStrokeStyle = {
      strokeStyle: textStrokeColor
    };
  }

  bubbleLabel(ctx, dataLabel_objectSpread(dataLabel_objectSpread({}, getBubbleRect(model)), {}, {
    labelStyle: [textStyle],
    labelStrokeStyle: [textStrokeStyle],
    text: text
  }));
}
function getBubbleArrowPoints(direction, _ref2, arrowPointTheme) {
  var x = _ref2.x,
      y = _ref2.y;
  var width = arrowPointTheme.width;
  var height = arrowPointTheme.height;
  var points = [];

  if (direction === 'top') {
    points = [{
      x: x - width / 2,
      y: y + height
    }, {
      x: x,
      y: y
    }, {
      x: x + width / 2,
      y: y + height
    }];
  } else if (direction === 'bottom') {
    points = [{
      x: x + width / 2,
      y: y - height
    }, {
      x: x,
      y: y
    }, {
      x: x - width / 2,
      y: y - height
    }];
  } else if (direction === 'right') {
    points = [{
      x: x - height,
      y: y - width / 2
    }, {
      x: x,
      y: y
    }, {
      x: x - height,
      y: y + width / 2
    }];
  } else if (direction === 'left') {
    points = [{
      x: x + height,
      y: y + width / 2
    }, {
      x: x,
      y: y
    }, {
      x: x + height,
      y: y - width / 2
    }];
  }

  return points;
}

function getBubbleRect(model) {
  var text = model.text,
      theme = model.theme,
      textAlign = model.textAlign,
      textBaseline = model.textBaseline;
  var font = getFont(theme);
  var _ref3 = theme.textBubble,
      arrow = _ref3.arrow,
      paddingX = _ref3.paddingX,
      paddingY = _ref3.paddingY,
      borderRadius = _ref3.borderRadius,
      borderColor = _ref3.borderColor,
      borderWidth = _ref3.borderWidth,
      backgroundColor = _ref3.backgroundColor,
      shadowBlur = _ref3.shadowBlur,
      shadowOffsetX = _ref3.shadowOffsetX,
      shadowOffsetY = _ref3.shadowOffsetY,
      shadowColor = _ref3.shadowColor;
  var labelWidth = getTextWidth(text, font);
  var width = labelWidth + paddingX * 2;
  var height = getTextHeight(text, font) + paddingY * 2;
  var x = model.x,
      y = model.y;

  if (textAlign === 'center') {
    x -= width / 2;
  } else if (textAlign === 'right') {
    x -= width;
  }

  if (textBaseline === 'middle') {
    y -= height / 2;
  } else if (textBaseline === 'bottom') {
    y -= height;
  }

  var rect = {
    x: x,
    y: y,
    width: width,
    height: height
  };
  return dataLabel_objectSpread(dataLabel_objectSpread({}, rect), {}, {
    radius: borderRadius,
    fill: backgroundColor,
    lineWidth: borderWidth,
    stroke: borderColor,
    bubbleStyle: [{
      shadowBlur: shadowBlur,
      shadowOffsetX: shadowOffsetX,
      shadowOffsetY: shadowOffsetY,
      shadowColor: shadowColor
    }]
  }, getArrowInfo(rect, textAlign, textBaseline, arrow));
}

function getArrowInfo(rect, textAlign, textBaseline, theme) {
  var _theme$direction;

  if (!(theme === null || theme === void 0 ? void 0 : theme.visible)) {
    return null;
  }

  var arrowHeight = theme.height;
  var width = rect.width,
      height = rect.height;
  var direction = (_theme$direction = theme.direction) !== null && _theme$direction !== void 0 ? _theme$direction : getArrowDirection(textAlign, textBaseline);
  var boxX = rect.x,
      boxY = rect.y;
  var pointX = rect.x,
      pointY = rect.y;

  if (direction === 'top') {
    boxY += arrowHeight;
  } else if (direction === 'bottom') {
    boxY -= arrowHeight;
    pointY += height;
  } else if (direction === 'right') {
    boxX -= arrowHeight;
    pointX += width;
  } else if (direction === 'left') {
    boxX += arrowHeight;
  }

  if (textAlign === 'center') {
    pointX = rect.x + width / 2;
  } else if (textBaseline === 'middle') {
    pointY = rect.y + height / 2;
  }

  return {
    direction: direction,
    points: getBubbleArrowPoints(direction, {
      x: pointX,
      y: pointY
    }, theme),
    x: boxX,
    y: boxY
  };
}

function getArrowDirection(textAlign, textBaseline) {
  var direction = 'top';

  if (textAlign === 'center' && textBaseline === 'top') {
    direction = 'top';
  } else if (textAlign === 'center' && textBaseline === 'bottom') {
    direction = 'bottom';
  } else if (textBaseline === 'middle' && textAlign === 'right') {
    direction = 'right';
  } else if (textBaseline === 'middle' && textAlign === 'left') {
    direction = 'left';
  }

  return direction;
}

function getTextStrokeStyle(theme) {
  var textStrokeColor = theme.textStrokeColor;
  var textStrokeStyle = pick(theme, 'lineWidth', 'shadowColor', 'shadowBlur');

  if (textStrokeColor) {
    textStrokeStyle.strokeStyle = textStrokeColor;
  }

  return textStrokeStyle;
}
// CONCATENATED MODULE: ./src/brushes/spectrumLegend.ts








function spectrumLegend_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function spectrumLegend_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { spectrumLegend_ownKeys(Object(source), true).forEach(function (key) { spectrumLegend_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { spectrumLegend_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function spectrumLegend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var SPECTRUM_LEGEND_LABEL_HEIGHT = 12;
var spectrumLegendBar = {
  HEIGHT: 6,
  PADDING: 5
};
var spectrumLegendTooltip = {
  HEIGHT: 28,
  POINT_WIDTH: 8,
  POINT_HEIGHT: 6,
  PADDING: 6
};

function getBarStartPoint(model) {
  var align = model.align,
      modelX = model.x,
      modelY = model.y,
      labels = model.labels,
      width = model.width;
  var PADDING = spectrumLegendBar.PADDING;
  var x, y;

  if (align === 'top') {
    x = modelX;
    y = modelY + SPECTRUM_LEGEND_LABEL_HEIGHT + PADDING;
  } else if (align === 'bottom') {
    x = modelX;
    y = modelY + spectrumLegendTooltip.HEIGHT;
  } else if (align === 'left') {
    x = modelX + getMaxLengthLabelWidth(labels) + PADDING;
    y = modelY + SPECTRUM_LEGEND_LABEL_HEIGHT / 2;
  } else {
    x = modelX + width - (getMaxLengthLabelWidth(labels) + layout_padding.X + PADDING * 2 + spectrumLegendBar.HEIGHT);
    y = modelY + SPECTRUM_LEGEND_LABEL_HEIGHT / 2;
  }

  return {
    x: x,
    y: y
  };
}

function getLabelsStartPoint(model) {
  var align = model.align,
      modelX = model.x,
      modelY = model.y,
      labels = model.labels,
      width = model.width;
  var x, y;

  if (align === 'top') {
    x = modelX;
    y = modelY;
  } else if (align === 'bottom') {
    x = modelX;
    y = modelY + spectrumLegendTooltip.HEIGHT + spectrumLegendBar.HEIGHT + spectrumLegendBar.PADDING;
  } else if (align === 'left') {
    x = modelX + getMaxLengthLabelWidth(labels);
    y = modelY;
  } else {
    x = modelX + width - getMaxLengthLabelWidth(labels) - layout_padding.X;
    y = modelY;
  }

  return {
    x: x,
    y: y
  };
}

function getBarSize(width, height, verticalAlign) {
  var HEIGHT = spectrumLegendBar.HEIGHT;
  var barWidth = verticalAlign ? width : HEIGHT;
  var barHeight = verticalAlign ? HEIGHT : height - SPECTRUM_LEGEND_LABEL_HEIGHT;
  return {
    barWidth: barWidth,
    barHeight: barHeight
  };
}

function drawLabels(ctx, model) {
  var labels = model.labels,
      align = model.align,
      x = model.x,
      y = model.y,
      width = model.width,
      height = model.height,
      verticalAlign = model.verticalAlign;

  var _getBarSize = getBarSize(width, height, verticalAlign),
      barWidth = _getBarSize.barWidth,
      barHeight = _getBarSize.barHeight;

  var labelSize = labels.length - 1;
  var textBaseStyleMap = {
    left: {
      textAlign: 'right',
      textBaseline: 'top'
    },
    right: {
      textAlign: 'left',
      textBaseline: 'top'
    },
    top: {
      textAlign: 'center',
      textBaseline: 'top'
    },
    bottom: {
      textAlign: 'center',
      textBaseline: 'top'
    }
  };
  labels.forEach(function (text, idx) {
    var startX = verticalAlign ? x + barWidth / labelSize * idx : x;
    var startY = verticalAlign ? y : y + barHeight / labelSize * idx;
    label_label(ctx, {
      type: 'label',
      x: startX,
      y: startY,
      text: text,
      style: ['default', textBaseStyleMap[align]]
    });
  });
}

function drawBar(ctx, model) {
  var width = model.width,
      height = model.height,
      startColor = model.startColor,
      endColor = model.endColor,
      x = model.x,
      y = model.y,
      verticalAlign = model.verticalAlign;

  var _getBarSize2 = getBarSize(width, height, verticalAlign),
      barWidth = _getBarSize2.barWidth,
      barHeight = _getBarSize2.barHeight;

  var gradient = verticalAlign ? ctx.createLinearGradient(x, y, x + barWidth, y) : ctx.createLinearGradient(x, y, x, y + barHeight);
  gradient.addColorStop(0, startColor);
  gradient.addColorStop(1, endColor);
  ctx.fillStyle = gradient;
  ctx.fillRect(x, y, barWidth, barHeight);
}

function getTooltipArrowPoint(model) {
  var align = model.align,
      colorRatio = model.colorRatio,
      width = model.width,
      height = model.height,
      x = model.x,
      y = model.y,
      labels = model.labels,
      verticalAlign = model.verticalAlign;

  var _getBarSize3 = getBarSize(width, height, verticalAlign),
      barWidth = _getBarSize3.barWidth,
      barHeight = _getBarSize3.barHeight;

  var PADDING = spectrumLegendBar.PADDING,
      HEIGHT = spectrumLegendBar.HEIGHT;

  if (align === 'top') {
    return {
      x: x + barWidth * colorRatio,
      y: y + SPECTRUM_LEGEND_LABEL_HEIGHT + HEIGHT + PADDING * 2
    };
  }

  if (align === 'bottom') {
    return {
      x: x + barWidth * colorRatio,
      y: y + SPECTRUM_LEGEND_LABEL_HEIGHT + PADDING * 2
    };
  }

  if (align === 'left') {
    return {
      x: x + getMaxLengthLabelWidth(labels) + HEIGHT + PADDING * 2,
      y: y + barHeight * colorRatio + PADDING
    };
  }

  if (align === 'right') {
    return {
      x: x + width - (getMaxLengthLabelWidth(labels) + layout_padding.X + PADDING * 3 + HEIGHT),
      y: y + barHeight * colorRatio + PADDING
    };
  }
}

function spectrumLegend(ctx, model) {
  var labelsStartPoint = getLabelsStartPoint(model);
  var barStartPoint = getBarStartPoint(model);
  drawLabels(ctx, spectrumLegend_objectSpread(spectrumLegend_objectSpread({}, model), labelsStartPoint));
  drawBar(ctx, spectrumLegend_objectSpread(spectrumLegend_objectSpread({}, model), barStartPoint));
}
function spectrumTooltip(ctx, model) {
  var _ref = getTooltipArrowPoint(model),
      x = _ref.x,
      y = _ref.y;

  var PADDING = spectrumLegendTooltip.PADDING,
      POINT_HEIGHT = spectrumLegendTooltip.POINT_HEIGHT,
      POINT_WIDTH = spectrumLegendTooltip.POINT_WIDTH;
  var align = model.align,
      text = model.text,
      color = model.color;
  var labelWidth = getTextWidth(text);
  var width = labelWidth + PADDING * 2;
  var height = SPECTRUM_LEGEND_LABEL_HEIGHT + PADDING * 2;
  var direction = align;
  var boxStartX = x;
  var boxStartY = y;

  if (align === 'top') {
    boxStartY += POINT_HEIGHT;
  } else if (align === 'right') {
    boxStartX -= width / 2 + POINT_HEIGHT;
    boxStartY -= height / 2;
  } else if (align === 'left') {
    boxStartX += width / 2 + POINT_HEIGHT;
    boxStartY -= height / 2;
  } else if (align === 'bottom') {
    boxStartY -= height + POINT_HEIGHT;
  }

  var points = getBubbleArrowPoints(align, {
    x: x,
    y: y
  }, {
    visible: true,
    width: POINT_WIDTH,
    height: POINT_HEIGHT
  });
  bubbleLabel(ctx, {
    x: boxStartX - width / 2,
    y: boxStartY,
    width: width,
    height: height,
    text: text,
    labelStyle: ['default', {
      textAlign: 'center'
    }],
    points: points,
    direction: direction,
    fill: color
  });
}
// CONCATENATED MODULE: ./src/brushes/polygon.ts



function polygon(ctx, polygonModel) {
  var strokeStyle = polygonModel.color,
      points = polygonModel.points,
      lineWidth = polygonModel.lineWidth,
      fillColor = polygonModel.fillColor,
      _polygonModel$dashSeg = polygonModel.dashSegments,
      dashSegments = _polygonModel$dashSeg === void 0 ? [] : _polygonModel$dashSeg;
  ctx.beginPath();

  if (dashSegments) {
    setLineDash(ctx, dashSegments);
  }

  points.forEach(function (_ref, idx) {
    var x = _ref.x,
        y = _ref.y;

    if (idx === 0) {
      ctx.moveTo(x, y);
      return;
    }

    ctx.lineTo(x, y);
  });
  ctx.lineTo(points[0].x, points[0].y);

  if (fillColor) {
    style_fillStyle(ctx, fillColor);
  }

  strokeWithOptions(ctx, {
    lineWidth: lineWidth,
    strokeStyle: strokeStyle
  });
  ctx.closePath();
}
// CONCATENATED MODULE: ./src/brushes/scatterSeries.ts










function scatterSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function scatterSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { scatterSeries_ownKeys(Object(source), true).forEach(function (key) { scatterSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { scatterSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function scatterSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





function regularPolygon(ctx, model) {
  var numberOfSides = model.numberOfSides,
      size = model.size,
      x = model.x,
      y = model.y,
      borderColor = model.borderColor,
      borderWidth = model.borderWidth,
      fillColor = model.fillColor;
  var s = size / 2;
  var shift = numberOfSides % 2 ? Math.PI / 180.0 * (10 + (numberOfSides - 3) / 2) * numberOfSides : 0;
  var step = 2 * Math.PI / numberOfSides;
  ctx.beginPath();

  for (var i = 0; i <= numberOfSides; i += 1) {
    var curStep = i * step + shift;
    ctx.lineTo(x + s * Math.cos(curStep), y + s * Math.sin(curStep));
  }

  ctx.strokeStyle = borderColor;
  ctx.lineWidth = borderWidth;
  style_fillStyle(ctx, fillColor);
  ctx.stroke();
  ctx.closePath();
} // https://programmingthomas.wordpress.com/2012/05/16/drawing-stars-with-html5-canvas/


function star(ctx, model) {
  var x = model.x,
      y = model.y,
      borderColor = model.borderColor,
      borderWidth = model.borderWidth,
      size = model.size,
      fillColor = model.fillColor;
  ctx.lineWidth = borderWidth;
  ctx.strokeStyle = borderColor;
  ctx.fillStyle = fillColor;
  ctx.save();
  ctx.beginPath();
  ctx.translate(x, y);
  ctx.moveTo(0, -size);

  for (var i = 0; i < 5; i += 1) {
    ctx.rotate(Math.PI / 5);
    ctx.lineTo(0, -size / 2);
    ctx.rotate(Math.PI / 5);
    ctx.lineTo(0, -size);
  }

  ctx.fill();
  ctx.stroke();
  ctx.restore();
  ctx.closePath();
}

function cross(ctx, model) {
  var x = model.x,
      y = model.y,
      borderColor = model.borderColor,
      borderWidth = model.borderWidth,
      size = model.size,
      fillColor = model.fillColor;
  var quarter = size / 4;
  var half = size / 2;
  var xPointsOffset = [-half, -half, -quarter, -quarter, quarter, quarter, half, half, quarter, quarter, -quarter, -quarter];
  var yPointsOffset = [];

  for (var idx = 0, len = xPointsOffset.length; idx < len; idx += 1) {
    var startIdx = 9;
    yPointsOffset.push(xPointsOffset[(startIdx + idx) % len]);
  }

  polygon(ctx, {
    type: 'polygon',
    lineWidth: borderWidth,
    color: borderColor,
    points: xPointsOffset.map(function (val, idx) {
      return {
        x: x + val,
        y: y + yPointsOffset[idx]
      };
    }),
    fillColor: fillColor
  });
}

function getNumberOfSidesByIconType(iconType) {
  switch (iconType) {
    case 'triangle':
      return 3;

    case 'diamond':
      return 4;

    case 'pentagon':
      return 5;

    case 'hexagon':
      return 6;
  }
}

function scatterSeries_scatterSeries(ctx, model) {
  var x = model.x,
      y = model.y,
      borderColor = model.borderColor,
      borderWidth = model.borderWidth,
      fillColor = model.fillColor,
      iconType = model.iconType,
      size = model.size;
  var commonModel = {
    x: x,
    y: y,
    fillColor: fillColor,
    borderColor: borderColor,
    borderWidth: borderWidth,
    size: size
  };
  ctx.beginPath();

  switch (iconType) {
    case 'rect':
      pathRect(ctx, {
        type: 'pathRect',
        x: x - size / 2,
        y: y - size / 2,
        width: size,
        height: size,
        stroke: borderColor,
        lineWidth: borderWidth,
        fill: fillColor
      });
      break;

    case 'triangle':
    case 'pentagon':
    case 'diamond':
    case 'hexagon':
      regularPolygon(ctx, scatterSeries_objectSpread({
        type: 'regularPolygon',
        numberOfSides: getNumberOfSidesByIconType(iconType)
      }, commonModel));
      break;

    case 'star':
      star(ctx, scatterSeries_objectSpread(scatterSeries_objectSpread({
        type: 'star'
      }, commonModel), {}, {
        size: size / 2
      }));
      break;

    case 'cross':
      cross(ctx, scatterSeries_objectSpread({
        type: 'cross'
      }, commonModel));
      break;

    default:
      basic_circle(ctx, {
        type: 'circle',
        x: x,
        y: y,
        radius: size / 2,
        style: [{
          strokeStyle: borderColor,
          lineWidth: borderWidth
        }],
        color: fillColor
      });
  }

  ctx.stroke();
  ctx.closePath();
}
// CONCATENATED MODULE: ./src/brushes/legend.ts








var LEGEND_ITEM_MARGIN_X = 40;
var LEGEND_MARGIN_X = 5;
var LEGEND_MARGIN_Y = 13;
var LEGEND_CHECKBOX_SIZE = 12;
var LEGEND_ICON_SIZE = 12;
var ICON_BORDER_WIDTH = 1.5;
var INACTIVE_OPACITY = 0.3;
var RECT_SIZE = 10;
var LINE_ICON_PADDING = 2;
var CIRCLE_ICON_RADIUS = 6;
function getLegendItemHeight(fontSize) {
  return fontSize + LEGEND_MARGIN_Y;
}

function drawLineIcon(ctx, x, y, color) {
  var xCurveOffset = [2, 2, 6, 6, 10, 10];
  var yCurveOffset = [8, 0, 0, 8, 8, 0];
  xCurveOffset.forEach(function (xOffset, idx) {
    if (idx === 5) {
      return;
    }

    basic_line(ctx, {
      type: 'line',
      x: x + xOffset,
      y: y + yCurveOffset[idx],
      x2: x + xCurveOffset[idx + 1],
      y2: y + yCurveOffset[idx + 1],
      lineWidth: 2,
      strokeStyle: color
    });
  });
}

function drawCheckIcon(ctx, x, y, active) {
  var color = '#555555';
  var strokeStyle = active ? color : getRGBA(color, INACTIVE_OPACITY);
  basic_line(ctx, {
    type: 'line',
    x: x + 2,
    y: y + 5,
    x2: x + 5,
    y2: y + 8,
    strokeStyle: strokeStyle,
    lineWidth: 2
  });
  basic_line(ctx, {
    type: 'line',
    x: x + 5,
    y: y + 9,
    x2: x + 10,
    y2: y + 3,
    strokeStyle: strokeStyle,
    lineWidth: 2
  });
}

function drawCheckbox(ctx, x, y, renderOptions) {
  var active = renderOptions.active,
      checked = renderOptions.checked;
  var borderColor = active ? '#bbb' : getRGBA('#bbbbbb', INACTIVE_OPACITY);
  basic_rect(ctx, {
    type: 'rect',
    x: x,
    y: y,
    width: LEGEND_CHECKBOX_SIZE,
    height: LEGEND_CHECKBOX_SIZE,
    color: '#fff',
    borderColor: borderColor,
    thickness: 1
  });

  if (checked) {
    drawCheckIcon(ctx, x, y, active);
  }
}

function drawIcon(ctx, x, y, renderOptions) {
  var iconType = renderOptions.iconType,
      active = renderOptions.active,
      color = renderOptions.color,
      showCheckbox = renderOptions.showCheckbox;
  var iconX = x + (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0);
  var iconColor = active ? color : getRGBA(color, INACTIVE_OPACITY);

  if (iconType === 'rect') {
    basic_rect(ctx, {
      type: 'rect',
      x: iconX,
      y: y + (LEGEND_CHECKBOX_SIZE - RECT_SIZE) / 2,
      width: RECT_SIZE,
      height: RECT_SIZE,
      color: iconColor
    });
  } else if (iconType === 'line') {
    drawLineIcon(ctx, iconX, y + LINE_ICON_PADDING, iconColor);
  } else if (iconType === 'circle') {
    basic_circle(ctx, {
      type: 'circle',
      x: iconX + CIRCLE_ICON_RADIUS,
      y: y + CIRCLE_ICON_RADIUS,
      radius: CIRCLE_ICON_RADIUS,
      color: iconColor,
      style: ['default']
    });
  }
}

function drawScatterIcon(ctx, x, y, renderOptions) {
  var iconType = renderOptions.iconType,
      active = renderOptions.active,
      color = renderOptions.color,
      showCheckbox = renderOptions.showCheckbox;
  var iconX = x + (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0);
  var iconColor = active ? color : getRGBA(color, INACTIVE_OPACITY);
  scatterSeries_scatterSeries(ctx, {
    type: 'scatterSeries',
    iconType: iconType,
    x: iconX + CIRCLE_ICON_RADIUS,
    y: y + CIRCLE_ICON_RADIUS,
    borderColor: iconColor,
    size: CIRCLE_ICON_RADIUS * 2,
    fillColor: 'rgba(255, 255, 255, 0)',
    borderWidth: ICON_BORDER_WIDTH
  });
}

function drawLabel(ctx, x, y, text, renderOptions) {
  var active = renderOptions.active,
      showCheckbox = renderOptions.showCheckbox,
      font = renderOptions.font,
      fontColor = renderOptions.fontColor;
  var fillStyle = active ? fontColor : getRGBA(fontColor, INACTIVE_OPACITY);
  label_label(ctx, {
    type: 'label',
    x: x + LEGEND_ICON_SIZE + LEGEND_MARGIN_X + (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0),
    y: y,
    text: text,
    style: ['default', {
      font: font,
      textBaseline: 'top',
      fillStyle: fillStyle
    }]
  });
}

function legend_legend(ctx, model) {
  var data = model.data,
      showCheckbox = model.showCheckbox,
      align = model.align,
      fontSize = model.fontSize,
      fontFamily = model.fontFamily,
      fontWeight = model.fontWeight;
  var font = getTitleFontString({
    fontSize: fontSize,
    fontFamily: fontFamily,
    fontWeight: fontWeight
  });
  var fontColor = model.color;
  data.forEach(function (datum) {
    var x = datum.x,
        y = datum.y,
        checked = datum.checked,
        active = datum.active,
        color = datum.color,
        iconType = datum.iconType,
        useScatterChartIcon = datum.useScatterChartIcon,
        legendLabel = datum.label;
    var iconY = y - 1 + (getTextHeight(legendLabel, font) - 11) / 4;
    var renderOptions = {
      iconType: iconType,
      checked: checked,
      active: active,
      color: color,
      showCheckbox: showCheckbox,
      align: align,
      font: font,
      fontColor: fontColor
    };

    if (showCheckbox) {
      drawCheckbox(ctx, x, iconY, renderOptions);
    }

    if (useScatterChartIcon && iconType !== 'line') {
      drawScatterIcon(ctx, x, iconY, renderOptions);
    } else {
      drawIcon(ctx, x, iconY, renderOptions);
    }

    drawLabel(ctx, x, y, legendLabel, renderOptions);
  });
}
// CONCATENATED MODULE: ./src/store/layout.ts








function layout_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function layout_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { layout_ownKeys(Object(source), true).forEach(function (key) { layout_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { layout_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function layout_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var layout_padding = {
  X: 10,
  Y: 15
};
var X_AXIS_HEIGHT = 20;
var Y_AXIS_MIN_WIDTH = 40;
function isVerticalAlign(align) {
  return align === 'top' || align === 'bottom';
}

function getValidRectSize(size, width, height) {
  var _size$height, _size$width;

  return {
    height: (_size$height = size === null || size === void 0 ? void 0 : size.height) !== null && _size$height !== void 0 ? _size$height : height,
    width: (_size$width = size === null || size === void 0 ? void 0 : size.width) !== null && _size$width !== void 0 ? _size$width : width
  };
}

function getDefaultXAxisHeight(size) {
  var _size$xAxis;

  return ((_size$xAxis = size.xAxis) === null || _size$xAxis === void 0 ? void 0 : _size$xAxis.height) && !size.yAxis ? size.xAxis.height : X_AXIS_HEIGHT;
}

function getDefaultYAxisXPoint(yAxisRectParam) {
  var yAxisTitle = yAxisRectParam.yAxisTitle,
      isRightSide = yAxisRectParam.isRightSide,
      visibleSecondaryYAxis = yAxisRectParam.visibleSecondaryYAxis;
  var yAxisWidth = getDefaultYAxisWidth(yAxisRectParam);
  return isRightSide && visibleSecondaryYAxis ? Math.max(yAxisTitle.x + yAxisTitle.width - yAxisWidth, 0) : yAxisTitle.x;
}

function layout_getYAxisXPoint(yAxisRectParam) {
  var chartSize = yAxisRectParam.chartSize,
      legend = yAxisRectParam.legend,
      circleLegend = yAxisRectParam.circleLegend,
      hasCenterYAxis = yAxisRectParam.hasCenterYAxis,
      maxLabelWidth = yAxisRectParam.maxLabelWidth;
  var width = chartSize.width;
  var align = legend.align;
  var yAxisWidth = getDefaultYAxisWidth(yAxisRectParam);
  var x = getDefaultYAxisXPoint(yAxisRectParam);

  if (hasCenterYAxis) {
    yAxisWidth = maxLabelWidth + (TICK_SIZE + layout_padding.X) * 2;
    x = (width - legend.width - yAxisWidth + layout_padding.X * 2) / 2;
  }

  if (legend.visible && align === 'left') {
    x = getDefaultYAxisXPoint(yAxisRectParam);
  }

  if (circleLegend.visible && align === 'left') {
    x = Math.max(circleLegend.width + layout_padding.X, x);
  }

  return x;
}

function getYAxisYPoint(_ref) {
  var yAxisTitle = _ref.yAxisTitle;
  return yAxisTitle.y + yAxisTitle.height;
}

function getDefaultYAxisWidth(_ref2) {
  var _size$width2, _size;

  var maxLabelWidth = _ref2.maxLabelWidth,
      size = _ref2.size,
      isRightSide = _ref2.isRightSide;
  return (_size$width2 = size === null || size === void 0 ? void 0 : (_size = size[isRightSide ? 'secondaryYAxis' : 'yAxis']) === null || _size === void 0 ? void 0 : _size.width) !== null && _size$width2 !== void 0 ? _size$width2 : maxLabelWidth;
}

function getYAxisWidth(yAxisRectParam) {
  var hasCenterYAxis = yAxisRectParam.hasCenterYAxis,
      hasAxis = yAxisRectParam.hasAxis,
      maxLabelWidth = yAxisRectParam.maxLabelWidth,
      _yAxisRectParam$visib = yAxisRectParam.visibleSecondaryYAxis,
      visibleSecondaryYAxis = _yAxisRectParam$visib === void 0 ? false : _yAxisRectParam$visib,
      _yAxisRectParam$isRig = yAxisRectParam.isRightSide,
      isRightSide = _yAxisRectParam$isRig === void 0 ? false : _yAxisRectParam$isRig;
  var yAxisWidth = getDefaultYAxisWidth(yAxisRectParam);

  if (hasCenterYAxis && !isRightSide) {
    yAxisWidth = maxLabelWidth + (TICK_SIZE + layout_padding.X) * 2;
  } else if (!hasAxis || isRightSide && !visibleSecondaryYAxis) {
    yAxisWidth = 0;
  }

  return yAxisWidth;
}

function getYAxisHeight(_ref3) {
  var _size$yAxis, _size$plot;

  var chartSize = _ref3.chartSize,
      legend = _ref3.legend,
      yAxisTitle = _ref3.yAxisTitle,
      hasAxis = _ref3.hasAxis,
      size = _ref3.size,
      xAxisTitleHeight = _ref3.xAxisTitleHeight,
      legendItemHeight = _ref3.legendItemHeight;
  var height = chartSize.height;
  var align = legend.align,
      useSpectrumLegend = legend.useSpectrumLegend;
  var xAxisHeight = getDefaultXAxisHeight(size);
  var y = yAxisTitle.y + yAxisTitle.height;
  var yAxisHeight = height - y - xAxisHeight - xAxisTitleHeight;

  if (!hasAxis) {
    yAxisHeight = height - y;
  }

  if (legend.visible) {
    var legendAreaHeight = getTopLegendAreaHeight(useSpectrumLegend, legendItemHeight);
    var topArea = Math.max(y, legendAreaHeight);

    if (align === 'top') {
      yAxisHeight = height - topArea - (hasAxis ? X_AXIS_HEIGHT + xAxisTitleHeight : 0);
    } else if (align === 'bottom') {
      yAxisHeight = height - y - X_AXIS_HEIGHT - xAxisTitleHeight - legendItemHeight;
    }
  }

  if (!(size === null || size === void 0 ? void 0 : (_size$yAxis = size.yAxis) === null || _size$yAxis === void 0 ? void 0 : _size$yAxis.height) && (size === null || size === void 0 ? void 0 : (_size$plot = size.plot) === null || _size$plot === void 0 ? void 0 : _size$plot.height)) {
    yAxisHeight = size.plot.height;
  }

  return yAxisHeight;
}

function getYAxisRect(yAxisRectParam) {
  var size = yAxisRectParam.size,
      _yAxisRectParam$isRig2 = yAxisRectParam.isRightSide,
      isRightSide = _yAxisRectParam$isRig2 === void 0 ? false : _yAxisRectParam$isRig2;
  var x = layout_getYAxisXPoint(yAxisRectParam);
  var y = getYAxisYPoint(yAxisRectParam);
  var yAxisWidth = getYAxisWidth(yAxisRectParam);
  var yAxisHeight = getYAxisHeight(yAxisRectParam);
  return layout_objectSpread({
    x: x,
    y: y
  }, getValidRectSize(isRightSide ? size === null || size === void 0 ? void 0 : size.secondaryYAxis : size === null || size === void 0 ? void 0 : size.yAxis, yAxisWidth, yAxisHeight));
}

function getXAxisWidth(_ref4) {
  var chartSize = _ref4.chartSize,
      yAxis = _ref4.yAxis,
      hasCenterYAxis = _ref4.hasCenterYAxis,
      legend = _ref4.legend,
      circleLegend = _ref4.circleLegend,
      secondaryYAxis = _ref4.secondaryYAxis,
      xAxisData = _ref4.xAxisData;
  var width = chartSize.width;
  var align = legend.align,
      legendWidth = legend.width;
  var legendVerticalAlign = isVerticalAlign(align);
  var xAxisWidth;

  if (legendVerticalAlign) {
    xAxisWidth = width - (yAxis.x + yAxis.width + layout_padding.X);

    if (circleLegend.visible) {
      xAxisWidth -= circleLegend.width;
    }
  } else {
    xAxisWidth = width - (yAxis.width + Math.max(legendWidth, circleLegend.width));
  }

  if (hasCenterYAxis) {
    xAxisWidth = width - (legendVerticalAlign ? 0 : legendWidth) - layout_padding.X * 2;
  }

  if (secondaryYAxis.width) {
    xAxisWidth -= secondaryYAxis.width;
  }

  if (xAxisData === null || xAxisData === void 0 ? void 0 : xAxisData.maxLabelWidth) {
    // subtract half of the maximum label length to secure margin size
    xAxisWidth -= xAxisData.maxLabelWidth * 0.5;
  }

  return xAxisWidth;
}

function getXAxisHeight(xAxisData) {
  var _xAxisData$maxHeight;

  var hasAxis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (!hasAxis) {
    return 0;
  }

  return (_xAxisData$maxHeight = xAxisData === null || xAxisData === void 0 ? void 0 : xAxisData.maxHeight) !== null && _xAxisData$maxHeight !== void 0 ? _xAxisData$maxHeight : X_AXIS_HEIGHT;
}

function getXAxisRect(xAxisRectParam) {
  var hasAxis = xAxisRectParam.hasAxis,
      hasCenterYAxis = xAxisRectParam.hasCenterYAxis,
      yAxis = xAxisRectParam.yAxis,
      size = xAxisRectParam.size,
      xAxisData = xAxisRectParam.xAxisData;
  var x = hasCenterYAxis ? layout_padding.X * 2 : yAxis.x + yAxis.width;
  var y = yAxis.y + yAxis.height;
  var xAxisWidth = getXAxisWidth(xAxisRectParam);
  var xAxisHeight = getXAxisHeight(xAxisData, hasAxis);
  return layout_objectSpread({
    x: x,
    y: y
  }, getValidRectSize(size === null || size === void 0 ? void 0 : size.xAxis, xAxisWidth, xAxisHeight));
}

function getLegendRect(legendRectParams) {
  var legend = legendRectParams.legend,
      xAxis = legendRectParams.xAxis,
      yAxis = legendRectParams.yAxis,
      chartSize = legendRectParams.chartSize,
      title = legendRectParams.title,
      hasAxis = legendRectParams.hasAxis,
      secondaryYAxis = legendRectParams.secondaryYAxis,
      xAxisTitleHeight = legendRectParams.xAxisTitleHeight,
      legendItemHeight = legendRectParams.legendItemHeight;

  if (!legend.visible) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }

  var align = legend.align,
      legendWidth = legend.width;
  var width = chartSize.width;
  var verticalAlign = isVerticalAlign(align);
  var x = xAxis.x + xAxis.width + secondaryYAxis.width + layout_padding.X;
  var y = Math.max(yAxis.y, BUTTON_RECT_SIZE);
  var height = yAxis.height - xAxis.height;

  if (verticalAlign) {
    x = (width - legendWidth) / 2;
    height = getTopLegendAreaHeight(legend.useSpectrumLegend, legendItemHeight);

    if (align === 'top') {
      y = title.y + title.height;
    } else {
      y = yAxis.y + yAxis.height + (hasAxis ? xAxis.height + xAxisTitleHeight : layout_padding.Y);
    }
  } else if (align === 'left') {
    x = layout_padding.X;
  }

  return {
    width: legendWidth,
    height: height,
    x: x,
    y: y
  };
}

function getCircleLegendRect(xAxis, yAxis, align, width) {
  return {
    width: width,
    height: yAxis.height,
    x: align === 'left' ? layout_padding.X : xAxis.x + xAxis.width + layout_padding.X,
    y: yAxis.y
  };
}

function getPlotRect(xAxis, yAxis, size) {
  return layout_objectSpread({
    x: xAxis.x,
    y: yAxis.y
  }, getValidRectSize(size, Math.max(xAxis.width, 1), Math.max(yAxis.height, 1)));
}

function getTitleRect(chartSize, exportMenu, visible, titleHeight) {
  var point = {
    x: layout_padding.X,
    y: layout_padding.Y
  };
  var marginBottom = 5;
  var width = visible ? chartSize.width - exportMenu.width : 0;
  var height = visible ? Math.max(titleHeight + marginBottom, exportMenu.height) : exportMenu.height;
  return layout_objectSpread({
    width: width,
    height: height
  }, point);
}

function getTopLegendAreaHeight(useSpectrumLegend, legendItemHeight) {
  return useSpectrumLegend ? SPECTRUM_LEGEND_LABEL_HEIGHT + spectrumLegendBar.PADDING * 2 + spectrumLegendTooltip.POINT_HEIGHT + spectrumLegendTooltip.HEIGHT + layout_padding.Y : legendItemHeight + layout_padding.Y;
}

function getYAxisTitleRect(_ref5) {
  var chartSize = _ref5.chartSize,
      visible = _ref5.visible,
      title = _ref5.title,
      _ref5$legend = _ref5.legend,
      legendAlign = _ref5$legend.align,
      legendWidth = _ref5$legend.width,
      legendVisible = _ref5$legend.visible,
      useSpectrumLegend = _ref5$legend.useSpectrumLegend,
      hasCenterYAxis = _ref5.hasCenterYAxis,
      visibleSecondaryYAxis = _ref5.visibleSecondaryYAxis,
      _ref5$isRightSide = _ref5.isRightSide,
      isRightSide = _ref5$isRightSide === void 0 ? false : _ref5$isRightSide,
      yAxisTitleHeight = _ref5.yAxisTitleHeight,
      legendItemHeight = _ref5.legendItemHeight;
  var marginBottom = 5;
  var height = visible ? yAxisTitleHeight + marginBottom : 0;
  var verticalLegendAlign = isVerticalAlign(legendAlign);
  var width = (chartSize.width - (verticalLegendAlign ? layout_padding.X * 2 : legendWidth)) / (visibleSecondaryYAxis ? 2 : 1);
  var point = {
    x: isRightSide ? title.x + width : title.x,
    y: title.y + title.height
  };

  if (legendVisible) {
    if (legendAlign === 'left') {
      point.x += legendWidth;
    } else if (legendAlign === 'top') {
      point.y += getTopLegendAreaHeight(useSpectrumLegend, legendItemHeight);
    }
  }

  if (hasCenterYAxis) {
    point.x = (width + layout_padding.X * 2) / 2;
  }

  return layout_objectSpread({
    height: height,
    width: width
  }, point);
}

function getXAxisTitleRect(visible, xAxis, xAxisTitleHeight) {
  var point = {
    x: xAxis.x,
    y: xAxis.y + xAxis.height
  };
  var height = visible ? xAxisTitleHeight : 0;
  var width = visible ? xAxis.width : 0;
  return layout_objectSpread({
    height: height,
    width: width
  }, point);
}

function getExportMenuRect(chartSize, visible) {
  var marginY = 5;
  var x = visible ? layout_padding.X + chartSize.width - BUTTON_RECT_SIZE : layout_padding.X + chartSize.width;
  var y = layout_padding.Y;
  var height = visible ? BUTTON_RECT_SIZE + marginY : 0;
  var width = visible ? BUTTON_RECT_SIZE : 0;
  return {
    x: x,
    y: y,
    height: height,
    width: width
  };
}

function getResetButtonRect(exportMenu, useResetButton) {
  var marginY = 5;
  var x = useResetButton ? exportMenu.x - BUTTON_RECT_SIZE - layout_padding.X : 0;
  var y = useResetButton ? exportMenu.y : 0;
  var height = useResetButton ? BUTTON_RECT_SIZE + marginY : 0;
  var width = useResetButton ? BUTTON_RECT_SIZE : 0;
  return {
    x: x,
    y: y,
    height: height,
    width: width
  };
}

function isUsingResetButton(options) {
  var _ref6;

  return !!((_ref6 = options.series) === null || _ref6 === void 0 ? void 0 : _ref6.zoomable);
}
function isExportMenuVisible(options) {
  var _options$exportMenu;

  var visible = (_options$exportMenu = options.exportMenu) === null || _options$exportMenu === void 0 ? void 0 : _options$exportMenu.visible;
  return isUndefined(visible) ? true : visible;
}

function getYAxisMaxLabelWidth(maxLabelLength) {
  return maxLabelLength ? maxLabelLength + layout_padding.X : Y_AXIS_MIN_WIDTH;
}

function pickOptionSize(option) {
  if (!option || isUndefined(option.width) && isUndefined(option.height)) {
    return null;
  }

  return pick(option, 'width', 'height');
}

function validOffsetValue(axis, plot, sizeKey) {
  var axisSize = axis[sizeKey];
  var plotSize = plot[sizeKey];

  if (isNumber(axisSize) && isNumber(plotSize)) {
    return Math.max(axisSize, plotSize);
  }
}

function getOptionSize(options) {
  var xAxis = pickOptionSize(options.xAxis);
  var yAxisOptions = getYAxisOption(options);
  var yAxis = pickOptionSize(yAxisOptions.yAxis);
  var secondaryYAxis = pickOptionSize(yAxisOptions.secondaryYAxis);
  var plot = pickOptionSize(options.plot);

  if (plot) {
    /*
    If both the width of the x-axis and the width of the plot are entered,
    set the maximum value.
    */
    if (xAxis) {
      xAxis.width = plot.width = validOffsetValue(xAxis, plot, 'width');
    }
    /*
    If both the height of the y-axis and the height of the plot are entered,
    set the maximum value.
    */


    if (yAxis) {
      yAxis.height = plot.height = validOffsetValue(yAxis, plot, 'height');
    }

    if (secondaryYAxis) {
      secondaryYAxis.height = plot.height = validOffsetValue(secondaryYAxis, plot, 'height');
    }
  }

  return {
    xAxis: xAxis,
    yAxis: yAxis,
    plot: plot,
    secondaryYAxis: secondaryYAxis
  };
}

function getAxisTitleHeight(axisTheme) {
  var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var fontSize = Array.isArray(axisTheme) ? Math.max(axisTheme[0].title.fontSize, axisTheme[1].title.fontSize) : axisTheme.title.fontSize;
  return fontSize + offsetY;
}

function adjustAxisSize(_ref7, layout, legendState) {
  var width = _ref7.width,
      height = _ref7.height;

  if (width < 0 || height < 0) {
    return;
  }

  var title = layout.title,
      yAxisTitle = layout.yAxisTitle,
      yAxis = layout.yAxis,
      xAxis = layout.xAxis,
      xAxisTitle = layout.xAxisTitle,
      legend = layout.legend,
      secondaryYAxis = layout.secondaryYAxis;
  var align = legendState.align;
  var hasVerticalLegend = isVerticalAlign(align);
  var legendHeight = hasVerticalLegend ? legend.height : 0;
  var diffHeight = xAxis.height + xAxisTitle.height + yAxis.height + yAxisTitle.height + title.height + legendHeight - height;

  if (diffHeight > 0) {
    yAxis.height -= diffHeight;
    xAxis.y -= diffHeight;
    xAxisTitle.y -= diffHeight;

    if (hasVerticalLegend) {
      legend.y -= diffHeight;
    }
  }

  secondaryYAxis.x = xAxis.x + xAxis.width;
  secondaryYAxis.height = yAxis.height;
}

var layout_layout = {
  name: 'layout',
  state: function state() {
    return {
      layout: {}
    };
  },
  action: {
    setLayout: function setLayout(_ref8) {
      var _getAxisTitleHeight, _axes$yAxis, _axes$yAxis$title, _getAxisTitleHeight2, _axes$xAxis, _axes$xAxis$title, _options$chart, _axes$secondaryYAxis, _options$xAxis;

      var state = _ref8.state;
      var legendState = state.legend,
          theme = state.theme,
          circleLegendState = state.circleLegend,
          series = state.series,
          options = state.options,
          chart = state.chart,
          axes = state.axes;
      var width = chart.width,
          height = chart.height;
      var chartSize = {
        height: height - layout_padding.Y * 2,
        width: width - layout_padding.X * 2
      };
      var hasCenterYAxis = isCenterYAxis(options, !!series.bar);
      var hasAxis = !(series.pie || series.radar || series.treemap);
      var optionSize = getOptionSize(options);

      var _getYAxisOption = getYAxisOption(options),
          yAxisOption = _getYAxisOption.yAxis,
          secondaryYAxisOption = _getYAxisOption.secondaryYAxis;

      var visibleSecondaryYAxis = !!secondaryYAxisOption;
      var titleHeight = theme.title.fontSize;
      var yAxisTitleHeight = (_getAxisTitleHeight = getAxisTitleHeight(theme.yAxis, axes === null || axes === void 0 ? void 0 : (_axes$yAxis = axes.yAxis) === null || _axes$yAxis === void 0 ? void 0 : (_axes$yAxis$title = _axes$yAxis.title) === null || _axes$yAxis$title === void 0 ? void 0 : _axes$yAxis$title.offsetY)) !== null && _getAxisTitleHeight !== void 0 ? _getAxisTitleHeight : 0;
      var xAxisTitleHeight = (_getAxisTitleHeight2 = getAxisTitleHeight(theme.xAxis, axes === null || axes === void 0 ? void 0 : (_axes$xAxis = axes.xAxis) === null || _axes$xAxis === void 0 ? void 0 : (_axes$xAxis$title = _axes$xAxis.title) === null || _axes$xAxis$title === void 0 ? void 0 : _axes$xAxis$title.offsetY)) !== null && _getAxisTitleHeight2 !== void 0 ? _getAxisTitleHeight2 : 0;
      var legendItemHeight = getLegendItemHeight(theme.legend.label.fontSize); // Don't change the order!
      // exportMenu -> resetButton -> title -> yAxis.title -> yAxis -> secondaryYAxisTitle -> secondaryYAxis -> xAxis -> xAxis.title -> legend -> circleLegend -> plot

      var exportMenu = getExportMenuRect(chartSize, isExportMenuVisible(options));
      var resetButton = getResetButtonRect(exportMenu, isUsingResetButton(options));
      var btnAreaRect = exportMenu.height ? exportMenu : resetButton;
      var title = getTitleRect(chartSize, btnAreaRect, !!((_options$chart = options.chart) === null || _options$chart === void 0 ? void 0 : _options$chart.title), titleHeight);
      var yAxisTitle = getYAxisTitleRect({
        chartSize: chartSize,
        visible: !!(yAxisOption === null || yAxisOption === void 0 ? void 0 : yAxisOption.title) || !!(secondaryYAxisOption === null || secondaryYAxisOption === void 0 ? void 0 : secondaryYAxisOption.title),
        title: title,
        legend: legendState,
        hasCenterYAxis: hasCenterYAxis,
        visibleSecondaryYAxis: visibleSecondaryYAxis,
        yAxisTitleHeight: yAxisTitleHeight,
        legendItemHeight: legendItemHeight
      });
      var yAxis = getYAxisRect({
        chartSize: chartSize,
        legend: legendState,
        circleLegend: circleLegendState,
        yAxisTitle: yAxisTitle,
        hasCenterYAxis: hasCenterYAxis,
        hasAxis: hasAxis,
        maxLabelWidth: getYAxisMaxLabelWidth(axes === null || axes === void 0 ? void 0 : axes.yAxis.maxLabelWidth),
        size: optionSize,
        xAxisTitleHeight: xAxisTitleHeight,
        legendItemHeight: legendItemHeight
      });
      var secondaryYAxisTitle = getYAxisTitleRect({
        chartSize: chartSize,
        visible: !!(yAxisOption === null || yAxisOption === void 0 ? void 0 : yAxisOption.title) || !!(secondaryYAxisOption === null || secondaryYAxisOption === void 0 ? void 0 : secondaryYAxisOption.title),
        title: title,
        legend: legendState,
        hasCenterYAxis: hasCenterYAxis,
        isRightSide: true,
        visibleSecondaryYAxis: visibleSecondaryYAxis,
        yAxisTitleHeight: yAxisTitleHeight,
        legendItemHeight: legendItemHeight
      });
      var secondaryYAxis = getYAxisRect({
        chartSize: chartSize,
        legend: legendState,
        circleLegend: circleLegendState,
        yAxisTitle: secondaryYAxisTitle,
        hasCenterYAxis: hasCenterYAxis,
        hasAxis: hasAxis,
        maxLabelWidth: getYAxisMaxLabelWidth(axes === null || axes === void 0 ? void 0 : (_axes$secondaryYAxis = axes.secondaryYAxis) === null || _axes$secondaryYAxis === void 0 ? void 0 : _axes$secondaryYAxis.maxLabelWidth),
        size: optionSize,
        isRightSide: true,
        visibleSecondaryYAxis: visibleSecondaryYAxis,
        xAxisTitleHeight: xAxisTitleHeight,
        legendItemHeight: legendItemHeight
      });
      var xAxis = getXAxisRect({
        chartSize: chartSize,
        yAxis: yAxis,
        secondaryYAxis: secondaryYAxis,
        legend: legendState,
        circleLegend: circleLegendState,
        hasCenterYAxis: hasCenterYAxis,
        hasAxis: hasAxis,
        size: optionSize,
        xAxisData: axes === null || axes === void 0 ? void 0 : axes.xAxis
      });
      var xAxisTitle = getXAxisTitleRect(!!((_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : _options$xAxis.title), xAxis, xAxisTitleHeight);
      var legend = getLegendRect({
        chartSize: chartSize,
        xAxis: xAxis,
        yAxis: yAxis,
        secondaryYAxis: secondaryYAxis,
        title: title,
        legend: legendState,
        hasAxis: hasAxis,
        xAxisTitleHeight: xAxisTitleHeight,
        legendItemHeight: legendItemHeight
      });
      adjustAxisSize(chartSize, {
        title: title,
        yAxisTitle: yAxisTitle,
        yAxis: yAxis,
        xAxis: xAxis,
        xAxisTitle: xAxisTitle,
        legend: legend,
        secondaryYAxis: secondaryYAxis
      }, legendState);
      var circleLegend = getCircleLegendRect(xAxis, yAxis, legendState.align, circleLegendState.width);
      var plot = getPlotRect(xAxis, yAxis, optionSize.plot);
      store_extend(state.layout, {
        chart: {
          x: 0,
          y: 0,
          width: width,
          height: height
        },
        title: title,
        plot: plot,
        legend: legend,
        circleLegend: circleLegend,
        xAxis: xAxis,
        xAxisTitle: xAxisTitle,
        yAxis: yAxis,
        yAxisTitle: yAxisTitle,
        exportMenu: exportMenu,
        resetButton: resetButton,
        secondaryYAxisTitle: secondaryYAxisTitle,
        secondaryYAxis: secondaryYAxis
      });
    }
  },
  observe: {
    updateLayoutObserve: function updateLayoutObserve() {
      this.dispatch('setLayout');
    }
  }
};
/* harmony default export */ var store_layout = (layout_layout);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.includes.js
var es_string_includes = __webpack_require__(77);

// CONCATENATED MODULE: ./src/store/category.ts

















function category_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function category_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { category_ownKeys(Object(source), true).forEach(function (key) { category_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { category_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function category_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




function makeRawCategories(series, categories) {
  if (categories) {
    return categories;
  }

  var firstValues = new Set();
  Object.keys(series).forEach(function (key) {
    var _series$key$data;

    if (key === 'pie') {
      return;
    }

    ((_series$key$data = series[key].data) !== null && _series$key$data !== void 0 ? _series$key$data : series[key]).forEach(function (_ref) {
      var data = _ref.data,
          name = _ref.name;

      if (Array.isArray(data)) {
        data.forEach(function (datum) {
          if (!isNull(datum)) {
            var rawXValue = getCoordinateXValue(datum);
            firstValues.add(isNumber(rawXValue) ? rawXValue : rawXValue.toString());
          }
        });
      } else if (key === 'bullet') {
        firstValues.add(name);
      }
    });
  });
  return Array.from(firstValues).sort(sortCategories).map(function (category) {
    return String(category);
  });
}
var category_category = {
  name: 'category',
  state: function state(_ref2) {
    var categories = _ref2.categories,
        series = _ref2.series;
    return {
      categories: makeRawCategories(series, categories)
    };
  },
  action: {
    setCategory: function setCategory(_ref3) {
      var state = _ref3.state,
          computed = _ref3.computed;
      var viewRange = computed.viewRange;
      var categories = state.rawCategories;

      if (viewRange) {
        if (Array.isArray(categories)) {
          categories = getDataInRange(categories, viewRange);
        } else {
          categories = category_objectSpread(category_objectSpread({}, categories), {}, {
            x: getDataInRange(categories.x, viewRange)
          });
        }
      }

      state.categories = categories;
      this.notify(state, 'categories');
    },
    initCategory: function initCategory(_ref4) {
      var initStoreState = _ref4.initStoreState,
          state = _ref4.state;
      var zoomRange = state.zoomRange;
      var categories = makeRawCategories(initStoreState.series);

      if (zoomRange && Array.isArray(categories)) {
        categories = getDataInRange(categories, zoomRange);
      }

      state.categories = categories;
      this.notify(state, 'categories');
    }
  },
  observe: {
    updateCategory: function updateCategory() {
      this.dispatch('setCategory');
    }
  }
};
/* harmony default export */ var store_category = (category_category);
// CONCATENATED MODULE: ./src/store/seriesData.ts
























function seriesData_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function seriesData_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { seriesData_ownKeys(Object(source), true).forEach(function (key) { seriesData_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { seriesData_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function seriesData_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function seriesData_slicedToArray(arr, i) { return seriesData_arrayWithHoles(arr) || seriesData_iterableToArrayLimit(arr, i) || seriesData_unsupportedIterableToArray(arr, i) || seriesData_nonIterableRest(); }

function seriesData_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function seriesData_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return seriesData_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return seriesData_arrayLikeToArray(o, minLen); }

function seriesData_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function seriesData_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function seriesData_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







function initRange(series, categories) {
  var rawCategoriesLength;

  if (categories) {
    rawCategoriesLength = Array.isArray(categories) ? categories.length : categories.x.length;
  } else {
    rawCategoriesLength = Object.keys(makeRawCategories(series, categories)).length;
  }

  return [0, rawCategoriesLength - 1];
}

function initZoomRange(series, options, categories) {
  var _ref;

  if (!(series.line || series.area) || !((_ref = options.series) === null || _ref === void 0 ? void 0 : _ref.zoomable)) {
    return;
  }

  return initRange(series, categories);
}

function initShiftRange(series, options, categories) {
  var _ref2;

  if (!(series.line || series.area || series.column || series.heatmap) || !((_ref2 = options.series) === null || _ref2 === void 0 ? void 0 : _ref2.shift)) {
    return;
  }

  return initRange(series, categories);
}

function getCoordinateDataRange(data, rawCategories, zoomRange) {
  var _zoomRange = seriesData_slicedToArray(zoomRange, 2),
      zoomStart = _zoomRange[0],
      zoomEnd = _zoomRange[1];

  var start, end;
  utils_range(zoomStart, zoomEnd + 1).forEach(function (i) {
    var idx = data.findIndex(function (datum) {
      return getCoordinateXValue(datum).toString() === rawCategories[i];
    });

    if (idx !== -1) {
      if (isUndefined(start)) {
        start = idx;
      }

      if (!isUndefined(start)) {
        var _end;

        end = Math.max(idx, (_end = end) !== null && _end !== void 0 ? _end : 0);
      }
    }
  });
  return [start, end];
}

function getSeriesDataInRange(data, rawCategories, chartType, zoomRange) {
  if (!zoomRange) {
    return data;
  }

  var _zoomRange2 = seriesData_slicedToArray(zoomRange, 2),
      startIdx = _zoomRange2[0],
      endIdx = _zoomRange2[1];

  var isCoordinateChart = chartType !== 'area' && !isNumber(getFirstValidValue(data));

  if (isCoordinateChart) {
    var _getCoordinateDataRan = getCoordinateDataRange(data, rawCategories, zoomRange);

    var _getCoordinateDataRan2 = seriesData_slicedToArray(_getCoordinateDataRan, 2);

    startIdx = _getCoordinateDataRan2[0];
    endIdx = _getCoordinateDataRan2[1];
  } else {
    startIdx = startIdx > 1 ? startIdx - 1 : startIdx;
    endIdx = endIdx < rawCategories.length - 1 ? endIdx + 1 : endIdx;
  }

  return data.slice(startIdx, endIdx + 1);
}

function isCoordinateTypeSeries(series, chartType) {
  return isCoordinateSeries(series) && (isUndefined(chartType) || chartType === 'line' || chartType === 'scatter');
}

function isSeriesAlreadyExist(series, seriesName, data) {
  return series[seriesName].some(function (_ref3) {
    var label = _ref3.label;
    return label === data.name;
  });
}

function isTreemapSeriesAlreadyExist(series, data) {
  return series.treemap.some(function (_ref4) {
    var label = _ref4.label;
    return label === data.label;
  });
}

function isHeatmapSeriesAlreadyExist(categories, category) {
  return includes(categories.y, category);
}

var seriesData_seriesData = {
  name: 'seriesData',
  state: function state(_ref5) {
    var series = _ref5.series,
        categories = _ref5.categories,
        options = _ref5.options;
    return {
      rawCategories: makeRawCategories(series, categories),
      series: seriesData_objectSpread({}, series),
      zoomRange: initZoomRange(series, options, categories),
      shiftRange: initShiftRange(series, options, categories),
      disabledSeries: []
    };
  },
  action: {
    setSeriesData: function setSeriesData(_ref6) {
      var state = _ref6.state,
          initStoreState = _ref6.initStoreState;
      var rawSeries = deepCopy(initStoreState.series);
      var disabledSeries = state.disabledSeries,
          theme = state.theme,
          zoomRange = state.zoomRange,
          rawCategories = state.rawCategories;
      var newSeriesData = {};
      Object.keys(rawSeries).forEach(function (seriesName) {
        var _originSeriesData$0$d, _originSeriesData$, _originSeriesData$$da;

        var _seriesName = theme.series[seriesName],
            colors = _seriesName.colors,
            iconTypes = _seriesName.iconTypes;
        var originSeriesData = rawSeries[seriesName].map(function (m, idx) {
          return seriesData_objectSpread(seriesData_objectSpread({}, m), {}, {
            rawData: m.data,
            data: getSeriesDataInRange(m.data, rawCategories, seriesName, zoomRange),
            color: colors ? colors[idx] : ''
          });
        });

        if (seriesName === 'scatter') {
          originSeriesData = originSeriesData.map(function (m, idx) {
            return seriesData_objectSpread(seriesData_objectSpread({}, m), {}, {
              iconType: iconTypes ? iconTypes[idx] : 'circle'
            });
          });
        }

        var seriesCount = originSeriesData.length;
        var seriesGroupCount = (_originSeriesData$0$d = (_originSeriesData$ = originSeriesData[0]) === null || _originSeriesData$ === void 0 ? void 0 : (_originSeriesData$$da = _originSeriesData$.data) === null || _originSeriesData$$da === void 0 ? void 0 : _originSeriesData$$da.length) !== null && _originSeriesData$0$d !== void 0 ? _originSeriesData$0$d : 0;
        var data = originSeriesData.filter(function (_ref7) {
          var name = _ref7.name;
          return !disabledSeries.includes(name);
        });
        newSeriesData[seriesName] = {
          seriesCount: seriesCount,
          seriesGroupCount: seriesGroupCount,
          data: data,
          colors: colors
        };
      });
      store_extend(state.series, newSeriesData);
    },
    disableSeries: function disableSeries(_ref8, name) {
      var state = _ref8.state;
      state.disabledSeries.push(name);
      this.notify(state, 'disabledSeries');

      if (state.series.bullet) {
        var index = state.categories.findIndex(function (seriesName) {
          return seriesName === name;
        });
        state.categories.splice(index, 1);
        this.notify(state, 'axes');
      }
    },
    enableSeries: function enableSeries(_ref9, name) {
      var state = _ref9.state;
      var index = state.disabledSeries.findIndex(function (disabled) {
        return disabled === name;
      });
      state.disabledSeries.splice(index, 1);
      this.notify(state, 'disabledSeries');

      if (state.series.bullet) {
        state.categories = state.series.bullet.data.map(function (_ref10) {
          var seriesName = _ref10.name;
          return seriesName;
        });
        this.notify(state, 'axes');
      }
    },
    zoom: function zoom(_ref11, rangeCategories) {
      var state = _ref11.state;
      var rawCategories = state.rawCategories;
      state.zoomRange = rangeCategories.map(function (rangeCategory) {
        return rawCategories.findIndex(function (category) {
          return category === rangeCategory;
        });
      });
      this.notify(state, 'zoomRange');
    },
    resetZoom: function resetZoom(_ref12) {
      var state = _ref12.state,
          initStoreState = _ref12.initStoreState;
      var series = initStoreState.series,
          options = initStoreState.options;
      var rawCategories = state.rawCategories;
      state.zoomRange = initZoomRange(series, options, rawCategories);
      this.notify(state, 'zoomRange');
    },
    addData: function addData(_ref13, _ref14) {
      var state = _ref13.state,
          initStoreState = _ref13.initStoreState;
      var data = _ref14.data,
          category = _ref14.category,
          chartType = _ref14.chartType;
      var series = initStoreState.series;
      var coordinateChart = isCoordinateTypeSeries(state.series, chartType);
      var categories = initStoreState.categories;
      categories = series.heatmap ? categories.x : categories;

      if (category && Array.isArray(categories)) {
        var isExist = categories.some(function (c) {
          return c === category;
        });

        if (!isExist) {
          categories.push(category);

          if (Array.isArray(state.shiftRange)) {
            var _state$shiftRange = seriesData_slicedToArray(state.shiftRange, 2),
                start = _state$shiftRange[0],
                end = _state$shiftRange[1];

            state.shiftRange = [start + 1, end + 1];
          }
        }
      }

      if (chartType) {
        series[chartType].forEach(function (datum, idx) {
          datum.data.push(data[idx]);
        });
      } else {
        var _Object$keys = Object.keys(initStoreState.series),
            _Object$keys2 = seriesData_slicedToArray(_Object$keys, 1),
            seriesName = _Object$keys2[0];

        series[seriesName].forEach(function (datum, idx) {
          datum.data.push(data[idx]);
        });
      }

      this.notify(state, 'series');
      this.notify(state, 'rawCategories');

      if (Array.isArray(state.zoomRange)) {
        this.dispatch('resetZoom');
      }

      if (coordinateChart) {
        this.dispatch('initCategory');
      }
    },
    addSeries: function addSeries(_ref15, _ref16) {
      var state = _ref15.state,
          initStoreState = _ref15.initStoreState;
      var data = _ref16.data,
          chartType = _ref16.chartType,
          category = _ref16.category;
      var series = initStoreState.series,
          categories = initStoreState.categories;
      var coordinateChart = isCoordinateTypeSeries(state.series, chartType);
      var seriesName = chartType || Object.keys(series)[0];
      var isExist = isSeriesAlreadyExist(series, seriesName, data);

      if (!isExist) {
        series[seriesName].push(data);

        if (Array.isArray(categories) && category) {
          categories.push(category);
        }
      }

      this.dispatch('initThemeState');
      this.dispatch('initLegendState');
      this.notify(state, 'series');

      if (coordinateChart || seriesName === 'bullet') {
        this.dispatch('initCategory');
      }
    },
    addHeatmapSeries: function addHeatmapSeries(_ref17, _ref18) {
      var state = _ref17.state,
          initStoreState = _ref17.initStoreState;
      var data = _ref18.data,
          category = _ref18.category;
      var series = initStoreState.series,
          categories = initStoreState.categories;
      var isExist = isHeatmapSeriesAlreadyExist(categories, category);

      if (!isExist) {
        series.heatmap.push({
          data: data,
          yCategory: category
        });
      }

      if (!isExist && category) {
        categories.y.push(category);
        this.notify(state, 'rawCategories');
      }

      this.notify(state, 'series');
      this.dispatch('initThemeState');
      this.dispatch('initLegendState');
    },
    addTreemapSeries: function addTreemapSeries(_ref19, _ref20) {
      var state = _ref19.state,
          initStoreState = _ref19.initStoreState;
      var data = _ref20.data;
      var series = initStoreState.series;
      var isExist = isTreemapSeriesAlreadyExist(series, data);

      if (!isExist) {
        series.treemap.push(data);
      }

      this.notify(state, 'series');
      this.notify(state, 'treemapSeries');
      this.dispatch('initThemeState');
      this.dispatch('initLegendState');
    },
    setData: function setData(_ref21, _ref22) {
      var state = _ref21.state,
          initStoreState = _ref21.initStoreState;
      var series = _ref22.series,
          categories = _ref22.categories;
      initStoreState.series = series;
      state.rawCategories = makeRawCategories(series, categories);
      this.dispatch('initThemeState');
      this.dispatch('initLegendState');
    }
  },
  observe: {
    updateSeriesData: function updateSeriesData() {
      this.dispatch('setSeriesData');
    }
  },
  computed: {
    isLineTypeSeriesZooming: function isLineTypeSeriesZooming(_ref23) {
      var zoomRange = _ref23.zoomRange,
          rawCategories = _ref23.rawCategories;
      return isZooming(rawCategories, zoomRange);
    },
    viewRange: function viewRange(_ref24) {
      var zoomRange = _ref24.zoomRange,
          shiftRange = _ref24.shiftRange;
      return zoomRange || shiftRange;
    }
  }
};
/* harmony default export */ var store_seriesData = (seriesData_seriesData);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.flat-map.js
var es_array_flat_map = __webpack_require__(38);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.unscopables.flat-map.js
var es_array_unscopables_flat_map = __webpack_require__(39);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.values.js
var es_object_values = __webpack_require__(45);

// CONCATENATED MODULE: ./src/helpers/pieSeries.ts







var semiCircleCenterYRatio = {
  COUNTER_CLOCKWISE: 0.1,
  CLOCKWISE: 1
};
var MINIMUM_RADIUS = 10;
function hasClockwiseSemiCircle(clockwise, startAngle, endAngle) {
  return clockwise && (startAngle >= -90 && endAngle <= 90 || startAngle >= 90 && endAngle <= 180);
}
function hasCounterClockwiseSemiCircle(clockwise, startAngle, endAngle) {
  return !clockwise && (startAngle >= -180 && endAngle <= 90 || startAngle <= 90 && endAngle >= -90);
}
function getRadius(defaultRadius, radius) {
  return isString(radius) ? Number((defaultRadius * getPercentageValue(radius) / 100).toFixed(2)) : radius;
}
function getTotalAngle(clockwise, startAngle, endAngle) {
  var totalAngle = Math.abs(endAngle - startAngle);
  return totalAngle !== 360 && !clockwise ? 360 - totalAngle : totalAngle;
}
function isSemiCircle(clockwise, startAngle, endAngle) {
  return getTotalAngle(clockwise, startAngle, endAngle) <= 180 && (hasClockwiseSemiCircle(clockwise, startAngle, endAngle) || hasCounterClockwiseSemiCircle(clockwise, startAngle, endAngle));
}
function getDefaultRadius(_ref) {
  var width = _ref.width,
      height = _ref.height;
  var isSemiCircular = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var maxDataLabelWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var maxDataLabelHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var result;

  if (isSemiCircular) {
    result = Math.min(width / 2, height) - maxDataLabelHeight;
  } else if (width > height) {
    result = height / 2 - maxDataLabelHeight;
  } else {
    result = width / 2 - maxDataLabelWidth;
  }

  return Math.max(result, MINIMUM_RADIUS);
}
function getSemiCircleCenterY(rectHeight, clockwise) {
  return clockwise ? rectHeight * semiCircleCenterYRatio.CLOCKWISE : rectHeight * semiCircleCenterYRatio.COUNTER_CLOCKWISE;
}
function makePieTooltipData(seriesRawData) {
  var category = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return seriesRawData.filter(function (_ref2) {
    var data = _ref2.data;
    return !isNull(data);
  }).map(function (_ref3) {
    var data = _ref3.data,
        name = _ref3.name,
        color = _ref3.color,
        rootParentName = _ref3.rootParentName;
    return {
      label: name,
      color: color,
      value: data,
      category: category,
      rootParentName: rootParentName,
      templateType: 'pie'
    };
  });
}
function hasNestedPieSeries(series) {
  return !!(series.pie && Array.isArray(series.pie[0].data));
}
function getNestedPieChartAliasNames(series) {
  return series.pie.map(function (_ref4) {
    var name = _ref4.name;
    return name;
  });
}
function pieTooltipLabelFormatter(percentValue) {
  var percentageString = percentValue.toFixed(2);
  var percent = parseFloat(percentageString);
  var needSlice = percentageString.length > 5;
  return "".concat(needSlice ? parseFloat(percentageString.substr(0, 4)) : String(percent), "%");
}
function hasOuterDataLabel(options, series) {
  var _ref5, _options$series;

  return !!series.pie && ((_ref5 = options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.dataLabels) === null || _ref5 === void 0 ? void 0 : _ref5.anchor) === 'outer';
}
function hasOuterPieSeriesName(options, series) {
  var _ref6, _ref6$pieSeriesName, _options$series2;

  return !!series.pie && ((_ref6 = options === null || options === void 0 ? void 0 : (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : _options$series2.dataLabels) === null || _ref6 === void 0 ? void 0 : (_ref6$pieSeriesName = _ref6.pieSeriesName) === null || _ref6$pieSeriesName === void 0 ? void 0 : _ref6$pieSeriesName.anchor) === 'outer';
}
// CONCATENATED MODULE: ./src/helpers/theme.ts









function theme_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function theme_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { theme_ownKeys(Object(source), true).forEach(function (key) { theme_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { theme_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function theme_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var DEFAULT_LINE_SERIES_WIDTH = 2;
var DEFAULT_LINE_SERIES_DOT_RADIUS = 3;
var DEFAULT_AREA_OPACITY = 0.3;
var DEFAULT_AREA_SELECTED_SERIES_OPACITY = DEFAULT_AREA_OPACITY;
var DEFAULT_AREA_UNSELECTED_SERIES_OPACITY = 0.06;
var radarDefault = {
  LINE_WIDTH: 2,
  DOT_RADIUS: 3,
  HOVER_DOT_RADIUS: 4,
  SELECTED_SERIES_OPACITY: 0.3,
  UNSELECTED_SERIES_OPACITY: 0.05
};
var boxDefault = {
  HOVER_THICKNESS: 4,
  BOX_HOVER: {
    shadowColor: 'rgba(0, 0, 0, 0.3)',
    shadowOffsetX: 2,
    shadowOffsetY: 2,
    shadowBlur: 6
  }
};
var boxplotDefault = {
  OUTLIER_RADIUS: 4,
  OUTLIER_BORDER_WIDTH: 2,
  LINE_TYPE: {
    whisker: {
      lineWidth: 1
    },
    maximum: {
      lineWidth: 1
    },
    minimum: {
      lineWidth: 1
    },
    median: {
      lineWidth: 1,
      color: '#ffffff'
    }
  }
};
var DEFAULT_BULLET_RANGE_OPACITY = [0.5, 0.3, 0.1];
var DEFAULT_PIE_LINE_WIDTH = 3;

function makeDefaultDataLabelsTheme() {
  var globalFontFamily = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Arial';
  return {
    fontFamily: globalFontFamily,
    fontSize: 11,
    fontWeight: 400,
    color: '#333333',
    useSeriesColor: false
  };
}

var DEFAULT_BUBBLE_ARROW = {
  width: 8,
  height: 6
};
var defaultSeriesTheme = {
  colors: ['#00a9ff', '#ffb840', '#ff5a46', '#00bd9f', '#785fff', '#f28b8c', '#989486', '#516f7d', '#29dbe3', '#dddddd', '#64e38b', '#e3b664', '#fB826e', '#64e3C2', '#f66efb', '#e3cd64', '#82e364', '#8570ff', '#e39e64', '#fa5643', '#7a4b46', '#81b1c7', '#257a6c', '#58527a', '#fbb0b0', '#c7c7c7'],
  startColor: '#ffe98a',
  endColor: '#d74177',
  lineWidth: DEFAULT_LINE_SERIES_WIDTH,
  dashSegments: [],
  borderWidth: 0,
  borderColor: '#ffffff',
  select: {
    dot: {
      radius: DEFAULT_LINE_SERIES_DOT_RADIUS,
      borderWidth: DEFAULT_LINE_SERIES_DOT_RADIUS + 2
    },
    areaOpacity: DEFAULT_AREA_SELECTED_SERIES_OPACITY,
    restSeries: {
      areaOpacity: DEFAULT_AREA_UNSELECTED_SERIES_OPACITY
    }
  },
  hover: {
    dot: {
      radius: DEFAULT_LINE_SERIES_DOT_RADIUS,
      borderWidth: DEFAULT_LINE_SERIES_DOT_RADIUS + 2
    }
  },
  dot: {
    radius: DEFAULT_LINE_SERIES_DOT_RADIUS
  },
  areaOpacity: DEFAULT_AREA_OPACITY
};
function makeAxisTitleTheme() {
  var globalFontFamily = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Arial';
  return {
    fontSize: 11,
    fontFamily: globalFontFamily,
    fontWeight: 700,
    color: '#bbbbbb'
  };
}

function makeCommonTextTheme() {
  var globalFontFamily = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Arial';
  return {
    fontSize: 11,
    fontFamily: globalFontFamily,
    fontWeight: 'normal',
    color: '#333333'
  };
}

function makeDefaultTheme() {
  var globalFontFamily = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Arial';
  var axisTitleTheme = makeAxisTitleTheme(globalFontFamily);
  var commonTextTheme = makeCommonTextTheme(globalFontFamily);
  return {
    chart: {
      fontFamily: globalFontFamily,
      backgroundColor: '#ffffff'
    },
    title: {
      fontSize: 18,
      fontFamily: globalFontFamily,
      fontWeight: 100,
      color: '#333333'
    },
    yAxis: {
      title: theme_objectSpread({}, axisTitleTheme),
      label: theme_objectSpread({}, commonTextTheme),
      width: 1,
      color: '#333333'
    },
    xAxis: {
      title: theme_objectSpread({}, axisTitleTheme),
      label: theme_objectSpread({}, commonTextTheme),
      width: 1,
      color: '#333333'
    },
    legend: {
      label: {
        color: '#333333',
        fontSize: 11,
        fontWeight: 'normal',
        fontFamily: globalFontFamily
      }
    },
    tooltip: {
      background: 'rgba(85, 85, 85, 0.95)',
      borderColor: 'rgba(255, 255, 255, 0)',
      borderWidth: 0,
      borderRadius: 3,
      borderStyle: 'solid',
      body: {
        fontSize: 12,
        fontFamily: "".concat(globalFontFamily, ", sans-serif"),
        fontWeight: 'normal',
        color: '#ffffff'
      },
      header: {
        fontSize: 13,
        fontFamily: "".concat(globalFontFamily, ", sans-serif"),
        fontWeight: 'bold',
        color: '#ffffff'
      }
    },
    plot: {
      lineColor: 'rgba(0, 0, 0, 0.05)',
      backgroundColor: 'rgba(255, 255, 255, 0)'
    },
    exportMenu: {
      button: theme_objectSpread(theme_objectSpread({}, makeBorderTheme(5, '#f4f4f4')), {}, {
        backgroundColor: '#f4f4f4',
        xIcon: {
          color: '#555555',
          lineWidth: 2
        },
        dotIcon: {
          color: '#555555',
          width: 2,
          height: 2,
          gap: 2
        }
      }),
      panel: theme_objectSpread(theme_objectSpread({}, makeBorderTheme(0, '#bab9ba')), {}, {
        header: theme_objectSpread(theme_objectSpread({}, commonTextTheme), {}, {
          backgroundColor: '#f4f4f4'
        }),
        body: theme_objectSpread(theme_objectSpread({}, commonTextTheme), {}, {
          backgroundColor: '#ffffff'
        })
      })
    }
  };
}

function makeBorderTheme(borderRadius, borderColor) {
  var borderWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return {
    borderWidth: borderWidth,
    borderRadius: borderRadius,
    borderColor: borderColor
  };
}

function makeDefaultTextBubbleTheme() {
  var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var borderRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 7;
  var paddingX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;
  var paddingY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var backgroundColor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '#ffffff';
  return {
    visible: visible,
    paddingX: paddingX,
    paddingY: paddingY,
    borderRadius: borderRadius,
    backgroundColor: backgroundColor,
    shadowColor: 'rgba(0, 0, 0, 0.3)',
    shadowOffsetY: 2,
    shadowBlur: 4
  };
} // eslint-disable-next-line complexity


function getSeriesTheme(globalFontFamily, seriesName, _ref) {
  var _ref$hasOuterAnchor = _ref.hasOuterAnchor,
      hasOuterAnchor = _ref$hasOuterAnchor === void 0 ? false : _ref$hasOuterAnchor,
      _ref$hasOuterAnchorPi = _ref.hasOuterAnchorPieSeriesName,
      hasOuterAnchorPieSeriesName = _ref$hasOuterAnchorPi === void 0 ? false : _ref$hasOuterAnchorPi;
  var isNestedPieChart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
  var lineTypeSeriesTheme = {
    lineWidth: defaultSeriesTheme.lineWidth,
    dashSegments: defaultSeriesTheme.dashSegments,
    select: {
      dot: defaultSeriesTheme.select.dot
    },
    hover: {
      dot: defaultSeriesTheme.hover.dot
    },
    dot: defaultSeriesTheme.dot,
    dataLabels: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
      textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme()), {}, {
        arrow: theme_objectSpread({
          visible: false,
          direction: 'bottom'
        }, DEFAULT_BUBBLE_ARROW)
      })
    })
  };
  var transparentColor = 'rgba(255, 255, 255, 0)';

  switch (seriesName) {
    case 'line':
      return theme_objectSpread({}, lineTypeSeriesTheme);

    case 'area':
      return theme_objectSpread(theme_objectSpread({}, lineTypeSeriesTheme), {}, {
        select: theme_objectSpread(theme_objectSpread({}, lineTypeSeriesTheme.select), {}, {
          areaOpacity: DEFAULT_AREA_SELECTED_SERIES_OPACITY,
          restSeries: defaultSeriesTheme.select.restSeries
        }),
        areaOpacity: DEFAULT_AREA_OPACITY
      });

    case 'treemap':
    case 'heatmap':
      return {
        startColor: defaultSeriesTheme.startColor,
        endColor: defaultSeriesTheme.endColor,
        borderWidth: 0,
        borderColor: '#ffffff',
        hover: {
          borderWidth: boxDefault.HOVER_THICKNESS,
          borderColor: '#ffffff'
        },
        select: {
          borderWidth: boxDefault.HOVER_THICKNESS,
          borderColor: '#ffffff'
        },
        dataLabels: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
          color: '#ffffff',
          textBubble: theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 1, 5, 1, 'rgba(255, 255, 255, 0.5)'))
        })
      };

    case 'scatter':
      return {
        size: 12,
        borderWidth: 1.5,
        fillColor: transparentColor,
        select: {
          fillColor: 'rgba(255, 255, 255, 1)',
          borderWidth: 2.5,
          size: 12
        },
        hover: {
          fillColor: 'rgba(255, 255, 255, 1)',
          borderWidth: 2.5,
          size: 12
        }
      };

    case 'bubble':
      return {
        borderWidth: 0,
        borderColor: transparentColor,
        select: {},
        hover: {
          shadowColor: 'rgba(0, 0, 0, 0.3)',
          shadowBlur: 2,
          shadowOffsetY: 2,
          lineWidth: 2
        }
      };

    case 'radar':
      return {
        areaOpacity: radarDefault.SELECTED_SERIES_OPACITY,
        hover: {
          dot: {
            radius: radarDefault.HOVER_DOT_RADIUS,
            borderWidth: radarDefault.HOVER_DOT_RADIUS + 1
          }
        },
        select: {
          dot: {
            radius: radarDefault.HOVER_DOT_RADIUS,
            borderWidth: radarDefault.HOVER_DOT_RADIUS + 1
          },
          restSeries: {
            areaOpacity: radarDefault.UNSELECTED_SERIES_OPACITY
          },
          areaOpacity: radarDefault.SELECTED_SERIES_OPACITY
        },
        dot: {
          radius: radarDefault.DOT_RADIUS
        }
      };

    case 'bar':
    case 'column':
      return {
        colorByPoint: false,
        areaOpacity: 1,
        hover: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
          borderWidth: boxDefault.HOVER_THICKNESS,
          borderColor: '#ffffff',
          groupedRect: {
            color: '#000000',
            opacity: 0.05
          }
        }),
        select: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
          borderWidth: boxDefault.HOVER_THICKNESS,
          borderColor: '#ffffff',
          groupedRect: {
            color: '#000000',
            opacity: 0.2
          },
          restSeries: {
            areaOpacity: 0.2
          },
          areaOpacity: 1
        }),
        connector: {
          color: 'rgba(51, 85, 139, 0.3)',
          lineWidth: 1,
          dashSegments: []
        },
        dataLabels: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
          textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 1, 4, 3)), {}, {
            arrow: theme_objectSpread({
              visible: false
            }, DEFAULT_BUBBLE_ARROW)
          }),
          stackTotal: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
            textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme(true, 1, 4, 3)), {}, {
              arrow: theme_objectSpread({
                visible: true
              }, DEFAULT_BUBBLE_ARROW)
            })
          })
        })
      };

    case 'bullet':
      return {
        areaOpacity: 1,
        barWidthRatios: {
          rangeRatio: 1,
          bulletRatio: 0.5,
          markerRatio: 0.8
        },
        markerLineWidth: 1,
        borderWidth: 0,
        borderColor: 'rgba(255, 255, 255, 0)',
        hover: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
          borderWidth: boxDefault.HOVER_THICKNESS,
          borderColor: '#ffffff',
          groupedRect: {
            color: '#000000',
            opacity: 0.05
          }
        }),
        select: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
          borderWidth: boxDefault.HOVER_THICKNESS,
          borderColor: '#ffffff',
          groupedRect: {
            color: '#000000',
            opacity: 0.2
          },
          restSeries: {
            areaOpacity: 0.2
          },
          areaOpacity: 1
        }),
        dataLabels: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
          textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme()), {}, {
            arrow: theme_objectSpread({
              visible: false
            }, DEFAULT_BUBBLE_ARROW)
          }),
          marker: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
            fontSize: 9,
            useSeriesColor: true,
            textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme(true)), {}, {
              backgroundColor: 'rgba(255, 255, 255, 0.8)',
              shadowColor: 'rgba(0, 0, 0, 0.0)',
              shadowOffsetX: 0,
              shadowOffsetY: 0,
              shadowBlur: 0,
              arrow: theme_objectSpread({
                visible: false
              }, DEFAULT_BUBBLE_ARROW)
            })
          })
        })
      };

    case 'boxPlot':
      return {
        areaOpacity: 1,
        barWidthRatios: {
          barRatio: 1,
          minMaxBarRatio: 0.5
        },
        markerLineWidth: 1,
        dot: {
          color: '#ffffff',
          radius: boxplotDefault.OUTLIER_RADIUS,
          borderWidth: boxplotDefault.OUTLIER_BORDER_WIDTH,
          useSeriesColor: false
        },
        rect: {
          borderWidth: 0
        },
        line: theme_objectSpread({}, boxplotDefault.LINE_TYPE),
        hover: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
          rect: {
            borderWidth: boxDefault.HOVER_THICKNESS,
            borderColor: '#ffffff'
          },
          dot: {
            radius: boxplotDefault.OUTLIER_RADIUS,
            borderWidth: 0,
            useSeriesColor: true
          },
          line: theme_objectSpread({}, boxplotDefault.LINE_TYPE)
        }),
        select: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
          rect: {
            borderWidth: boxDefault.HOVER_THICKNESS,
            borderColor: '#ffffff'
          },
          dot: {
            radius: boxplotDefault.OUTLIER_RADIUS,
            borderWidth: 0,
            useSeriesColor: true
          },
          line: theme_objectSpread({}, boxplotDefault.LINE_TYPE),
          restSeries: {
            areaOpacity: 0.2
          },
          areaOpacity: 1
        })
      };

    case 'pie':
      return {
        areaOpacity: 1,
        strokeStyle: isNestedPieChart ? '#ffffff' : 'rgba(255, 255, 255, 0)',
        lineWidth: isNestedPieChart ? 1 : 0,
        hover: {
          lineWidth: DEFAULT_PIE_LINE_WIDTH,
          strokeStyle: '#ffffff',
          shadowColor: '#cccccc',
          shadowBlur: 5,
          shadowOffsetX: 0,
          shadowOffsetY: 0
        },
        select: {
          lineWidth: DEFAULT_PIE_LINE_WIDTH,
          strokeStyle: '#ffffff',
          shadowColor: '#cccccc',
          shadowBlur: 5,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          restSeries: {
            areaOpacity: 0.3
          },
          areaOpacity: 1
        },
        dataLabels: {
          fontFamily: 'Arial',
          fontSize: 16,
          fontWeight: 600,
          color: hasOuterAnchor ? '#333333' : '#ffffff',
          useSeriesColor: hasOuterAnchor,
          textBubble: theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 0)),
          callout: {
            lineWidth: 1,
            useSeriesColor: true,
            lineColor: '#e9e9e9'
          },
          pieSeriesName: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
            useSeriesColor: hasOuterAnchorPieSeriesName,
            color: hasOuterAnchorPieSeriesName ? '#333333' : '#ffffff',
            textBubble: theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 0))
          })
        }
      };

    default:
      return {};
  }
}

function getDefaultTheme(globalFontFamily, series, pieSeriesOuterAnchors) {
  var isNestedPieChart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var result = Object.keys(series).reduce(function (acc, seriesName) {
    return theme_objectSpread(theme_objectSpread({}, acc), {}, {
      series: theme_objectSpread(theme_objectSpread({}, acc.series), {}, theme_defineProperty({}, seriesName, getSeriesTheme(globalFontFamily, seriesName, pieSeriesOuterAnchors)))
    });
  }, makeDefaultTheme(globalFontFamily));

  if (isNestedPieChart) {
    var aliasNames = getNestedPieChartAliasNames(series);
    result.series.pie = aliasNames.reduce(function (acc, cur) {
      return theme_objectSpread(theme_objectSpread({}, acc), {}, theme_defineProperty({}, cur, getSeriesTheme(globalFontFamily, 'pie', pieSeriesOuterAnchors[cur], isNestedPieChart)));
    }, {});
  }

  return result;
}
// CONCATENATED MODULE: ./src/store/legend.ts

























function legend_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function legend_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { legend_ownKeys(Object(source), true).forEach(function (key) { legend_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { legend_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function legend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function legend_toConsumableArray(arr) { return legend_arrayWithoutHoles(arr) || legend_iterableToArray(arr) || legend_unsupportedIterableToArray(arr) || legend_nonIterableSpread(); }

function legend_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function legend_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return legend_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return legend_arrayLikeToArray(o, minLen); }

function legend_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function legend_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return legend_arrayLikeToArray(arr); }

function legend_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }











function calculateLegendWidth(_ref) {
  var defaultWidth = _ref.defaultWidth,
      legendWidths = _ref.legendWidths,
      useSpectrumLegend = _ref.useSpectrumLegend,
      options = _ref.options,
      align = _ref.align,
      visible = _ref.visible,
      checkbox = _ref.checkbox;
  var verticalAlign = isVerticalAlign(align);
  var legendOptions = options === null || options === void 0 ? void 0 : options.legend;
  var legendWidth = defaultWidth;

  if (!visible) {
    return 0;
  }

  if (legendOptions === null || legendOptions === void 0 ? void 0 : legendOptions.width) {
    return legendOptions.width;
  }

  if (useSpectrumLegend && verticalAlign) {
    var labelAreaWidth = sum(legendWidths);
    legendWidth = Math.max(getInitialWidth(options) / 4, labelAreaWidth);
  } else if (useSpectrumLegend && !verticalAlign) {
    var spectrumAreaWidth = spectrumLegendTooltip.PADDING * 2 + spectrumLegendBar.PADDING * 2 + spectrumLegendTooltip.POINT_HEIGHT + spectrumLegendBar.HEIGHT + layout_padding.X * 2;
    legendWidth = Math.max.apply(Math, legend_toConsumableArray(legendWidths)) + spectrumAreaWidth;
  } else if (!useSpectrumLegend && verticalAlign) {
    legendWidth = sum(legendWidths) + LEGEND_ITEM_MARGIN_X * (legendWidths.length - 1);
  } else {
    var _labelAreaWidth = Math.max.apply(Math, legend_toConsumableArray(legendWidths));

    legendWidth = (checkbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) + LEGEND_ICON_SIZE + LEGEND_MARGIN_X + Math.max(_labelAreaWidth, legendWidth);
  }

  return legendWidth;
}

function showCircleLegend(options) {
  var _options$circleLegend, _options$circleLegend2;

  return isUndefined(options === null || options === void 0 ? void 0 : (_options$circleLegend = options.circleLegend) === null || _options$circleLegend === void 0 ? void 0 : _options$circleLegend.visible) ? true : !!(options === null || options === void 0 ? void 0 : (_options$circleLegend2 = options.circleLegend) === null || _options$circleLegend2 === void 0 ? void 0 : _options$circleLegend2.visible);
}

function showLegend(options, series) {
  var _ref2, _options$legend, _options$legend2;

  if (series.treemap && !((_ref2 = options.series) === null || _ref2 === void 0 ? void 0 : _ref2.useColorValue)) {
    return false;
  }

  return isUndefined((_options$legend = options.legend) === null || _options$legend === void 0 ? void 0 : _options$legend.visible) ? true : !!((_options$legend2 = options.legend) === null || _options$legend2 === void 0 ? void 0 : _options$legend2.visible);
}

function legend_showCheckbox(options) {
  var _options$legend3, _options$legend4;

  return isUndefined((_options$legend3 = options.legend) === null || _options$legend3 === void 0 ? void 0 : _options$legend3.showCheckbox) ? true : !!((_options$legend4 = options.legend) === null || _options$legend4 === void 0 ? void 0 : _options$legend4.showCheckbox);
}

function getNestedPieLegendLabels(series) {
  var result = [];
  series.pie.forEach(function (_ref3) {
    var data = _ref3.data;
    data.forEach(function (_ref4) {
      var name = _ref4.name,
          parentName = _ref4.parentName;

      if (!parentName) {
        result.push({
          label: name,
          type: 'pie'
        });
      }
    });
  });
  return result;
}

function getLegendLabels(series) {
  return Object.keys(series).flatMap(function (type) {
    return series[type].map(function (_ref5) {
      var name = _ref5.name,
          colorValue = _ref5.colorValue;
      return {
        label: colorValue ? colorValue : name,
        type: type
      };
    });
  });
}

function useRectIcon(type) {
  return includes(['bar', 'column', 'area', 'pie', 'boxPlot', 'bullet'], type);
}

function useCircleIcon(type) {
  return includes(['bubble', 'scatter'], type);
}

function useLineIcon(type) {
  return includes(['line', 'radar'], type);
}

function getIconType(type) {
  var iconType = 'spectrum';

  if (useCircleIcon(type)) {
    iconType = 'circle';
  } else if (useRectIcon(type)) {
    iconType = 'rect';
  } else if (useLineIcon(type)) {
    iconType = 'line';
  }

  return iconType;
}

function getAlign(options) {
  var _options$legend5, _options$legend6;

  return isUndefined((_options$legend5 = options.legend) === null || _options$legend5 === void 0 ? void 0 : _options$legend5.align) ? 'right' : (_options$legend6 = options.legend) === null || _options$legend6 === void 0 ? void 0 : _options$legend6.align;
}

function getItemWidth(label, checkboxVisible, useSpectrumLegend, font) {
  return (useSpectrumLegend ? 0 : (checkboxVisible ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) + LEGEND_ICON_SIZE + LEGEND_MARGIN_X) + getTextWidth(label, font);
}

function getInitialWidth(options) {
  var _options$chart;

  return isNumber((_options$chart = options.chart) === null || _options$chart === void 0 ? void 0 : _options$chart.width) ? options.chart.width : 0;
}

function getLegendDataAppliedTheme(data, series) {
  var colors = Object.values(series).reduce(function (acc, cur) {
    return cur && cur.colors ? [].concat(legend_toConsumableArray(acc), legend_toConsumableArray(cur.colors)) : acc;
  }, []);
  return data.map(function (datum, idx) {
    return legend_objectSpread(legend_objectSpread({}, datum), {}, {
      color: colors[idx]
    });
  });
}

function getLegendState(options, series) {
  var _useColorValue, _ref6, _options$theme, _options$theme$chart, _options$theme2, _options$theme2$legen;

  var checkboxVisible = legend_showCheckbox(options);
  var useSpectrumLegend = (_useColorValue = (_ref6 = options === null || options === void 0 ? void 0 : options.series) === null || _ref6 === void 0 ? void 0 : _ref6.useColorValue) !== null && _useColorValue !== void 0 ? _useColorValue : !!series.heatmap;
  var useScatterChartIcon = !!(series === null || series === void 0 ? void 0 : series.scatter);
  var defaultTheme = makeDefaultTheme(options === null || options === void 0 ? void 0 : (_options$theme = options.theme) === null || _options$theme === void 0 ? void 0 : (_options$theme$chart = _options$theme.chart) === null || _options$theme$chart === void 0 ? void 0 : _options$theme$chart.fontFamily);
  var font = getTitleFontString(deepMergedCopy(defaultTheme.legend.label, legend_objectSpread({}, (_options$theme2 = options.theme) === null || _options$theme2 === void 0 ? void 0 : (_options$theme2$legen = _options$theme2.legend) === null || _options$theme2$legen === void 0 ? void 0 : _options$theme2$legen.label)));
  var legendLabels = hasNestedPieSeries(series) ? getNestedPieLegendLabels(series) : getLegendLabels(series);
  var data = legendLabels.map(function (_ref7) {
    var label = _ref7.label,
        type = _ref7.type;
    return {
      label: label,
      active: true,
      checked: true,
      width: getItemWidth(label, checkboxVisible, useSpectrumLegend, font),
      iconType: getIconType(type),
      chartType: type
    };
  });
  return {
    useSpectrumLegend: useSpectrumLegend,
    useScatterChartIcon: useScatterChartIcon,
    data: data
  };
}

var store_legend_legend = {
  name: 'legend',
  state: function state(_ref8) {
    var options = _ref8.options,
        series = _ref8.series;
    return {
      legend: getLegendState(options, series),
      circleLegend: {}
    };
  },
  action: {
    initLegendState: function initLegendState(_ref9) {
      var state = _ref9.state,
          initStoreState = _ref9.initStoreState;
      store_extend(state.legend, getLegendState(initStoreState.options, initStoreState.series));
    },
    setLegendLayout: function setLegendLayout(_ref10) {
      var state = _ref10.state,
          initStoreState = _ref10.initStoreState;
      var _state$legend = state.legend,
          legendData = _state$legend.data,
          useSpectrumLegend = _state$legend.useSpectrumLegend,
          series = state.series,
          options = state.options;
      var align = getAlign(options);
      var visible = showLegend(options, series);
      var checkbox = legend_showCheckbox(options);
      var initialWidth = Math.min(getInitialWidth(options) / 10, 150);
      var legendWidths = legendData.map(function (_ref11) {
        var width = _ref11.width;
        return width;
      });
      var legendWidth = calculateLegendWidth({
        defaultWidth: initialWidth,
        legendWidths: legendWidths,
        useSpectrumLegend: useSpectrumLegend,
        options: options,
        align: align,
        visible: visible,
        checkbox: checkbox
      });
      var isNestedPieChart = hasNestedPieSeries(initStoreState.series);
      var isScatterChart = !!series.scatter;
      var circleLegendWidth = isVerticalAlign(align) ? initialWidth : Math.max(initialWidth, legendWidth);
      var circleLegendVisible = series.bubble ? showCircleLegend(options) : false;
      store_extend(state.legend, {
        visible: visible,
        align: align,
        showCheckbox: checkbox,
        width: legendWidth
      });
      store_extend(state.circleLegend, {
        visible: circleLegendVisible,
        width: circleLegendVisible ? circleLegendWidth : 0,
        radius: circleLegendVisible ? Math.max((circleLegendWidth - LEGEND_MARGIN_X) / 2, 0) : 0
      });

      if (!isNestedPieChart) {
        this.dispatch('updateLegendColor');
      }

      if (isScatterChart) {
        this.dispatch('updateLegendIcon');
      }
    },
    setLegendActiveState: function setLegendActiveState(_ref12, _ref13) {
      var state = _ref12.state;
      var name = _ref13.name,
          active = _ref13.active;
      var data = state.legend.data;
      var model = data.find(function (_ref14) {
        var label = _ref14.label;
        return label === name;
      });
      model.active = active;
      this.notify(state, 'legend');
    },
    setAllLegendActiveState: function setAllLegendActiveState(_ref15, active) {
      var state = _ref15.state;
      state.legend.data.forEach(function (datum) {
        datum.active = active;
      });
      this.notify(state, 'legend');
    },
    setLegendCheckedState: function setLegendCheckedState(_ref16, _ref17) {
      var state = _ref16.state;
      var name = _ref17.name,
          checked = _ref17.checked;
      var model = state.legend.data.find(function (_ref18) {
        var label = _ref18.label;
        return label === name;
      });
      model.checked = checked;
      this.notify(state, 'legend');
    },
    updateLegendColor: function updateLegendColor(_ref19) {
      var _useColorValue2, _ref20;

      var state = _ref19.state;
      var legendData = state.legend,
          series = state.series,
          options = state.options;
      var useSpectrumLegend = (_useColorValue2 = (_ref20 = options === null || options === void 0 ? void 0 : options.series) === null || _ref20 === void 0 ? void 0 : _ref20.useColorValue) !== null && _useColorValue2 !== void 0 ? _useColorValue2 : !!series.heatmap;
      var data = useSpectrumLegend ? legendData.data : getLegendDataAppliedTheme(legendData.data, series);
      store_extend(state.legend, {
        data: data
      });
    },
    updateLegendIcon: function updateLegendIcon(_ref21) {
      var state = _ref21.state;
      var legendData = state.legend,
          series = state.series;
      var data = legendData.data.reduce(function (acc, cur) {
        var _series$scatter;

        if (cur.chartType === 'scatter' && ((_series$scatter = series.scatter) === null || _series$scatter === void 0 ? void 0 : _series$scatter.data)) {
          var model = series.scatter.data.find(function (_ref22) {
            var name = _ref22.name;
            return name === cur.label;
          });
          var iconType = model ? model.iconType : cur.iconType;
          return [].concat(legend_toConsumableArray(acc), [legend_objectSpread(legend_objectSpread({}, cur), {}, {
            iconType: iconType
          })]);
        }

        return [].concat(legend_toConsumableArray(acc), [cur]);
      }, []);
      store_extend(state.legend, {
        data: data
      });
    },
    updateNestedPieChartLegend: function updateNestedPieChartLegend(_ref23) {
      var state = _ref23.state;
      var legendData = state.legend,
          nestedPieSeries = state.nestedPieSeries;
      store_extend(state.legend, {
        data: getLegendDataAppliedTheme(legendData.data, nestedPieSeries)
      });
    }
  },
  observe: {
    updateLegendLayout: function updateLegendLayout() {
      this.dispatch('setLegendLayout');
    }
  }
};
/* harmony default export */ var store_legend = (store_legend_legend);
// CONCATENATED MODULE: ./src/store/options.ts



function getOptionsBySize(size, options) {
  var _options$responsive;

  var rules = (_options$responsive = options.responsive) === null || _options$responsive === void 0 ? void 0 : _options$responsive.rules;
  return Array.isArray(rules) ? rules.reduce(function (acc, cur) {
    return cur.condition(size) ? deepMergedCopy(acc, cur.options) : acc;
  }, options) : options;
}

function getSize(usingContainerSize, containerSize, chartSize) {
  var usingContainerWidth = usingContainerSize.width,
      usingContainerHeight = usingContainerSize.height;
  return {
    width: usingContainerWidth ? containerSize.width : chartSize === null || chartSize === void 0 ? void 0 : chartSize.width,
    height: usingContainerHeight ? containerSize.height : chartSize === null || chartSize === void 0 ? void 0 : chartSize.height
  };
}

var optionsData = {
  name: 'options',
  state: function state(_ref) {
    var options = _ref.options;
    return {
      originalOptions: deepCopy(options),
      options: options
    };
  },
  action: {
    setOptions: function setOptions(_ref2) {
      var state = _ref2.state;
      var _state$chart = state.chart,
          width = _state$chart.width,
          height = _state$chart.height;

      if (width < 0 || height < 0) {
        return;
      }

      state.options = getOptionsBySize({
        width: width,
        height: height
      }, state.originalOptions);
    },
    initOptions: function initOptions(_ref3, _ref4) {
      var initStoreState = _ref3.initStoreState,
          state = _ref3.state;
      var options = _ref4.options,
          containerSize = _ref4.containerSize;
      initStoreState.options = options;
      state.originalOptions = deepCopy(options);
      var usingContainerSize = state.usingContainerSize,
          originalOptions = state.originalOptions;
      var size = getSize(usingContainerSize, containerSize, {
        width: originalOptions.chart.width,
        height: originalOptions.chart.height
      });
      this.dispatch('setChartSize', size);
    },
    updateOptions: function updateOptions(_ref5, _ref6) {
      var _originalOptions$char, _originalOptions$char2;

      var state = _ref5.state,
          initStoreState = _ref5.initStoreState;
      var options = _ref6.options,
          containerSize = _ref6.containerSize;
      initStoreState.options = deepMergedCopy(initStoreState.options, options);
      state.originalOptions = deepMergedCopy(state.originalOptions, options);
      var usingContainerSize = state.usingContainerSize,
          originalOptions = state.originalOptions;
      var size = getSize(usingContainerSize, containerSize, {
        width: (_originalOptions$char = originalOptions.chart) === null || _originalOptions$char === void 0 ? void 0 : _originalOptions$char.width,
        height: (_originalOptions$char2 = originalOptions.chart) === null || _originalOptions$char2 === void 0 ? void 0 : _originalOptions$char2.height
      });
      this.dispatch('setChartSize', size);
      this.dispatch('initThemeState');
    }
  },
  observe: {
    updateOptions: function updateOptions() {
      this.dispatch('setOptions');
    }
  }
};
/* harmony default export */ var store_options = (optionsData);
// CONCATENATED MODULE: ./src/store/theme.ts






















function theme_toConsumableArray(arr) { return theme_arrayWithoutHoles(arr) || theme_iterableToArray(arr) || theme_unsupportedIterableToArray(arr) || theme_nonIterableSpread(); }

function theme_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function theme_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return theme_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return theme_arrayLikeToArray(o, minLen); }

function theme_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function theme_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return theme_arrayLikeToArray(arr); }

function theme_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function store_theme_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function store_theme_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { store_theme_ownKeys(Object(source), true).forEach(function (key) { store_theme_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { store_theme_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function store_theme_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





function getCommonSeriesOptions(options, series, isNestedPieChart) {
  var theme = options === null || options === void 0 ? void 0 : options.theme;

  if (!(theme === null || theme === void 0 ? void 0 : theme.series)) {
    return {};
  }

  var seriesNames = isNestedPieChart ? getNestedPieChartAliasNames(series) : Object.keys(series);
  return seriesNames.reduce(function (acc, seriesName) {
    delete acc[seriesName];
    return acc;
  }, store_theme_objectSpread({}, theme.series));
}

function getThemeAppliedSecondaryYAxis(options) {
  var _options$theme, _options$theme$chart;

  var theme = store_theme_objectSpread({}, options.theme);

  if (!Array.isArray(theme.yAxis)) {
    return theme;
  }

  var axisTitleTheme = makeAxisTitleTheme(options === null || options === void 0 ? void 0 : (_options$theme = options.theme) === null || _options$theme === void 0 ? void 0 : (_options$theme$chart = _options$theme.chart) === null || _options$theme$chart === void 0 ? void 0 : _options$theme$chart.fontFamily);
  var yAxis = theme.yAxis.map(function (yAxisTheme) {
    return deepMergedCopy({
      title: store_theme_objectSpread({}, axisTitleTheme)
    }, store_theme_objectSpread({}, yAxisTheme));
  });
  return store_theme_objectSpread(store_theme_objectSpread({}, theme), {}, {
    yAxis: yAxis
  });
}

function getThemeOptionsWithSeriesName(options, series, commonSeriesOptions, isNestedPieChart) {
  var theme = getThemeAppliedSecondaryYAxis(options);

  if (!(theme === null || theme === void 0 ? void 0 : theme.series)) {
    return store_theme_objectSpread({}, theme);
  }

  var seriesTheme = store_theme_objectSpread(store_theme_objectSpread({}, theme), {}, {
    series: {}
  });

  var seriesNames = Object.keys(series);
  var isComboChart = seriesNames.length > 1;

  if (isNestedPieChart) {
    var aliasNames = getNestedPieChartAliasNames(series);
    seriesTheme.series = {
      pie: aliasNames.reduce(function (acc, aliasName) {
        var _theme$series;

        return store_theme_objectSpread(store_theme_objectSpread({}, acc), {}, store_theme_defineProperty({}, aliasName, deepMergedCopy((_theme$series = theme.series) === null || _theme$series === void 0 ? void 0 : _theme$series[aliasName], omit(commonSeriesOptions, 'colors'))));
      }, {})
    };
  } else if (isComboChart) {
    seriesTheme.series = store_theme_objectSpread({}, seriesNames.reduce(function (acc, seriesName) {
      var _theme$series2;

      return store_theme_objectSpread(store_theme_objectSpread({}, acc), {}, store_theme_defineProperty({}, seriesName, deepMergedCopy((_theme$series2 = theme.series) === null || _theme$series2 === void 0 ? void 0 : _theme$series2[seriesName], omit(commonSeriesOptions, 'colors'))));
    }, {}));
  } else {
    seriesTheme.series = store_theme_defineProperty({}, seriesNames[0], theme.series);
  }

  return seriesTheme;
}

function setColors(theme, series, commonSeriesOptions, isNestedPieChart) {
  var _ref;

  var index = 0;
  var commonColorsOption = [].concat(theme_toConsumableArray((_ref = commonSeriesOptions === null || commonSeriesOptions === void 0 ? void 0 : commonSeriesOptions.colors) !== null && _ref !== void 0 ? _ref : []), theme_toConsumableArray(defaultSeriesTheme.colors));
  var themeNames = isNestedPieChart ? getNestedPieChartAliasNames(series) : Object.keys(series);
  themeNames.forEach(function (name, idx) {
    var _target$name;

    var size = isNestedPieChart ? series.pie[idx].data.length : series[name].length;
    var target = isNestedPieChart ? theme.series.pie : theme.series;

    if (!((_target$name = target[name]) === null || _target$name === void 0 ? void 0 : _target$name.colors)) {
      target[name] = store_theme_objectSpread(store_theme_objectSpread({}, target[name]), {}, {
        colors: commonColorsOption.slice(index, index + size)
      });
      index += size;
    }
  });
}

function theme_setPlot(theme) {
  ['vertical', 'horizontal'].reduce(function (acc, cur) {
    if (!acc[cur]) {
      acc[cur] = {
        lineColor: acc.lineColor
      };
    }

    return acc;
  }, theme.plot);
}

function checkAnchorPieSeriesOption(options, series, alias) {
  var _options$series, _options$series$alias, _options$series$alias2, _options$series2, _options$series2$alia, _options$series2$alia2, _options$series2$alia3;

  return {
    hasOuterAnchor: !!series.pie && (options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : (_options$series$alias = _options$series[alias]) === null || _options$series$alias === void 0 ? void 0 : (_options$series$alias2 = _options$series$alias.dataLabels) === null || _options$series$alias2 === void 0 ? void 0 : _options$series$alias2.anchor) === 'outer',
    hasOuterAnchorPieSeriesName: !!series.pie && (options === null || options === void 0 ? void 0 : (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : (_options$series2$alia = _options$series2[alias]) === null || _options$series2$alia === void 0 ? void 0 : (_options$series2$alia2 = _options$series2$alia.dataLabels) === null || _options$series2$alia2 === void 0 ? void 0 : (_options$series2$alia3 = _options$series2$alia2.pieSeriesName) === null || _options$series2$alia3 === void 0 ? void 0 : _options$series2$alia3.anchor) === 'outer'
  };
}

function getTheme(options, series) {
  var _options$theme2, _options$theme2$chart;

  var isNestedPieChart = hasNestedPieSeries(series);
  var commonSeriesOptions = getCommonSeriesOptions(options, series, isNestedPieChart);
  var pieSeriesOuterAnchors = {
    hasOuterAnchor: hasOuterDataLabel(options, series),
    hasOuterAnchorPieSeriesName: hasOuterPieSeriesName(options, series)
  };

  if (isNestedPieChart) {
    var aliasNames = getNestedPieChartAliasNames(series);
    pieSeriesOuterAnchors = aliasNames.reduce(function (acc, cur) {
      return store_theme_objectSpread(store_theme_objectSpread({}, acc), {}, store_theme_defineProperty({}, cur, checkAnchorPieSeriesOption(options, series, cur)));
    }, {});
  }

  var globalFontFamily = options === null || options === void 0 ? void 0 : (_options$theme2 = options.theme) === null || _options$theme2 === void 0 ? void 0 : (_options$theme2$chart = _options$theme2.chart) === null || _options$theme2$chart === void 0 ? void 0 : _options$theme2$chart.fontFamily;
  var theme = deepMergedCopy(getDefaultTheme(globalFontFamily, series, pieSeriesOuterAnchors, isNestedPieChart), getThemeOptionsWithSeriesName(options, series, commonSeriesOptions, isNestedPieChart));

  if (!series.heatmap) {
    setColors(theme, series, commonSeriesOptions, isNestedPieChart);
  }

  theme_setPlot(theme);
  return theme;
}

var theme_theme = {
  name: 'theme',
  state: function state(_ref2) {
    var options = _ref2.options,
        series = _ref2.series;
    return {
      theme: getTheme(options, series)
    };
  },
  action: {
    initThemeState: function initThemeState(_ref3) {
      var state = _ref3.state,
          initStoreState = _ref3.initStoreState;
      state.theme = getTheme(state.options, initStoreState.series);
    }
  },
  observe: {
    updateTheme: function updateTheme() {
      this.dispatch('initThemeState');
    }
  }
};
/* harmony default export */ var store_theme = (theme_theme);
// CONCATENATED MODULE: ./src/eventEmitter.ts



function eventEmitter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function eventEmitter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function eventEmitter_createClass(Constructor, protoProps, staticProps) { if (protoProps) eventEmitter_defineProperties(Constructor.prototype, protoProps); if (staticProps) eventEmitter_defineProperties(Constructor, staticProps); return Constructor; }

function eventEmitter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var EventEmitter = /*#__PURE__*/function () {
  function EventEmitter() {
    eventEmitter_classCallCheck(this, EventEmitter);

    eventEmitter_defineProperty(this, "handlers", []);
  }

  eventEmitter_createClass(EventEmitter, [{
    key: "on",
    value: function on(type, handler) {
      if (!this.handlers[type]) {
        this.handlers[type] = [];
      }

      this.handlers[type].push(handler);
    }
  }, {
    key: "emit",
    value: function emit(type) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (this.handlers[type]) {
        this.handlers[type].forEach(function (handler) {
          return handler.apply(void 0, args);
        });
      }
    }
  }]);

  return EventEmitter;
}();


// CONCATENATED MODULE: ./src/component/componentManager.ts




function componentManager_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function componentManager_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function componentManager_createClass(Constructor, protoProps, staticProps) { if (protoProps) componentManager_defineProperties(Constructor.prototype, protoProps); if (staticProps) componentManager_defineProperties(Constructor, staticProps); return Constructor; }

function componentManager_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var componentManager_ComponentManager = /*#__PURE__*/function () {
  function ComponentManager(_ref) {
    var store = _ref.store,
        eventBus = _ref.eventBus;

    componentManager_classCallCheck(this, ComponentManager);

    componentManager_defineProperty(this, "components", []);

    componentManager_defineProperty(this, "store", void 0);

    componentManager_defineProperty(this, "eventBus", void 0);

    this.store = store;
    this.eventBus = eventBus;
  }

  componentManager_createClass(ComponentManager, [{
    key: "add",
    value: function add(ComponentCtor, initialParam) {
      var _this = this;

      var component = new ComponentCtor({
        store: this.store,
        eventBus: this.eventBus
      });

      if (component.initialize) {
        component.initialize(initialParam);
      }

      var proc = function proc() {
        component.render(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1]); // rest쓰면 에러남

        component.sync();

        _this.eventBus.emit('needLoop');
      };

      this.store.observe(function () {
        proc.apply(void 0, arguments);
      });
      proc = debounce(proc);
      this.components.push(component);
    }
  }, {
    key: "remove",
    value: function remove(ComponentCtor) {
      this.components = this.components.filter(function (component) {
        return !(component instanceof ComponentCtor);
      });
    }
  }, {
    key: "clear",
    value: function clear() {
      this.components = [];
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "invoke",
    value: function invoke(method, params) {
      this.components.forEach(function (component) {
        var fn = component[method];

        if (fn) {
          fn.call(component, params);
        }
      });
    }
  }, {
    key: "forEach",
    value: function forEach(iteratee) {
      this.components.forEach(iteratee);
    }
  }]);

  return ComponentManager;
}();


// CONCATENATED MODULE: ./src/painter.ts




function painter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function painter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function painter_createClass(Constructor, protoProps, staticProps) { if (protoProps) painter_defineProperties(Constructor.prototype, protoProps); if (staticProps) painter_defineProperties(Constructor, staticProps); return Constructor; }

function painter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var painter_Painter = /*#__PURE__*/function () {
  function Painter(chart) {
    painter_classCallCheck(this, Painter);

    painter_defineProperty(this, "width", 0);

    painter_defineProperty(this, "height", 0);

    painter_defineProperty(this, "brushes", {});

    painter_defineProperty(this, "chart", void 0);

    painter_defineProperty(this, "canvas", void 0);

    painter_defineProperty(this, "ctx", void 0);

    this.chart = chart;
  }

  painter_createClass(Painter, [{
    key: "setup",
    value: function setup() {
      var _this$chart$store$sta = this.chart.store.state.chart,
          height = _this$chart$store$sta.height,
          width = _this$chart$store$sta.width;

      if (!this.canvas) {
        var canvas = document.createElement('canvas');
        this.canvas = canvas;
        canvas.style.backgroundColor = '#fff';
        this.chart.el.appendChild(canvas);
        canvas.addEventListener('click', this.chart);
        canvas.addEventListener('mousemove', this.chart);
        canvas.addEventListener('mousedown', this.chart);
        canvas.addEventListener('mouseup', this.chart);

        var _ctx = canvas.getContext('2d');

        if (_ctx) {
          this.ctx = _ctx;
        }
      }

      this.setSize(width, height);
    }
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      this.canvas.style.width = "".concat(width, "px");
      this.canvas.style.height = "".concat(height, "px");
      var ratio = 1;

      if ('deviceXDPI' in window.screen) {
        // IE mobile or IE
        ratio = window.screen.deviceXDPI / window.screen.logicalXDPI;
      } else if (window.hasOwnProperty('devicePixelRatio')) {
        ratio = window.devicePixelRatio;
      }

      this.width = width * ratio || 0;
      this.height = height * ratio || 0;
      this.scaleCanvasRatio(ratio);
    }
  }, {
    key: "scaleCanvasRatio",
    value: function scaleCanvasRatio(ratio) {
      this.canvas.width = this.width;
      this.canvas.height = this.height;
      this.ctx.scale(ratio, ratio);
    }
  }, {
    key: "add",
    value: function add(name, brush) {
      this.brushes[name] = brush;
    }
  }, {
    key: "addGroups",
    value: function addGroups(groups) {
      var _this = this;

      groups.forEach(function (group) {
        Object.keys(group).forEach(function (key) {
          _this.add(key, group[key]);
        });
      });
    }
  }, {
    key: "paint",
    value: function paint(name, brushModel) {
      if (this.brushes[name]) {
        this.brushes[name](this.ctx, brushModel);
      } else {
        throw new Error(message.noBrushError(name));
      }
    }
  }, {
    key: "paintForEach",
    value: function paintForEach(brushModels) {
      var _this2 = this;

      brushModels.forEach(function (m) {
        return _this2.paint(m.type, m);
      });
    }
  }, {
    key: "beforeFrame",
    value: function beforeFrame() {
      this.ctx.clearRect(0, 0, this.width, this.height);
      this.ctx.fillStyle = '#fff';
      this.ctx.fillRect(0, 0, this.width, this.height);
    }
  }, {
    key: "beforeDraw",
    value: function beforeDraw(transX, transY) {
      this.ctx.save();
      this.ctx.translate(transX, transY);
    }
  }, {
    key: "afterDraw",
    value: function afterDraw() {
      this.ctx.restore();
    }
  }]);

  return Painter;
}();


// CONCATENATED MODULE: ./src/animator.ts




function animator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function animator_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function animator_createClass(Constructor, protoProps, staticProps) { if (protoProps) animator_defineProperties(Constructor.prototype, protoProps); if (staticProps) animator_defineProperties(Constructor, staticProps); return Constructor; }

function animator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var animator_Animator = /*#__PURE__*/function () {
  function Animator() {
    animator_classCallCheck(this, Animator);

    animator_defineProperty(this, "anims", []);

    animator_defineProperty(this, "state", 'IDLE');

    animator_defineProperty(this, "requestId", null);

    animator_defineProperty(this, "firstRendering", true);
  }

  animator_createClass(Animator, [{
    key: "add",
    value: function add(_ref) {
      var _this = this;

      var chart = _ref.chart,
          duration = _ref.duration,
          requester = _ref.requester,
          _ref$onCompleted = _ref.onCompleted,
          onCompleted = _ref$onCompleted === void 0 ? function () {} : _ref$onCompleted,
          _ref$onFrame = _ref.onFrame,
          onFrame = _ref$onFrame === void 0 ? function (delta) {
        if (!_this.firstRendering) {
          chart.update(delta);
        }

        if (_this.firstRendering) {
          chart.initUpdate(delta);

          if (delta === 1) {
            _this.firstRendering = false;
          }
        }
      } : _ref$onFrame;

      if (this.anims.length) {
        this.reset();
      }

      if (this.state === 'IDLE') {
        this.anims.push({
          chart: chart,
          requester: requester,
          duration: duration,
          onFrame: onFrame,
          onCompleted: onCompleted,
          start: null,
          current: null,
          completed: false
        });
        this.start();
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      this.anims.forEach(function (anim) {
        anim.current = 1;
        anim.onFrame(anim.current);
        anim.completed = true;
      });
      this.anims = [];
      this.cancelAnimFrame();
      this.state = 'IDLE';
      this.requestId = null;
    }
  }, {
    key: "start",
    value: function start() {
      if (this.anims.length) {
        this.state = 'RUNNING';
        this.runFrame();
      }
    }
  }, {
    key: "runFrame",
    value: function runFrame() {
      var _this2 = this;

      this.requestId = window.requestAnimationFrame(function (timestamp) {
        _this2.runAnims(timestamp);
      });
    }
  }, {
    key: "runAnims",
    value: function runAnims(timestamp) {
      this.next(timestamp);

      if (this.anims.length) {
        this.runFrame();
      } else {
        this.state = 'IDLE';
        this.requestId = null;
      }
    }
  }, {
    key: "next",
    value: function next(timestamp) {
      var _this3 = this;

      this.anims.forEach(function (anim) {
        if (isNull(anim.start)) {
          anim.start = timestamp;
        }

        Object.defineProperty(anim.chart, '___animId___', {
          value: timestamp,
          enumerable: false,
          writable: false,
          configurable: true
        });
        anim.current = anim.duration ? Math.min((timestamp - anim.start) / anim.duration, 1) : 1;
        anim.onFrame(anim.current);
        anim.completed = anim.current === 1;
      });
      this.anims.forEach(function (anim) {
        if (anim.chart.___animId___ === timestamp) {
          anim.chart.draw();
          delete anim.chart.___animId___;
        }

        if (anim.completed) {
          _this3.cancelAnimFrame();

          anim.onCompleted();
          anim.chart.eventBus.emit('animationCompleted', anim.requester);
        }
      });
      this.anims = this.anims.filter(function (anim) {
        return !anim.completed;
      });
    }
  }, {
    key: "cancelAnimFrame",
    value: function cancelAnimFrame() {
      if (this.requestId) {
        window.cancelAnimationFrame(this.requestId);
      }
    }
  }]);

  return Animator;
}();


// CONCATENATED MODULE: ./src/responderDetectors.ts



var responderDetectors = {
  circle: function circle(mousePosition, model, componentRect) {
    var x = mousePosition.x,
        y = mousePosition.y;
    var modelX = model.x,
        modelY = model.y,
        radius = model.radius,
        detectionSize = model.detectionSize;
    var compX = componentRect.x,
        compY = componentRect.y;
    var radiusAdjustment = isUndefined(detectionSize) ? 10 : detectionSize;
    return Math.pow(x - (modelX + compX), 2) + Math.pow(y - (modelY + compY), 2) < Math.pow(radius + radiusAdjustment, 2);
  },
  rect: function rect(mousePosition, model) {
    var componentRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    var x = mousePosition.x,
        y = mousePosition.y;
    var modelX = model.x,
        modelY = model.y,
        width = model.width,
        height = model.height;
    var compX = componentRect.x,
        compY = componentRect.y;
    return x >= modelX + compX && x <= modelX + compX + width && y >= modelY + compY && y <= modelY + compY + height;
  },
  sector: function sector(mousePosition, model) {
    var componentRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    var x = mousePosition.x,
        y = mousePosition.y;
    var modelX = model.x,
        modelY = model.y,
        _model$radius = model.radius,
        outer = _model$radius.outer,
        inner = _model$radius.inner,
        _model$degree = model.degree,
        start = _model$degree.start,
        end = _model$degree.end,
        drawingStartAngle = model.drawingStartAngle,
        clockwise = model.clockwise;
    var compX = componentRect.x,
        compY = componentRect.y;
    var xPos = x - (modelX + compX);
    var yPos = y - (modelY + compY);
    var insideOuterRadius = Math.pow(xPos, 2) + Math.pow(yPos, 2) < Math.pow(outer, 2);
    var outsideInnerRadius = Math.pow(xPos, 2) + Math.pow(yPos, 2) > Math.pow(inner, 2);
    var withinRadius = insideOuterRadius && outsideInnerRadius;
    var detectionDegree = calculateRadianToDegree(Math.atan2(yPos, xPos), drawingStartAngle);
    return withinRadius && withinRadian(clockwise, start, end, detectionDegree);
  },
  line: function line(mousePosition, model) {
    var componentRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    var x = mousePosition.x,
        y = mousePosition.y;
    var compX = componentRect.x,
        compY = componentRect.y;
    var modelX = model.x,
        modelY = model.y,
        x2 = model.x2,
        y2 = model.y2,
        _model$detectionSize = model.detectionSize,
        detectionSize = _model$detectionSize === void 0 ? 3 : _model$detectionSize;
    var numerator = y2 - modelY;
    var denominator = x2 - modelX;
    var result = false;

    if (numerator === 0) {
      // y = a
      var minX = Math.min(modelX, x2);
      var maxX = Math.max(modelX, x2);
      result = x - compX >= minX && x - compX <= maxX && y >= modelY + compY - detectionSize && y <= modelY + compY + detectionSize;
    } else if (denominator === 0) {
      // x = a
      var minY = Math.min(modelY, y2);
      var maxY = Math.max(modelY, y2);
      result = y - compY >= minY && y - compY <= maxY && x >= modelX + compX - detectionSize && x <= modelX + compX + detectionSize;
    } else {
      // y = ax + b
      var slope = numerator / denominator;
      var xPos = x - (modelX + compX);
      var yPos = y - (modelY + compY);
      result = slope * xPos === yPos;
    }

    return result;
  },
  boxPlot: function boxPlot(mousePosition, model) {
    var componentRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    return ['rect', 'median', 'minimum', 'maximum', 'upperWhisker', 'lowerWhisker'].some(function (prop) {
      if (!model[prop]) {
        return false;
      }

      return prop === 'rect' ? responderDetectors.rect(mousePosition, model[prop], componentRect) : responderDetectors.line(mousePosition, model[prop], componentRect);
    });
  }
};
// CONCATENATED MODULE: ./src/helpers/googleAnalytics.ts





var MS_7_DAYS = 7 * 24 * 60 * 60 * 1000;

function isExpired(date) {
  var now = new Date().getTime();
  return now - date > MS_7_DAYS;
}

function imagePing(url, trackingInfo) {
  var queryString = Object.keys(trackingInfo).map(function (id, index) {
    return "".concat(index ? '&' : '').concat(id, "=").concat(trackingInfo[id]);
  }).join('');
  var trackingElement = document.createElement('img');
  trackingElement.src = "".concat(url, "?").concat(queryString);
  trackingElement.style.display = 'none';
  document.body.appendChild(trackingElement);
  document.body.removeChild(trackingElement);
  return trackingElement;
}

function sendHostname() {
  var hostname = location.hostname;
  var applicationKeyForStorage = "TOAST UI chart for ".concat(hostname, ": Statistics");
  var date = window.localStorage.getItem(applicationKeyForStorage);

  if (date && !isExpired(Number(date))) {
    return;
  }

  window.localStorage.setItem(applicationKeyForStorage, String(new Date().getTime()));
  setTimeout(function () {
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      imagePing('https://www.google-analytics.com/collect', {
        v: 1,
        t: 'event',
        tid: 'UA-129983528-2',
        cid: hostname,
        dp: hostname,
        dh: 'chart',
        el: 'chart',
        ec: 'use'
      });
    }
  }, 1000);
}
// CONCATENATED MODULE: ./src/charts/chart.ts





















function chart_toConsumableArray(arr) { return chart_arrayWithoutHoles(arr) || chart_iterableToArray(arr) || chart_unsupportedIterableToArray(arr) || chart_nonIterableSpread(); }

function chart_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function chart_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return chart_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return chart_arrayLikeToArray(o, minLen); }

function chart_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function chart_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return chart_arrayLikeToArray(arr); }

function chart_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function chart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function chart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { chart_ownKeys(Object(source), true).forEach(function (key) { chart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { chart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function chart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function chart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function chart_createClass(Constructor, protoProps, staticProps) { if (protoProps) chart_defineProperties(Constructor.prototype, protoProps); if (staticProps) chart_defineProperties(Constructor, staticProps); return Constructor; }

function chart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


















var DEFAULT_ANIM_DURATION = 500;

function getUsingContainerSize(eventName, usingContainerSize, width, height) {
  var usingContainerWidth = usingContainerSize.width,
      usingContainerHeight = usingContainerSize.height;
  var isAutoWidth = isAutoValue(width);
  var isAutoHeight = isAutoValue(height);
  return eventName === 'updateOptions' ? {
    width: !isUndefined(width) && usingContainerWidth !== isAutoWidth ? isAutoWidth : usingContainerWidth,
    height: !isUndefined(height) && usingContainerHeight !== isAutoHeight ? isAutoHeight : usingContainerHeight
  } : {
    width: isAutoWidth,
    height: isAutoHeight
  };
}
/**
 * @class
 * @abstract
 * Abstract class used to implement each chart.
 */


var chart_Chart = /*#__PURE__*/function () {
  chart_createClass(Chart, [{
    key: "getAnimationDuration",
    value: function getAnimationDuration(animationOption) {
      var firstRendering = this.animator.firstRendering;
      var _this$animationContro = this.animationControlFlag,
          resizing = _this$animationContro.resizing,
          updating = _this$animationContro.updating;
      var duration;

      if (!firstRendering && !resizing || isUndefined(animationOption)) {
        duration = DEFAULT_ANIM_DURATION;
      } else if (isBoolean(animationOption)) {
        duration = animationOption ? DEFAULT_ANIM_DURATION : 0;
      } else if (isNumber(animationOption.duration)) {
        duration = animationOption.duration;
      }

      if (updating) {
        duration = 0;
      }

      this.animationControlFlag.updating = false;
      return duration;
    }
  }]);

  function Chart(props) {
    var _this = this,
        _options$chart4,
        _options$chart5;

    chart_classCallCheck(this, Chart);

    chart_defineProperty(this, "store", void 0);

    chart_defineProperty(this, "___animId___", null);

    chart_defineProperty(this, "animator", void 0);

    chart_defineProperty(this, "el", void 0);

    chart_defineProperty(this, "ctx", void 0);

    chart_defineProperty(this, "painter", new painter_Painter(this));

    chart_defineProperty(this, "eventBus", new EventEmitter());

    chart_defineProperty(this, "componentManager", void 0);

    chart_defineProperty(this, "modules", void 0);

    chart_defineProperty(this, "enteredComponents", []);

    chart_defineProperty(this, "animationControlFlag", {
      resizing: false,
      updating: false
    });

    chart_defineProperty(this, "resizeObserver", null);

    chart_defineProperty(this, "debounceResizeEvent", debounce(function (containerWidth, containerHeight) {
      _this.resizeChartSize(containerWidth, containerHeight);
    }, 100));

    chart_defineProperty(this, "debounceWindowResizeEvent", debounce(function () {
      var _this$el = _this.el,
          offsetWidth = _this$el.offsetWidth,
          offsetHeight = _this$el.offsetHeight;

      _this.resizeChartSize(offsetWidth, offsetHeight);
    }, 100));

    chart_defineProperty(this, "getCheckedLegend", function () {
      var data = _this.store.state.legend.data;
      return data.filter(function (datum) {
        return datum.checked;
      }).map(function (datum) {
        return pick(datum, 'chartType', 'label', 'checked');
      });
    });

    chart_defineProperty(this, "getOptions", function () {
      return makeObservableObjectToNormal(_this.store.initStoreState.options);
    });

    chart_defineProperty(this, "on", function (eventName, handler) {
      /**
       * Register Events that occur when click legend label
       * @event ChartBase#clickLegendLabel
       * @param {object} info selected legend information
       * @api
       * @example
       * chart.on('clickLegendLabel', (info) => {
       *   console.log(info);
       * });
       */

      /**
       * Register Events that occur when click legend checkbox
       * @event ChartBase#clickLegendCheckbox
       * @param {object} info selected legend info
       * @api
       * @example
       * chart.on('clickLegendCheckbox', (info) => {
       *   console.log(info);
       * });
       */

      /**
       * Register Events that occur when select series
       * @event ChartBase#selectSeries
       * @param {object} info selected series info
       * @api
       * @example
       * chart.on('selectSeries', (info) => {
       *   console.log(info);
       * });
       */

      /**
       * Register Events that occur when unselect series
       * @event ChartBase#unselectSeries
       * @param {object} info unselected series info
       * @api
       * @example
       * chart.on('unselectSeries', (info) => {
       *   console.log(info);
       * });
       */

      /**
       * Register Events that occur when hover to series
       * @event ChartBase#hoverSeries
       * @param {object} info hovered series info
       * @api
       * @example
       * chart.on('hoverSeries', (info) => {
       *   console.log(info);
       * });
       */

      /**
       * Register Events that occur when unhover from series
       * @event ChartBase#unhoverSeries
       * @param {object} info unhovered series info
       * @api
       * @example
       * chart.on('unhoverSeries', (info) => {
       *  console.log(info);
       * });
       */

      /**
       * Register Events that occur when zooming
       * @event ChartBase#zoom
       * @param {string[]} dataRange - []
       * @api
       * @example
       * chart.on('zoom', (dataRange) => {
       *    console.log(dataRange);
       * });
       */

      /**
       * Register Events that occur when zoom is reset
       * @event ChartBase#resetZoom
       * @api
       * @example
       * chart.on('resetZoom', () => {});
       */
      _this.eventBus.on(eventName, handler);
    });

    chart_defineProperty(this, "destroy", function () {
      _this.componentManager.clear();

      _this.clearResizeEvent();

      _this.el.innerHTML = '';
    });

    chart_defineProperty(this, "selectSeries", function (seriesInfo) {
      if (!_this.isSelectableSeries()) {
        throw new Error(message.SELECT_SERIES_API_SELECTABLE_ERROR);
      }

      _this.eventBus.emit('selectSeries', chart_objectSpread(chart_objectSpread({}, seriesInfo), {}, {
        state: _this.store.state
      }));
    });

    chart_defineProperty(this, "unselectSeries", function () {
      if (!_this.isSelectableSeries()) {
        throw new Error(message.SELECT_SERIES_API_SELECTABLE_ERROR);
      }

      _this.store.dispatch('setAllLegendActiveState', true);

      _this.eventBus.emit('resetSelectedSeries');
    });

    chart_defineProperty(this, "resize", function (size) {
      _this.resetSeries();

      _this.store.dispatch('updateOptions', {
        options: {
          chart: chart_objectSpread({}, size)
        }
      });
    });

    chart_defineProperty(this, "resetSeries", function () {
      _this.eventBus.emit('resetHoveredSeries');

      _this.eventBus.emit('resetSelectedSeries');
    });

    chart_defineProperty(this, "setResizeEventListeners", function (eventName, options) {
      var _options$chart, _options$chart2;

      var usingContainerSize = _this.store.state.usingContainerSize;
      var usingContainerWidth = usingContainerSize.width,
          usingContainerHeight = usingContainerSize.height;
      var width = options === null || options === void 0 ? void 0 : (_options$chart = options.chart) === null || _options$chart === void 0 ? void 0 : _options$chart.width;
      var height = options === null || options === void 0 ? void 0 : (_options$chart2 = options.chart) === null || _options$chart2 === void 0 ? void 0 : _options$chart2.height;
      var isAutoWidth = isAutoValue(width);
      var isAutoHeight = isAutoValue(height);

      if ((usingContainerWidth || usingContainerHeight) && isNumber(width) && isNumber(height)) {
        _this.clearResizeEvent();
      } else if (!(usingContainerWidth || usingContainerHeight) && (isAutoWidth || isAutoHeight)) {
        _this.setResizeEvent();
      }

      _this.store.dispatch('setUsingContainerSize', getUsingContainerSize(eventName, usingContainerSize, width, height));
    });

    var el = props.el,
        _options = props.options,
        series = props.series,
        categories = props.categories,
        modules = props.modules;
    this.modules = modules !== null && modules !== void 0 ? modules : [];

    if (isUndefined(_options.usageStatistics) || _options.usageStatistics) {
      sendHostname();
    }

    this.el = el;
    this.animator = new animator_Animator();
    this.store = new store_Store({
      series: series,
      categories: categories,
      options: _options
    });
    this.componentManager = new componentManager_ComponentManager({
      store: this.store,
      eventBus: this.eventBus
    });
    this.eventBus.on('needLoop', debounce(function () {
      var _options$chart3;

      var duration = _this.getAnimationDuration((_options$chart3 = _options.chart) === null || _options$chart3 === void 0 ? void 0 : _options$chart3.animation);

      if (_this.animationControlFlag.resizing) {
        var _options$responsive;

        duration = isUndefined(_options.responsive) ? _this.getAnimationDuration() : _this.getAnimationDuration((_options$responsive = _options.responsive) === null || _options$responsive === void 0 ? void 0 : _options$responsive.animation);
        _this.animationControlFlag.resizing = false;
      }

      _this.eventBus.emit('loopStart');

      _this.animator.add({
        onCompleted: function onCompleted() {
          _this.eventBus.emit('loopComplete');
        },
        chart: _this,
        duration: duration,
        requester: _this
      });
    }, 10));
    this.eventBus.on('needSubLoop', function (opts) {
      _this.animator.add(chart_objectSpread(chart_objectSpread({}, opts), {}, {
        chart: _this
      }));
    });
    this.eventBus.on('needDraw', debounce(function () {
      _this.draw();
    }, 10));
    this.initialize();
    this.store.observe(function () {
      _this.painter.setup();
    });

    if (isAutoValue(_options === null || _options === void 0 ? void 0 : (_options$chart4 = _options.chart) === null || _options$chart4 === void 0 ? void 0 : _options$chart4.width) || isAutoValue(_options === null || _options === void 0 ? void 0 : (_options$chart5 = _options.chart) === null || _options$chart5 === void 0 ? void 0 : _options$chart5.height)) {
      this.setResizeEvent();
    }
  }

  chart_createClass(Chart, [{
    key: "resizeChartSize",
    value: function resizeChartSize(containerWidth, containerHeight) {
      this.animationControlFlag.resizing = true;
      var _this$store$state = this.store.state,
          _this$store$state$usi = _this$store$state.usingContainerSize,
          usingContainerWidth = _this$store$state$usi.width,
          usingContainerHeight = _this$store$state$usi.height,
          _this$store$state$cha = _this$store$state.chart,
          width = _this$store$state$cha.width,
          height = _this$store$state$cha.height;

      if (!(usingContainerWidth || usingContainerHeight) || !(containerWidth || containerHeight) || containerWidth === width && containerHeight === height) {
        this.animationControlFlag.resizing = false;
        return;
      } // @TODO: For updates where the data doesn't change, it looks good to recalculate the selected series position.


      this.resetSeries();
      this.store.dispatch('setChartSize', {
        width: usingContainerWidth ? containerWidth : width,
        height: usingContainerHeight ? containerHeight : height
      });
      this.draw();
    }
  }, {
    key: "setResizeEvent",
    value: function setResizeEvent() {
      var _this2 = this;

      if (isUndefined(ResizeObserver)) {
        window.addEventListener('resize', this.debounceWindowResizeEvent);
      } else {
        this.resizeObserver = new ResizeObserver(function (entries) {
          entries.forEach(function (entry) {
            var _entry$contentRect = entry.contentRect,
                width = _entry$contentRect.width,
                height = _entry$contentRect.height;

            _this2.debounceResizeEvent(width, height);
          });
        });
        this.resizeObserver.observe(this.el);
      }
    }
  }, {
    key: "clearResizeEvent",
    value: function clearResizeEvent() {
      if (this.resizeObserver) {
        this.resizeObserver.unobserve(this.el);
        this.resizeObserver.disconnect();
        this.resizeObserver = null;
      } else {
        window.removeEventListener('resize', this.debounceWindowResizeEvent);
      }
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      var _this3 = this;

      var clientX = event.clientX,
          clientY = event.clientY,
          eventType = event.type;
      var delegationMethod = "on".concat(eventType[0].toUpperCase() + eventType.substring(1));
      var canvasRect = this.painter.ctx.canvas.getBoundingClientRect();
      var mousePosition = {
        x: clientX - canvasRect.left,
        y: clientY - canvasRect.top
      };
      var newEnteredComponents = [];

      if (eventType === 'mousemove') {
        this.componentManager.forEach(function (component) {
          var _component$rect = component.rect,
              x = _component$rect.x,
              y = _component$rect.y,
              height = _component$rect.height,
              width = _component$rect.width;

          var exist = _this3.enteredComponents.some(function (enteredComponent) {
            return enteredComponent === component;
          });

          var entered = mousePosition.x >= x && mousePosition.x <= x + width && mousePosition.y >= y && mousePosition.y <= y + height;

          if (entered) {
            newEnteredComponents.push(component);

            if (!exist && component.onMouseenterComponent) {
              component.onMouseenterComponent();
            }
          } else if (exist && component.onMouseoutComponent) {
            component.onMouseoutComponent();
          }
        });
        this.enteredComponents = newEnteredComponents;
      }

      var allResponders = [];
      this.componentManager.forEach(function (component) {
        if (!component[delegationMethod]) {
          return;
        }

        if (!responderDetectors.rect(mousePosition, component.rect)) {
          return;
        }

        var detected = (component.responders || []).filter(function (m) {
          return responderDetectors[m.type](mousePosition, m, component.rect);
        });

        if (detected.length) {
          allResponders.push({
            component: component,
            detected: detected
          });
        }

        component[delegationMethod]({
          mousePosition: mousePosition,
          responders: detected
        }, event);
      });

      if (this.handleEventForAllResponders) {
        this.handleEventForAllResponders(event, allResponders, delegationMethod, mousePosition);
      }
    }
  }, {
    key: "initStore",
    value: function initStore() {
      var _this4 = this;

      [store_root, store_options, store_theme, store_seriesData, store_legend, store_layout, store_category].concat(chart_toConsumableArray(this.modules)).forEach(function (module) {
        return _this4.store.setModule(module);
      });
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this.initStore();
      this.store.dispatch('initChartSize', this.el);
    }
  }, {
    key: "draw",
    value: function draw() {
      var _this5 = this;

      this.painter.beforeFrame();
      this.componentManager.forEach(function (component) {
        if (!component.isShow) {
          return;
        }

        _this5.painter.beforeDraw(component.rect.x, component.rect.y);

        if (component.beforeDraw) {
          component.beforeDraw(_this5.painter);
        }

        component.draw(_this5.painter);

        _this5.painter.afterDraw();
      });
    }
  }, {
    key: "update",
    value: function update(delta) {
      this.componentManager.invoke('update', delta);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      this.componentManager.invoke('initUpdate', delta);
    }
  }, {
    key: "isSelectableSeries",
    value: function isSelectableSeries() {
      var _this$store$initStore;

      return (_this$store$initStore = this.store.initStoreState.options.series) === null || _this$store$initStore === void 0 ? void 0 : _this$store$initStore.selectable;
    }
    /**
     * Select series. It works only when the selectable option is true.
     * @param {Object} seriesInfo - Information of the series to be selected
     *      @param {number} [seriesInfo.seriesIndex] - Index of series
     *      @param {number} [seriesInfo.index] - Index of data within series
     *      @param {string} [seriesInfo.name] - Specify name for NestedPie Chart
     *      @param {string} [seriesInfo.chartType] - Specify which chart to select when using LineArea, LineScatter, and ColumnLine charts.specifies which chart to select when using LineArea, LineScatter, and ColumnLine charts.
     * @api
     * @example
     * chart.selectSeries({index: 1, seriesIndex: 2});
     */

  }, {
    key: "setTooltipOffset",

    /**
     * Set tooltip offset.
     * @param {Object} offset - Offset size
     *   @param {number} [offset.x] Offset value to move title horizontally
     *   @param {number} [offset.y] Offset value to move title vertically
     * @api
     * @example
     * chart.setTooltipOffset({x: 10, y: -20});
     */
    value: function setTooltipOffset(offset) {
      var offsetX = offset.x,
          offsetY = offset.y;
      this.store.dispatch('updateOptions', {
        options: {
          tooltip: {
            offsetX: offsetX,
            offsetY: offsetY
          }
        }
      });
    }
  }, {
    key: "dispatchOptionsEvent",
    value: function dispatchOptionsEvent(eventName, options) {
      this.setResizeEventListeners(eventName, options);
      var _this$el2 = this.el,
          offsetWidth = _this$el2.offsetWidth,
          offsetHeight = _this$el2.offsetHeight;
      this.store.dispatch(eventName, {
        options: options,
        containerSize: {
          width: offsetWidth,
          height: offsetHeight
        }
      });
    }
  }]);

  return Chart;
}();


// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.max-safe-integer.js
var es_number_max_safe_integer = __webpack_require__(133);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.min-safe-integer.js
var es_number_min_safe_integer = __webpack_require__(134);

// CONCATENATED MODULE: ./src/store/dataRange.ts



























function dataRange_slicedToArray(arr, i) { return dataRange_arrayWithHoles(arr) || dataRange_iterableToArrayLimit(arr, i) || dataRange_unsupportedIterableToArray(arr, i) || dataRange_nonIterableRest(); }

function dataRange_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function dataRange_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function dataRange_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function dataRange_toConsumableArray(arr) { return dataRange_arrayWithoutHoles(arr) || dataRange_iterableToArray(arr) || dataRange_unsupportedIterableToArray(arr) || dataRange_nonIterableSpread(); }

function dataRange_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function dataRange_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dataRange_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dataRange_arrayLikeToArray(o, minLen); }

function dataRange_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function dataRange_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return dataRange_arrayLikeToArray(arr); }

function dataRange_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }






function getLimitSafely(baseValues) {
  var limit = {
    min: Math.min.apply(Math, dataRange_toConsumableArray(baseValues)),
    max: Math.max.apply(Math, dataRange_toConsumableArray(baseValues))
  };

  if (baseValues.length === 1) {
    var _baseValues = dataRange_slicedToArray(baseValues, 1),
        firstValue = _baseValues[0];

    if (firstValue > 0) {
      limit.min = 0;
    } else if (firstValue === 0) {
      limit.max = 10;
    } else {
      limit.max = 0;
    }
  } else if (limit.min === 0 && limit.max === 0) {
    limit.max = 10;
  } else if (limit.min === limit.max) {
    limit.min -= limit.min / 10;
    limit.max += limit.max / 10;
  }

  return limit;
}

function getTotalDataRange(seriesDataRange) {
  var defaultDataRange = {
    min: Number.MAX_SAFE_INTEGER,
    max: Number.MIN_SAFE_INTEGER
  };
  return Object.values(seriesDataRange).reduce(function (acc, cur) {
    if (cur.xAxis) {
      var _acc$xAxis$min, _acc$xAxis, _acc$xAxis$max, _acc$xAxis2;

      acc.xAxis = {
        min: Math.min(cur.xAxis.min, (_acc$xAxis$min = (_acc$xAxis = acc.xAxis) === null || _acc$xAxis === void 0 ? void 0 : _acc$xAxis.min) !== null && _acc$xAxis$min !== void 0 ? _acc$xAxis$min : defaultDataRange.min),
        max: Math.max(cur.xAxis.max, (_acc$xAxis$max = (_acc$xAxis2 = acc.xAxis) === null || _acc$xAxis2 === void 0 ? void 0 : _acc$xAxis2.max) !== null && _acc$xAxis$max !== void 0 ? _acc$xAxis$max : defaultDataRange.max)
      };
    }

    if (cur.yAxis) {
      var _acc$yAxis$min, _acc$yAxis, _acc$yAxis$max, _acc$yAxis2;

      acc.yAxis = {
        min: Math.min(cur.yAxis.min, (_acc$yAxis$min = (_acc$yAxis = acc.yAxis) === null || _acc$yAxis === void 0 ? void 0 : _acc$yAxis.min) !== null && _acc$yAxis$min !== void 0 ? _acc$yAxis$min : defaultDataRange.min),
        max: Math.max(cur.yAxis.max, (_acc$yAxis$max = (_acc$yAxis2 = acc.yAxis) === null || _acc$yAxis2 === void 0 ? void 0 : _acc$yAxis2.max) !== null && _acc$yAxis$max !== void 0 ? _acc$yAxis$max : defaultDataRange.max)
      };
    }

    if (cur.secondaryYAxis) {
      var _acc$secondaryYAxis$m, _acc$secondaryYAxis, _acc$secondaryYAxis$m2, _acc$secondaryYAxis2;

      acc.secondaryYAxis = {
        min: Math.min(cur.secondaryYAxis.min, (_acc$secondaryYAxis$m = (_acc$secondaryYAxis = acc.secondaryYAxis) === null || _acc$secondaryYAxis === void 0 ? void 0 : _acc$secondaryYAxis.min) !== null && _acc$secondaryYAxis$m !== void 0 ? _acc$secondaryYAxis$m : defaultDataRange.min),
        max: Math.max(cur.secondaryYAxis.max, (_acc$secondaryYAxis$m2 = (_acc$secondaryYAxis2 = acc.secondaryYAxis) === null || _acc$secondaryYAxis2 === void 0 ? void 0 : _acc$secondaryYAxis2.max) !== null && _acc$secondaryYAxis$m2 !== void 0 ? _acc$secondaryYAxis$m2 : defaultDataRange.max)
      };
    }

    return acc;
  }, {});
}

function setSeriesDataRange(options, seriesName, values, valueAxisName, seriesDataRange) {
  var _getYAxisOption = getYAxisOption(options),
      secondaryYAxis = _getYAxisOption.secondaryYAxis;

  var axisNames = hasSecondaryYAxis(options) && (secondaryYAxis === null || secondaryYAxis === void 0 ? void 0 : secondaryYAxis.chartType) ? [secondaryYAxis.chartType === seriesName ? 'secondaryYAxis' : 'yAxis'] : getValueAxisNames(options, valueAxisName);
  axisNames.forEach(function (axisName) {
    seriesDataRange[seriesName][axisName] = getLimitSafely(dataRange_toConsumableArray(new Set(values)));
  });
  return seriesDataRange;
}

var dataRange_dataRange = {
  name: 'dataRange',
  state: function state() {
    return {
      dataRange: {}
    };
  },
  action: {
    setDataRange: function setDataRange(_ref) {
      var _options$xAxis;

      var state = _ref.state;
      var series = state.series,
          disabledSeries = state.disabledSeries,
          stackSeries = state.stackSeries,
          categories = state.categories,
          options = state.options;
      var seriesDataRange = {};
      var labelAxisOnYAxis = isLabelAxisOnYAxis(series, options);

      var _getAxisName = getAxisName(labelAxisOnYAxis),
          labelAxisName = _getAxisName.labelAxisName,
          valueAxisName = _getAxisName.valueAxisName;

      var hasDateValue = !!((_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : _options$xAxis.date);

      for (var seriesName in series) {
        var _stackSeries$seriesNa;

        if (!series.hasOwnProperty(seriesName)) {
          continue;
        }

        seriesDataRange[seriesName] = {};
        var values = series[seriesName].data.flatMap(function (_ref2) {
          var data = _ref2.data,
              name = _ref2.name;
          return disabledSeries.includes(name) ? [] : data;
        });
        var firstExistValue = getFirstValidValue(values);

        if (isCoordinateSeries(series)) {
          values = values.filter(function (value) {
            return !isNull(value);
          }).map(function (value) {
            return getCoordinateYValue(value);
          });
          var xAxisValues = categories.map(function (value) {
            return hasDateValue ? Number(new Date(value)) : Number(value);
          });
          seriesDataRange[seriesName][labelAxisName] = getLimitSafely(dataRange_toConsumableArray(xAxisValues));
        } else if (isRangeValue(firstExistValue)) {
          values = values.reduce(function (arr, value) {
            if (isNull(value)) {
              return arr;
            }

            return Array.isArray(value) ? [].concat(dataRange_toConsumableArray(arr), dataRange_toConsumableArray(value)) : dataRange_toConsumableArray(value);
          }, []);
        } else if (stackSeries && ((_stackSeries$seriesNa = stackSeries[seriesName]) === null || _stackSeries$seriesNa === void 0 ? void 0 : _stackSeries$seriesNa.stack)) {
          values = stackSeries[seriesName].dataRangeValues;
        } else if (includes(['bar', 'column', 'radar'], seriesName)) {
          values.push(0);
        } else if (seriesName === 'boxPlot') {
          values = series[seriesName].data.flatMap(function (_ref3) {
            var data = _ref3.data,
                _ref3$outliers = _ref3.outliers,
                outliers = _ref3$outliers === void 0 ? [] : _ref3$outliers;
            return [].concat(dataRange_toConsumableArray((data !== null && data !== void 0 ? data : []).flatMap(function (datum) {
              return datum;
            })), dataRange_toConsumableArray((outliers !== null && outliers !== void 0 ? outliers : []).flatMap(function (datum) {
              return datum;
            })));
          });
        } else if (seriesName === 'bullet') {
          values = series[seriesName].data.flatMap(function (_ref4) {
            var data = _ref4.data,
                markers = _ref4.markers,
                ranges = _ref4.ranges;
            return [data].concat(dataRange_toConsumableArray((markers !== null && markers !== void 0 ? markers : []).flatMap(function (datum) {
              return datum;
            })), dataRange_toConsumableArray((ranges !== null && ranges !== void 0 ? ranges : []).flatMap(function (range) {
              return range;
            })));
          });
        }

        setSeriesDataRange(options, seriesName, values, valueAxisName, seriesDataRange);
      }

      var newDataRange = getTotalDataRange(seriesDataRange);
      store_extend(state.dataRange, newDataRange);
    }
  },
  observe: {
    updateDataRange: function updateDataRange() {
      this.dispatch('setDataRange');
    }
  }
};
/* harmony default export */ var store_dataRange = (dataRange_dataRange);
// CONCATENATED MODULE: ./src/scale/coordinateScaleCalculator.ts




















function coordinateScaleCalculator_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function coordinateScaleCalculator_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { coordinateScaleCalculator_ownKeys(Object(source), true).forEach(function (key) { coordinateScaleCalculator_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { coordinateScaleCalculator_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function coordinateScaleCalculator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function coordinateScaleCalculator_toConsumableArray(arr) { return coordinateScaleCalculator_arrayWithoutHoles(arr) || coordinateScaleCalculator_iterableToArray(arr) || coordinateScaleCalculator_unsupportedIterableToArray(arr) || coordinateScaleCalculator_nonIterableSpread(); }

function coordinateScaleCalculator_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function coordinateScaleCalculator_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return coordinateScaleCalculator_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return coordinateScaleCalculator_arrayLikeToArray(o, minLen); }

function coordinateScaleCalculator_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function coordinateScaleCalculator_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return coordinateScaleCalculator_arrayLikeToArray(arr); }

function coordinateScaleCalculator_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


var SNAP_VALUES = [1, 2, 5, 10];
var DEFAULT_PIXELS_PER_STEP = 88;

function adjustLimitForOverflow(_ref, stepSize, overflowed) {
  var min = _ref.min,
      max = _ref.max;
  return {
    min: overflowed.min ? min - stepSize : min,
    max: overflowed.max ? max + stepSize : max
  };
}

function isSeriesOverflowed(scaleData, _ref2, scaleOption) {
  var min = _ref2.min,
      max = _ref2.max;
  var scaleDataLimit = scaleData.limit;
  var hasMinOption = isNumber(scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.min);
  var hasMaxOption = isNumber(scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.max);
  var isOverflowedMin = !hasMinOption && scaleDataLimit.min === min && scaleDataLimit.min !== 0;
  var isOverflowedMax = !hasMaxOption && scaleDataLimit.max === max && scaleDataLimit.max !== 0;

  if (!isOverflowedMin && !isOverflowedMax) {
    return null;
  }

  return {
    min: isOverflowedMin,
    max: isOverflowedMax
  };
}

function getDigits(num) {
  var logNumberDividedLN10 = num === 0 ? 1 : Math.log(Math.abs(num)) / Math.LN10;
  return Math.pow(10, Math.floor(logNumberDividedLN10));
}

function getSnappedNumber(num) {
  var snapNumber = 0;

  for (var i = 0, t = SNAP_VALUES.length; i < t; i += 1) {
    snapNumber = SNAP_VALUES[i];
    var guideValue = (snapNumber + (SNAP_VALUES[i + 1] || snapNumber)) / 2;

    if (num <= guideValue) {
      break;
    }
  }

  return snapNumber;
}

function getNormalizedStep(stepSize) {
  var placeNumber = getDigits(stepSize);
  var simplifiedStepValue = stepSize / placeNumber;
  return getSnappedNumber(simplifiedStepValue) * placeNumber;
}
/**
 * Get normalized limit values
 * max = 155 and step = 10 ---> max = 160
 */


function getNormalizedLimit(limit, stepSize) {
  var min = limit.min,
      max = limit.max;
  var minNumber = Math.min(getDigits(max), getDigits(stepSize));
  var placeNumber = minNumber > 1 ? 1 : 1 / minNumber;
  var fixedStep = stepSize * placeNumber; // ceil max value step digits

  max = Math.ceil(max * placeNumber / fixedStep) * fixedStep / placeNumber;

  if (min > stepSize) {
    // floor min value to multiples of step
    min = Math.floor(min * placeNumber / fixedStep) * fixedStep / placeNumber;
  } else if (min < 0) {
    min = -(Math.ceil(Math.abs(min) * placeNumber / fixedStep) * fixedStep) / placeNumber;
  } else {
    min = 0;
  }

  return {
    min: min,
    max: max
  };
}

function getNormalizedStepCount(limitSize, stepSize) {
  var multiplier = 1 / Math.min(getDigits(limitSize), getDigits(stepSize));
  return Math.ceil(limitSize * multiplier / (stepSize * multiplier));
}

function hasStepSize(stepSize) {
  return isNumber(stepSize);
}

function getNormalizedScale(scaleData, scale) {
  var stepSize = hasStepSize(scale.stepSize) ? scaleData.stepSize : getNormalizedStep(scaleData.stepSize);
  var edge = getNormalizedLimit(scaleData.limit, stepSize);
  var limitSize = Math.abs(edge.max - edge.min);
  var stepCount = getNormalizedStepCount(limitSize, stepSize);
  return {
    limit: {
      min: edge.min,
      max: edge.max
    },
    stepSize: stepSize,
    stepCount: stepCount
  };
}

function getRoughScale(scale, offsetSize) {
  var minStepSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var min = scale.min,
      max = scale.max;
  var limitSize = Math.abs(max - min);
  var valuePerPixel = limitSize / offsetSize;
  var stepCount = Math.ceil(offsetSize / DEFAULT_PIXELS_PER_STEP);
  var pixelsPerStep = offsetSize / stepCount;
  var stepSize = valuePerPixel * pixelsPerStep;

  if (hasStepSize(scale.stepSize)) {
    stepSize = scale.stepSize;
    stepCount = limitSize / stepSize;
  } else if (isNumber(minStepSize) && stepSize < minStepSize) {
    stepSize = minStepSize;
    stepCount = limitSize / stepSize;
  }

  return {
    limit: {
      min: min,
      max: max
    },
    stepSize: stepSize,
    stepCount: stepCount
  };
}

function makeScaleOption(dataRange, scaleOptions) {
  var _scaleOptions$max, _scaleOptions$min, _scaleOptions$stepSiz;

  return {
    max: (_scaleOptions$max = scaleOptions === null || scaleOptions === void 0 ? void 0 : scaleOptions.max) !== null && _scaleOptions$max !== void 0 ? _scaleOptions$max : dataRange.max,
    min: (_scaleOptions$min = scaleOptions === null || scaleOptions === void 0 ? void 0 : scaleOptions.min) !== null && _scaleOptions$min !== void 0 ? _scaleOptions$min : dataRange.min,
    stepSize: (_scaleOptions$stepSiz = scaleOptions === null || scaleOptions === void 0 ? void 0 : scaleOptions.stepSize) !== null && _scaleOptions$stepSiz !== void 0 ? _scaleOptions$stepSiz : 'auto'
  };
}
function calculateCoordinateScale(options) {
  var dataRange = options.dataRange,
      scaleOption = options.scaleOption,
      offsetSize = options.offsetSize,
      minStepSize = options.minStepSize,
      useSpectrumLegend = options.useSpectrumLegend;
  var scale = makeScaleOption(dataRange, scaleOption);
  var roughScale = getRoughScale(scale, offsetSize, minStepSize);
  var normalizedScale = getNormalizedScale(roughScale, scale);
  var overflowed = useSpectrumLegend ? null : isSeriesOverflowed(normalizedScale, scale, scaleOption);

  if (overflowed) {
    var stepSize = normalizedScale.stepSize,
        limit = normalizedScale.limit;
    normalizedScale.limit = adjustLimitForOverflow(limit, stepSize, overflowed);
  }

  return normalizedScale;
}
function getStackScaleData(type) {
  if (type === 'minusPercentStack') {
    return {
      limit: {
        min: -100,
        max: 0
      },
      stepSize: 25,
      stepCount: 5
    };
  }

  if (type === 'dualPercentStack') {
    return {
      limit: {
        min: -100,
        max: 100
      },
      stepSize: 25,
      stepCount: 9
    };
  }

  if (type === 'divergingPercentStack') {
    return {
      limit: {
        min: -100,
        max: 100
      },
      stepSize: 25,
      stepCount: 9
    };
  }

  return {
    limit: {
      min: 0,
      max: 100
    },
    stepSize: 25,
    stepCount: 5
  };
}
function calculateScaleForCoordinateLineType(scale, options, categories) {
  var _options$xAxis;

  if (!categories) {
    return scale;
  }

  var dateType = !!(options === null || options === void 0 ? void 0 : (_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : _options$xAxis.date);
  var values = categories.map(function (value) {
    return dateType ? Number(new Date(value)) : Number(value);
  });
  var limit = scale.limit,
      stepSize = scale.stepSize;
  var min = Math.min.apply(Math, coordinateScaleCalculator_toConsumableArray(values));
  var max = Math.max.apply(Math, coordinateScaleCalculator_toConsumableArray(values));

  var newLimit = coordinateScaleCalculator_objectSpread({}, limit);

  if (max - min) {
    if (limit.min < min && limit.min + stepSize <= min) {
      newLimit.min += stepSize;
    }

    if (limit.max > max && limit.max - stepSize >= max) {
      newLimit.max -= stepSize;
    }
  }

  var limitSize = Math.abs(newLimit.max - newLimit.min);
  var newStepCount = getNormalizedStepCount(limitSize, stepSize);
  return {
    limit: newLimit,
    stepCount: newStepCount,
    stepSize: stepSize
  };
}
// CONCATENATED MODULE: ./src/scale/datetimeScaleCalculator.ts










function datetimeScaleCalculator_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function datetimeScaleCalculator_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { datetimeScaleCalculator_ownKeys(Object(source), true).forEach(function (key) { datetimeScaleCalculator_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { datetimeScaleCalculator_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function datetimeScaleCalculator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var msMap = {
  year: 31536000000,
  month: 2678400000,
  week: 604800000,
  date: 86400000,
  hour: 3600000,
  minute: 60000,
  second: 1000
};
function calculateDatetimeScale(options) {
  var dataRange = options.dataRange,
      rawCategoriesSize = options.rawCategoriesSize,
      scaleOption = options.scaleOption;
  var datetimeInfo = makeDatetimeInfo(dataRange, rawCategoriesSize, scaleOption);
  var minDate = datetimeInfo.minDate,
      divisionNumber = datetimeInfo.divisionNumber,
      limit = datetimeInfo.limit;
  var scale = calculateCoordinateScale(datetimeScaleCalculator_objectSpread(datetimeScaleCalculator_objectSpread({}, omit(options, 'scaleOption')), {}, {
    dataRange: limit,
    minStepSize: 1
  }));
  return restoreScaleToDatetimeType(scale, minDate, divisionNumber);
}
var msTypes = ['year', 'month', 'week', 'date', 'hour', 'minute', 'second'];

function restoreScaleToDatetimeType(scale, minDate, divisionNumber) {
  var limit = scale.limit,
      stepSize = scale.stepSize;
  var min = limit.min,
      max = limit.max;
  return datetimeScaleCalculator_objectSpread(datetimeScaleCalculator_objectSpread({}, scale), {}, {
    stepSize: multiply(stepSize, divisionNumber),
    limit: {
      min: multiply(calculator_add(min, minDate), divisionNumber),
      max: multiply(calculator_add(max, minDate), divisionNumber)
    }
  });
}

function makeDatetimeInfo(limit, count, scaleOption) {
  var _scaleOption$stepSize;

  var dateType = findDateType(limit, count);
  var divisionNumber = (_scaleOption$stepSize = scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.stepSize) !== null && _scaleOption$stepSize !== void 0 ? _scaleOption$stepSize : msMap[dateType];
  var scale = makeScaleOption(limit, scaleOption);
  var minDate = divide(Number(new Date(scale.min)), divisionNumber);
  var maxDate = divide(Number(new Date(scale.max)), divisionNumber);
  return {
    divisionNumber: divisionNumber,
    minDate: minDate,
    limit: {
      min: 0,
      max: maxDate - minDate
    }
  };
}

function findDateType(_ref, count) {
  var max = _ref.max,
      min = _ref.min;
  var diff = max - min;
  var lastTypeIndex = msTypes.length - 1;
  var foundType;

  if (diff) {
    msTypes.every(function (type, index) {
      var millisecond = msMap[type];
      var dividedCount = Math.floor(diff / millisecond);
      var foundIndex;

      if (dividedCount) {
        foundIndex = index < lastTypeIndex && dividedCount < 2 && dividedCount < count ? index + 1 : index;
        foundType = msTypes[foundIndex];
      }

      return !isExist(foundIndex);
    });
  } else {
    foundType = 'second';
  }

  return foundType;
}
// CONCATENATED MODULE: ./src/store/stackSeriesData.ts






















function stackSeriesData_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function stackSeriesData_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { stackSeriesData_ownKeys(Object(source), true).forEach(function (key) { stackSeriesData_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { stackSeriesData_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function stackSeriesData_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function stackSeriesData_toConsumableArray(arr) { return stackSeriesData_arrayWithoutHoles(arr) || stackSeriesData_iterableToArray(arr) || stackSeriesData_unsupportedIterableToArray(arr) || stackSeriesData_nonIterableSpread(); }

function stackSeriesData_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function stackSeriesData_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return stackSeriesData_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return stackSeriesData_arrayLikeToArray(o, minLen); }

function stackSeriesData_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function stackSeriesData_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return stackSeriesData_arrayLikeToArray(arr); }

function stackSeriesData_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



function isPercentStack(stack) {
  return !!((stack === null || stack === void 0 ? void 0 : stack.type) === 'percent');
}
function isGroupStack(rawData) {
  return !Array.isArray(rawData);
}
function hasPercentStackSeries(stackSeries) {
  if (!stackSeries) {
    return false;
  }

  return Object.keys(stackSeries).some(function (seriesName) {
    return isPercentStack(stackSeries[seriesName].stack);
  });
}
function pickStackOption(options) {
  return pickProperty(options, ['series', 'stack']) || pickProperty(options, ['series', 'column', 'stack']) || pickProperty(options, ['series', 'area', 'stack']);
}

function makeStackData(seriesData) {
  var seriesCount = seriesData.length;
  var groupCountLengths = seriesData.map(function (_ref) {
    var rawData = _ref.rawData;
    return rawData.length;
  });
  var seriesGroupCount = Math.max.apply(Math, stackSeriesData_toConsumableArray(groupCountLengths));
  var stackData = [];

  for (var i = 0; i < seriesGroupCount; i += 1) {
    var stackValues = [];

    for (var j = 0; j < seriesCount; j += 1) {
      stackValues.push(seriesData[j].rawData[i]);
    }

    stackData[i] = {
      values: stackValues,
      sum: sum(stackValues),
      total: {
        positive: sum(stackValues.filter(function (value) {
          return value >= 0;
        })),
        negative: sum(stackValues.filter(function (value) {
          return value < 0;
        }))
      }
    };
  }

  return stackData;
}

function makeStackGroupData(seriesData) {
  var stackData = {};

  var stackGroupIds = stackSeriesData_toConsumableArray(new Set(seriesData.map(function (_ref2) {
    var stackGroup = _ref2.stackGroup;
    return stackGroup;
  })));

  stackGroupIds.forEach(function (groupId) {
    var filtered = seriesData.filter(function (_ref3) {
      var stackGroup = _ref3.stackGroup;
      return groupId === stackGroup;
    });
    stackData[groupId] = makeStackData(filtered);
  });
  return stackData;
}

function initializeStack(stackOption) {
  if (!stackOption) {
    return;
  }

  var defaultStackOption = {
    type: 'normal',
    connector: false
  };

  if (isStackObject(stackOption)) {
    return stackSeriesData_objectSpread(stackSeriesData_objectSpread({}, defaultStackOption), stackOption);
  }

  return defaultStackOption;
}

function isStackObject(stackOption) {
  return isObject(stackOption);
}

function hasStackGrouped(seriesRawData) {
  return seriesRawData.some(function (rawData) {
    return rawData.hasOwnProperty('stackGroup');
  });
}

function getStackDataRangeValues(stackData) {
  var values = [];

  if (Array.isArray(stackData)) {
    values = [0].concat(stackSeriesData_toConsumableArray(getSumValues(stackData)));
  } else {
    for (var groupId in stackData) {
      if (Object.prototype.hasOwnProperty.call(stackData, groupId)) {
        values = [0].concat(stackSeriesData_toConsumableArray(values), stackSeriesData_toConsumableArray(getSumValues(stackData[groupId])));
      }
    }
  }

  return values;
}

function getSumValues(stackData) {
  var positiveSum = stackData.map(function (_ref4) {
    var total = _ref4.total;
    return total.positive;
  });
  var negativeSum = stackData.map(function (_ref5) {
    var total = _ref5.total;
    return total.negative;
  });
  return [].concat(stackSeriesData_toConsumableArray(negativeSum), stackSeriesData_toConsumableArray(positiveSum));
}

function getStackDataValues(stackData) {
  if (!isGroupStack(stackData)) {
    return stackData;
  }

  var stackDataValues = [];

  if (isGroupStack(stackData)) {
    Object.keys(stackData).forEach(function (groupId) {
      stackDataValues = [].concat(stackSeriesData_toConsumableArray(stackDataValues), stackSeriesData_toConsumableArray(stackData[groupId]));
    });
  }

  return stackDataValues;
}

function checkIfNegativeAndPositiveValues(stackData) {
  return {
    hasNegative: stackData.map(function (_ref6) {
      var total = _ref6.total;
      return total.negative;
    }).some(function (total) {
      return total < 0;
    }),
    hasPositive: stackData.map(function (_ref7) {
      var total = _ref7.total;
      return total.positive;
    }).some(function (total) {
      return total >= 0;
    })
  };
}

function getScaleType(stackData, stackType, diverging) {
  var _checkIfNegativeAndPo = checkIfNegativeAndPositiveValues(stackData),
      hasPositive = _checkIfNegativeAndPo.hasPositive,
      hasNegative = _checkIfNegativeAndPo.hasNegative;

  if (stackType === 'percent') {
    if (diverging) {
      return 'divergingPercentStack';
    }

    if (hasNegative && hasPositive) {
      return 'dualPercentStack';
    }

    if (!hasNegative && hasPositive) {
      return 'percentStack';
    }

    if (hasNegative && !hasPositive) {
      return 'minusPercentStack';
    }
  }
}

function initStackSeries(series, options) {
  var stackSeries = {};
  Object.keys(series).forEach(function (seriesName) {
    var chartType = seriesName;
    var stackOption = pickStackOption(options);

    if (stackOption) {
      if (!stackSeries[chartType]) {
        stackSeries[chartType] = {};
      }

      stackSeries[chartType].stack = initializeStack(stackOption);
    }
  });
  return stackSeries;
}

var stackSeriesData_stackSeriesData = {
  name: 'stackSeriesData',
  state: function state(_ref8) {
    var series = _ref8.series,
        options = _ref8.options;
    return {
      stackSeries: initStackSeries(series, options)
    };
  },
  action: {
    setStackSeriesData: function setStackSeriesData(_ref9) {
      var state = _ref9.state;
      var series = state.series,
          stackSeries = state.stackSeries,
          options = state.options;
      var stackOption = pickStackOption(options);
      var newStackSeries = {};
      Object.keys(series).forEach(function (seriesName) {
        var _ref11;

        var seriesData = series[seriesName];
        var data = seriesData.data,
            seriesCount = seriesData.seriesCount,
            seriesGroupCount = seriesData.seriesGroupCount;

        if (stackOption) {
          if (!stackSeries[seriesName]) {
            stackSeries[seriesName] = {};
          }

          stackSeries[seriesName].stack = initializeStack(stackOption);
        } else {
          stackSeries[seriesName] = null;
          delete stackSeries[seriesName];
        }

        var _ref10 = stackSeries[seriesName] || {},
            stack = _ref10.stack;

        var diverging = !!((_ref11 = options.series) === null || _ref11 === void 0 ? void 0 : _ref11.diverging);

        if (stack) {
          var stackData = hasStackGrouped(data) ? makeStackGroupData(data) : makeStackData(data);
          var stackType = stack.type;
          var dataRangeValues = getStackDataRangeValues(stackData);
          newStackSeries[seriesName] = {
            data: data,
            seriesCount: seriesCount,
            seriesGroupCount: seriesGroupCount,
            stackData: stackData,
            dataRangeValues: dataRangeValues,
            scaleType: getScaleType(getStackDataValues(stackData), stackType, diverging)
          };
          state.stackSeries[seriesName].stackData = stackData;
        }

        store_extend(state.stackSeries, newStackSeries);
      });
    }
  },
  observe: {
    updateStackSeriesData: function updateStackSeriesData() {
      this.dispatch('setStackSeriesData');
    }
  }
};
/* harmony default export */ var store_stackSeriesData = (stackSeriesData_stackSeriesData);
// CONCATENATED MODULE: ./src/store/scale.ts











function getLabelScaleData(state, labelAxisOnYAxis, scaleOptions, labelAxisName) {
  var _options$xAxis;

  var dataRange = state.dataRange,
      layout = state.layout,
      series = state.series,
      options = state.options;
  var categories = state.categories;
  var rawCategories = state.rawCategories;

  var _getSizeKey = getSizeKey(labelAxisOnYAxis),
      labelSizeKey = _getSizeKey.labelSizeKey;

  var dateTypeLabel = isExist((_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : _options$xAxis.date);
  var labelOptions = {
    dataRange: dataRange[labelAxisName],
    offsetSize: layout.plot[labelSizeKey],
    scaleOption: scaleOptions[labelAxisName],
    rawCategoriesSize: rawCategories.length
  };
  var result;

  if (dataRange[labelAxisName]) {
    result = dateTypeLabel ? calculateDatetimeScale(labelOptions) : calculateCoordinateScale(labelOptions);
  }

  if (series.line) {
    result = calculateScaleForCoordinateLineType(result, options, categories);
  }

  return result;
}

function getValueScaleData(state, labelAxisOnYAxis, scaleOptions, valueAxisName) {
  var dataRange = state.dataRange,
      layout = state.layout,
      series = state.series,
      stackSeries = state.stackSeries;

  var _getSizeKey2 = getSizeKey(labelAxisOnYAxis),
      valueSizeKey = _getSizeKey2.valueSizeKey;

  var result;

  if (hasPercentStackSeries(stackSeries)) {
    Object.keys(series).forEach(function (seriesName) {
      result = getStackScaleData(stackSeries[seriesName].scaleType);
    });
  } else if (isCoordinateSeries(series)) {
    var valueOptions = {
      dataRange: dataRange[valueAxisName],
      offsetSize: layout.plot[valueSizeKey],
      scaleOption: scaleOptions[valueAxisName]
    };
    result = calculateCoordinateScale(valueOptions);
  } else {
    result = calculateCoordinateScale({
      dataRange: dataRange[valueAxisName],
      offsetSize: layout.plot[valueSizeKey],
      scaleOption: scaleOptions[valueAxisName]
    });
  }

  return result;
}

var scale_scale = {
  name: 'scale',
  state: function state() {
    return {
      scale: {}
    };
  },
  action: {
    setScale: function setScale(_ref) {
      var _options$xAxis2;

      var state = _ref.state;
      var series = state.series,
          options = state.options;
      var labelAxisOnYAxis = isLabelAxisOnYAxis(series, options);

      var _getAxisName = getAxisName(labelAxisOnYAxis),
          labelAxisName = _getAxisName.labelAxisName,
          valueAxisName = _getAxisName.valueAxisName;

      var _getYAxisOption = getYAxisOption(options),
          yAxis = _getYAxisOption.yAxis,
          secondaryYAxis = _getYAxisOption.secondaryYAxis;

      var scaleData = {};
      var scaleOptions = {
        xAxis: options === null || options === void 0 ? void 0 : (_options$xAxis2 = options.xAxis) === null || _options$xAxis2 === void 0 ? void 0 : _options$xAxis2.scale,
        yAxis: yAxis === null || yAxis === void 0 ? void 0 : yAxis.scale
      };

      if (secondaryYAxis) {
        scaleOptions.secondaryYAxis = secondaryYAxis === null || secondaryYAxis === void 0 ? void 0 : secondaryYAxis.scale;
      }

      getValueAxisNames(options, valueAxisName).forEach(function (axisName) {
        scaleData[axisName] = getValueScaleData(state, labelAxisOnYAxis, scaleOptions, axisName);
      });

      if (isCoordinateSeries(series)) {
        scaleData[labelAxisName] = getLabelScaleData(state, labelAxisOnYAxis, scaleOptions, labelAxisName);
      }

      store_extend(state.scale, scaleData);
    }
  },
  observe: {
    updateScale: function updateScale() {
      this.dispatch('setScale');
    }
  }
};
/* harmony default export */ var store_scale = (scale_scale);
// CONCATENATED MODULE: ./src/store/plot.ts























function plot_toConsumableArray(arr) { return plot_arrayWithoutHoles(arr) || plot_iterableToArray(arr) || plot_unsupportedIterableToArray(arr) || plot_nonIterableSpread(); }

function plot_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function plot_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function plot_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return plot_arrayLikeToArray(arr); }

function plot_slicedToArray(arr, i) { return plot_arrayWithHoles(arr) || plot_iterableToArrayLimit(arr, i) || plot_unsupportedIterableToArray(arr, i) || plot_nonIterableRest(); }

function plot_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function plot_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return plot_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return plot_arrayLikeToArray(o, minLen); }

function plot_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function plot_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function plot_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






function getOverlappingRange(range) {
  return range.reduce(function (acc, rangeData) {
    var _acc = plot_slicedToArray(acc, 2),
        accStart = _acc[0],
        accEnd = _acc[1];

    var _rangeData = plot_slicedToArray(rangeData, 2),
        start = _rangeData[0],
        end = _rangeData[1];

    return [Math.min(accStart, start), Math.max(accEnd, end)];
  }, [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);
}

function getCategoryIndex(value, categories) {
  return categories.findIndex(function (category) {
    return category === String(value);
  });
}

function getValidValue(value, categories) {
  var isDateType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (isDateType) {
    return Number(new Date(value));
  }

  if (isString(value)) {
    return getCategoryIndex(value, categories);
  }

  return value;
}

function makePlotLines(categories, isDateType) {
  var plotLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  return plotLines.map(function (_ref) {
    var value = _ref.value,
        color = _ref.color,
        opacity = _ref.opacity;
    return {
      value: getValidValue(value, categories, isDateType),
      color: rgba(color, opacity)
    };
  });
}

function makePlotBands(categories, isDateType) {
  var plotBands = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  return plotBands.flatMap(function (_ref2) {
    var range = _ref2.range,
        _ref2$mergeOverlappin = _ref2.mergeOverlappingRanges,
        mergeOverlappingRanges = _ref2$mergeOverlappin === void 0 ? false : _ref2$mergeOverlappin,
        bgColor = _ref2.color,
        opacity = _ref2.opacity;
    var color = rgba(bgColor, opacity);

    if (isRangeValue(range[0])) {
      var ranges = range.map(function (rangeData) {
        return rangeData.map(function (value) {
          return getValidValue(value, categories, isDateType);
        });
      });

      if (mergeOverlappingRanges) {
        return {
          color: color,
          range: getOverlappingRange(ranges)
        };
      }

      return ranges.map(function (rangeData) {
        return {
          range: rangeData,
          color: color
        };
      });
    }

    return {
      color: color,
      range: range
    };
  });
}

function isExistPlotId(plots, data) {
  return plots.some(function (_ref3) {
    var bandId = _ref3.id;
    return !isUndefined(bandId) && !isUndefined(data.id) && bandId === data.id;
  });
}

var plot_plot = {
  name: 'plot',
  state: function state(_ref4) {
    var _plot$visible, _ref5, _ref5$plot;

    var options = _ref4.options;
    return {
      plot: {
        visible: (_plot$visible = (_ref5 = options) === null || _ref5 === void 0 ? void 0 : (_ref5$plot = _ref5.plot) === null || _ref5$plot === void 0 ? void 0 : _ref5$plot.visible) !== null && _plot$visible !== void 0 ? _plot$visible : true,
        lines: [],
        bands: []
      }
    };
  },
  action: {
    setPlot: function setPlot(_ref6) {
      var _options$xAxis, _lineAreaOptions$plot, _options$xAxis2, _lineAreaOptions$plot2;

      var state = _ref6.state;
      var series = state.series,
          options = state.options;

      if (!(series.area || series.line)) {
        return;
      }

      var rawCategories = state.rawCategories;
      var lineAreaOptions = options;
      var lines = makePlotLines(rawCategories, !!(options === null || options === void 0 ? void 0 : (_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : _options$xAxis.date), lineAreaOptions === null || lineAreaOptions === void 0 ? void 0 : (_lineAreaOptions$plot = lineAreaOptions.plot) === null || _lineAreaOptions$plot === void 0 ? void 0 : _lineAreaOptions$plot.lines);
      var bands = makePlotBands(rawCategories, !!(options === null || options === void 0 ? void 0 : (_options$xAxis2 = options.xAxis) === null || _options$xAxis2 === void 0 ? void 0 : _options$xAxis2.date), lineAreaOptions === null || lineAreaOptions === void 0 ? void 0 : (_lineAreaOptions$plot2 = lineAreaOptions.plot) === null || _lineAreaOptions$plot2 === void 0 ? void 0 : _lineAreaOptions$plot2.bands);
      store_extend(state.plot, {
        lines: lines,
        bands: bands
      });
    },
    addPlotLine: function addPlotLine(_ref7, _ref8) {
      var _plot$lines, _ref9, _ref9$plot;

      var state = _ref7.state;
      var data = _ref8.data;
      var lines = (_plot$lines = (_ref9 = state.options) === null || _ref9 === void 0 ? void 0 : (_ref9$plot = _ref9.plot) === null || _ref9$plot === void 0 ? void 0 : _ref9$plot.lines) !== null && _plot$lines !== void 0 ? _plot$lines : [];

      if (!isExistPlotId(lines, data)) {
        this.dispatch('updateOptions', {
          options: {
            plot: {
              lines: [].concat(plot_toConsumableArray(lines), [data])
            }
          }
        });
      }
    },
    addPlotBand: function addPlotBand(_ref10, _ref11) {
      var _plot$bands, _ref12, _ref12$plot;

      var state = _ref10.state;
      var data = _ref11.data;
      var bands = (_plot$bands = (_ref12 = state.options) === null || _ref12 === void 0 ? void 0 : (_ref12$plot = _ref12.plot) === null || _ref12$plot === void 0 ? void 0 : _ref12$plot.bands) !== null && _plot$bands !== void 0 ? _plot$bands : [];

      if (!isExistPlotId(bands, data)) {
        this.dispatch('updateOptions', {
          options: {
            plot: {
              bands: [].concat(plot_toConsumableArray(bands), [data])
            }
          }
        });
      }
    },
    removePlotLine: function removePlotLine(_ref13, _ref14) {
      var _plot$lines2, _ref15, _ref15$plot;

      var state = _ref13.state;
      var id = _ref14.id;
      var lines = ((_plot$lines2 = (_ref15 = state.options) === null || _ref15 === void 0 ? void 0 : (_ref15$plot = _ref15.plot) === null || _ref15$plot === void 0 ? void 0 : _ref15$plot.lines) !== null && _plot$lines2 !== void 0 ? _plot$lines2 : []).filter(function (_ref16) {
        var lineId = _ref16.id;
        return lineId !== id;
      });
      this.dispatch('updateOptions', {
        options: {
          plot: {
            lines: lines
          }
        }
      });
    },
    removePlotBand: function removePlotBand(_ref17, _ref18) {
      var _plot$bands2, _ref19, _ref19$plot;

      var state = _ref17.state;
      var id = _ref18.id;
      var bands = ((_plot$bands2 = (_ref19 = state.options) === null || _ref19 === void 0 ? void 0 : (_ref19$plot = _ref19.plot) === null || _ref19$plot === void 0 ? void 0 : _ref19$plot.bands) !== null && _plot$bands2 !== void 0 ? _plot$bands2 : []).filter(function (_ref20) {
        var bandId = _ref20.id;
        return bandId !== id;
      });
      this.dispatch('updateOptions', {
        options: {
          plot: {
            bands: bands
          }
        }
      });
    }
  },
  observe: {
    updatePlot: function updatePlot() {
      this.dispatch('setPlot');
    }
  }
};
/* harmony default export */ var store_plot = (plot_plot);
// CONCATENATED MODULE: ./src/helpers/tooltip.ts




function isBubblePointType(value) {
  return value.hasOwnProperty('r');
}

function getValueString(value) {
  var result = '';

  if (isRangeValue(value)) {
    result = "".concat(value[0], " ~ ").concat(value[1]);
  } else if (isObject(value) && !Array.isArray(value)) {
    result = "(".concat(value.x, ", ").concat(value.y, ")") + (isBubblePointType(value) ? ", r: ".concat(value.r) : '');
  } else {
    result = String(value);
  }

  return result;
}
// CONCATENATED MODULE: ./src/helpers/tooltipTemplate.ts

















function tooltipTemplate_slicedToArray(arr, i) { return tooltipTemplate_arrayWithHoles(arr) || tooltipTemplate_iterableToArrayLimit(arr, i) || tooltipTemplate_unsupportedIterableToArray(arr, i) || tooltipTemplate_nonIterableRest(); }

function tooltipTemplate_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function tooltipTemplate_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function tooltipTemplate_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function tooltipTemplate_toConsumableArray(arr) { return tooltipTemplate_arrayWithoutHoles(arr) || tooltipTemplate_iterableToArray(arr) || tooltipTemplate_unsupportedIterableToArray(arr) || tooltipTemplate_nonIterableSpread(); }

function tooltipTemplate_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function tooltipTemplate_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return tooltipTemplate_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return tooltipTemplate_arrayLikeToArray(o, minLen); }

function tooltipTemplate_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function tooltipTemplate_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return tooltipTemplate_arrayLikeToArray(arr); }

function tooltipTemplate_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }






function getSeriesNameTemplate(label, color) {
  return "<span class=\"toastui-chart-series-name\">\n    <i class=\"toastui-chart-icon\" style=\"background: ".concat(color, "\"></i>\n    <span class=\"toastui-chart-name\">").concat(label, "</span>\n  </span>");
}

function getTitleValueTemplate(title, value) {
  return "<div class=\"toastui-chart-tooltip-series\">\n    <span class=\"toastui-chart-series-name\">".concat(title, "</span>\n    <span class=\"toastui-chart-series-value\">").concat(value, "</span>\n  </div>");
}

function getColorValueTemplate(color, value) {
  return "<div class=\"toastui-chart-tooltip-series\">\n    <i class=\"toastui-chart-icon\" style=\"background: ".concat(color, "\"></i>\n    <span class=\"toastui-chart-series-value\">").concat(value, "</span>\n  </div>");
}

function makeBulletDataTemplate(data, titleType) {
  return data.filter(function (_ref) {
    var title = _ref.title;
    return title === titleType;
  }).sort(function (a, b) {
    if (isRangeValue(a.value) && isRangeValue(b.value)) {
      return a.value[0] - b.value[0];
    }

    if (isNumber(a.value) && isNumber(b.value)) {
      return a.value - b.value;
    }

    return 0;
  }).map(function (_ref2) {
    var formattedValue = _ref2.formattedValue,
        color = _ref2.color;
    return getColorValueTemplate(color, formattedValue);
  }).join('');
}

function getDefaultTemplate(model, _ref3, theme) {
  var header = _ref3.header,
      body = _ref3.body;
  var borderColor = theme.borderColor,
      borderWidth = theme.borderWidth,
      background = theme.background,
      borderRadius = theme.borderRadius,
      borderStyle = theme.borderStyle;
  var style = "border: ".concat(borderWidth, "px ").concat(borderStyle, " ").concat(borderColor, ";border-radius: ").concat(borderRadius, "px;background: ").concat(background, ";");
  return "<div class=\"toastui-chart-tooltip\" style=\"".concat(style, "\">").concat(header).concat(body, "</div>");
}
function getHeaderTemplate(_ref4, theme) {
  var category = _ref4.category;
  return category ? "<div class=\"toastui-chart-tooltip-category\" style=\"".concat(getFontStyleString(theme.header), "\">\n        ").concat(category, "\n      </div>") : '';
}

function getDefaultBodyTemplate(_ref5, theme) {
  var data = _ref5.data;
  return "\n    <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"".concat(getFontStyleString(theme.body), "\">\n      ").concat(data.map(function (_ref6) {
    var label = _ref6.label,
        color = _ref6.color,
        formattedValue = _ref6.formattedValue;
    return "<div class=\"toastui-chart-tooltip-series\">\n                ".concat(getSeriesNameTemplate(label, color), "\n                <span class=\"toastui-chart-series-value\">").concat(formattedValue, "</span>\n              </div>");
  }).join(''), "\n    </div>");
}

function getBoxPlotTemplate(_ref7, theme) {
  var data = _ref7.data;
  var groupedData = data.reduce(function (acc, item, index) {
    if (!index) {
      return item;
    }

    if (acc.category === item.category && acc.label === item.label) {
      acc.value = [].concat(tooltipTemplate_toConsumableArray(acc.value), tooltipTemplate_toConsumableArray(item.value));
    }

    return acc;
  }, {});
  return "\n    <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"".concat(getFontStyleString(theme.body), "\">\n      ").concat([groupedData].map(function (_ref8) {
    var label = _ref8.label,
        color = _ref8.color,
        values = _ref8.value;
    return "<div class=\"toastui-chart-tooltip-series\">\n              ".concat(getSeriesNameTemplate(label, color), "\n            </div>\n            <div>\n          ").concat(values.map(function (_ref9) {
      var title = _ref9.title,
          formattedValue = _ref9.formattedValue;
      return getTitleValueTemplate(title, formattedValue);
    }).join(''), "\n            </div>");
  }).join(''), "\n    </div>");
}

function getBulletTemplate(_ref10, theme) {
  var data = _ref10.data;
  return data.length > 1 ? getBulletGroupedTemplate(data, theme) : getBulletBasicTemplate(data, theme);
}

function getBulletBasicTemplate(data, theme) {
  return "\n    <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"".concat(getFontStyleString(theme.body), "\">\n      ").concat(data.map(function (_ref11) {
    var label = _ref11.label,
        color = _ref11.color,
        values = _ref11.value;
    return "<div class=\"toastui-chart-tooltip-series\">".concat(getSeriesNameTemplate(label, color), "</div>\n            ").concat(values.map(function (_ref12) {
      var title = _ref12.title,
          formattedValue = _ref12.formattedValue;
      return getTitleValueTemplate(title, formattedValue);
    }).join(''));
  }).join(''), "\n    </div>");
}

function getBulletGroupedTemplate(data, theme) {
  var bulletData = data.map(function (_ref13) {
    var value = _ref13.value;
    return value[0];
  });

  var _map = ['Actual', 'Range', 'Marker'].map(function (titleType) {
    return makeBulletDataTemplate(bulletData, titleType);
  }),
      _map2 = tooltipTemplate_slicedToArray(_map, 3),
      actual = _map2[0],
      ranges = _map2[1],
      markers = _map2[2];

  return "<div class=\"toastui-chart-tooltip-category\" style=\"".concat(getFontStyleString(theme.header), "\">\n      ").concat(data[0].label, "\n    </div>\n    <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"").concat(getFontStyleString(theme.body), "\">\n      ").concat(actual ? '<div class="toastui-chart-tooltip-title">Actual</div>' : '', " ").concat(actual, "\n      ").concat(ranges ? '<div class="toastui-chart-tooltip-title">Ranges</div>' : '', " ").concat(ranges, "\n      ").concat(markers ? '<div class="toastui-chart-tooltip-title">Markers</div>' : '', " ").concat(markers, "\n    </div>");
}

function getPieTemplate(_ref14, theme) {
  var data = _ref14.data;
  return "\n    <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"".concat(getFontStyleString(theme.body), "\">\n      ").concat(data.map(function (_ref15) {
    var label = _ref15.label,
        color = _ref15.color,
        formattedValue = _ref15.formattedValue,
        percentValue = _ref15.percentValue;
    return "<div class=\"toastui-chart-tooltip-series\">\n          ".concat(getSeriesNameTemplate(label, color), "\n          <span class=\"toastui-chart-series-value\">").concat(pieTooltipLabelFormatter(percentValue), "&nbsp;&nbsp;(").concat(formattedValue, ")</span>\n        </div>");
  }).join(''), "\n    </div>");
}

function getHeatmapTemplate(_ref16, theme) {
  var data = _ref16.data;
  return "".concat(data.map(function (_ref17) {
    var label = _ref17.label,
        color = _ref17.color,
        formattedValue = _ref17.formattedValue;
    return "<div class=\"toastui-chart-tooltip-category\" style=\"".concat(getFontStyleString(theme.header), "\">\n          ").concat(label, "\n        </div>\n        <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"").concat(getFontStyleString(theme.body), "\">\n          <div class=\"toastui-chart-tooltip-series\">\n            ").concat(getSeriesNameTemplate(formattedValue, color), "\n          </div>\n        </div>");
  }).join(''));
}

var tooltipTemplates = {
  default: getDefaultTemplate,
  defaultHeader: getHeaderTemplate,
  defaultBody: getDefaultBodyTemplate,
  boxPlot: getBoxPlotTemplate,
  bullet: getBulletTemplate,
  pie: getPieTemplate,
  heatmap: getHeatmapTemplate
};
function getBodyTemplate(type) {
  return tooltipTemplates[type || 'defaultBody'];
}
// CONCATENATED MODULE: ./src/component/tooltip.ts



























function tooltip_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { tooltip_typeof = function _typeof(obj) { return typeof obj; }; } else { tooltip_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return tooltip_typeof(obj); }

function tooltip_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function tooltip_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tooltip_ownKeys(Object(source), true).forEach(function (key) { tooltip_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tooltip_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function tooltip_toConsumableArray(arr) { return tooltip_arrayWithoutHoles(arr) || tooltip_iterableToArray(arr) || tooltip_unsupportedIterableToArray(arr) || tooltip_nonIterableSpread(); }

function tooltip_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function tooltip_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return tooltip_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return tooltip_arrayLikeToArray(o, minLen); }

function tooltip_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function tooltip_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return tooltip_arrayLikeToArray(arr); }

function tooltip_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function tooltip_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function tooltip_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function tooltip_createClass(Constructor, protoProps, staticProps) { if (protoProps) tooltip_defineProperties(Constructor.prototype, protoProps); if (staticProps) tooltip_defineProperties(Constructor, staticProps); return Constructor; }

function tooltip_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) tooltip_setPrototypeOf(subClass, superClass); }

function tooltip_setPrototypeOf(o, p) { tooltip_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return tooltip_setPrototypeOf(o, p); }

function tooltip_createSuper(Derived) { var hasNativeReflectConstruct = tooltip_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = tooltip_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = tooltip_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return tooltip_possibleConstructorReturn(this, result); }; }

function tooltip_possibleConstructorReturn(self, call) { if (call && (tooltip_typeof(call) === "object" || typeof call === "function")) { return call; } return tooltip_assertThisInitialized(self); }

function tooltip_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function tooltip_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function tooltip_getPrototypeOf(o) { tooltip_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return tooltip_getPrototypeOf(o); }

function tooltip_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var DEFAULT_TOOLTIP_TRANSITION = 'transform 0.2s ease';

var tooltip_Tooltip = /*#__PURE__*/function (_Component) {
  tooltip_inherits(Tooltip, _Component);

  var _super = tooltip_createSuper(Tooltip);

  function Tooltip() {
    var _this;

    tooltip_classCallCheck(this, Tooltip);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "chartEl", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "tooltipContainerEl", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "templateFunc", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "theme", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "offsetX", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "offsetY", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "formatter", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "tooltipInfoModels", {});

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "onSeriesPointHovered", function (_ref) {
      var models = _ref.models,
          name = _ref.name;
      _this.tooltipInfoModels[name] = (models === null || models === void 0 ? void 0 : models.length) ? tooltip_toConsumableArray(models) : [];
      var isShow = !!_this.getTooltipInfoModels().length;

      if (isShow) {
        _this.renderTooltip();
      } else {
        _this.removeTooltip();
      }
    });

    return _this;
  }

  tooltip_createClass(Tooltip, [{
    key: "isTooltipContainerOverflow",
    value: function isTooltipContainerOverflow(x, y) {
      var _this$tooltipContaine = this.tooltipContainerEl.getBoundingClientRect(),
          width = _this$tooltipContaine.width,
          height = _this$tooltipContaine.height;

      var _this$rect = this.rect,
          rectX = _this$rect.x,
          rectY = _this$rect.y,
          rectWidth = _this$rect.width,
          rectHeight = _this$rect.height;
      return {
        overflowX: x > rectX + rectWidth || x + width > rectX + rectWidth,
        overflowY: y > rectY + rectHeight || y + height > rectY + rectHeight
      };
    }
  }, {
    key: "getPositionInRect",
    value: function getPositionInRect(model) {
      var target = model.target;
      var startX = this.rect.x + model.x;
      var startY = this.rect.y + model.y;
      var x = startX + target.radius + target.width + this.offsetX;
      var y = startY + this.offsetY;

      var _this$isTooltipContai = this.isTooltipContainerOverflow(x, y),
          overflowX = _this$isTooltipContai.overflowX,
          overflowY = _this$isTooltipContai.overflowY;

      var _this$tooltipContaine2 = this.tooltipContainerEl.getBoundingClientRect(),
          width = _this$tooltipContaine2.width,
          height = _this$tooltipContaine2.height;

      if (overflowX) {
        x = startX - (width + target.radius + this.offsetX) > 0 ? startX - (width + target.radius + this.offsetX) : startX + this.offsetX;
      }

      if (overflowY) {
        y = startY + target.height - (height + this.offsetY) > 0 ? startY + target.height - (height + this.offsetY) : y;
      } // pageXOffset, pageYOffset for IE


      x += window.scrollX || window.pageXOffset;
      y += window.scrollY || window.pageYOffset;
      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "setTooltipPosition",
    value: function setTooltipPosition(model) {
      var _this$chartEl$getBoun = this.chartEl.getBoundingClientRect(),
          top = _this$chartEl$getBoun.top,
          left = _this$chartEl$getBoun.left;

      var _this$getPositionInRe = this.getPositionInRect(model),
          x = _this$getPositionInRe.x,
          y = _this$getPositionInRe.y;

      this.tooltipContainerEl.style.transform = getTranslateString(left + x, top + y);
    }
  }, {
    key: "getTooltipInfoModels",
    value: function getTooltipInfoModels() {
      return Object.values(this.tooltipInfoModels).flatMap(function (item) {
        return item;
      });
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      var _this2 = this;

      var model = this.getTooltipInfoModels().reduce(function (acc, item) {
        var data = item.data,
            x = item.x,
            y = item.y,
            radius = item.radius,
            width = item.width,
            height = item.height;
        acc.x = acc.x ? (acc.x + x) / 2 : x;
        acc.y = acc.y ? (acc.y + y) / 2 : y;

        if (isNumber(radius)) {
          acc.target.radius = radius;
        }

        if (width) {
          acc.target.width = width;
        }

        if (height) {
          acc.target.height = height;
        }

        acc.data.push(tooltip_objectSpread(tooltip_objectSpread({}, data), {}, {
          value: Array.isArray(data.value) ? data.value.map(function (titleValue) {
            return tooltip_objectSpread(tooltip_objectSpread({}, titleValue), {}, {
              formattedValue: _this2.getFormattedValue(titleValue.value, data)
            });
          }) : data.value,
          formattedValue: _this2.getFormattedValue(data.value, data)
        }));

        if (!acc.category && data.category) {
          acc.category = data.category;
        }

        if (data.templateType) {
          acc.templateType = data.templateType;
        }

        return acc;
      }, {
        type: 'tooltip',
        x: 0,
        y: 0,
        data: [],
        target: {
          radius: 0,
          width: 0,
          height: 0
        }
      });
      this.tooltipContainerEl.innerHTML = this.templateFunc(model, {
        header: tooltipTemplates.defaultHeader(model, this.theme),
        body: getBodyTemplate(model.templateType)(model, this.theme)
      }, this.theme);
      this.setTooltipPosition(model);
    }
  }, {
    key: "initialize",
    value: function initialize(_ref2) {
      var chartEl = _ref2.chartEl;
      this.type = 'tooltip';
      this.name = 'tooltip';
      this.chartEl = chartEl;
      this.tooltipContainerEl = document.createElement('div');
      this.tooltipContainerEl.classList.add('toastui-chart-tooltip-container');

      var _this$chartEl$getBoun2 = this.chartEl.getBoundingClientRect(),
          width = _this$chartEl$getBoun2.width,
          height = _this$chartEl$getBoun2.height,
          top = _this$chartEl$getBoun2.top,
          left = _this$chartEl$getBoun2.left;

      this.tooltipContainerEl.style.transform = getTranslateString(left + width / 2, top + height / 2);
      this.chartEl.appendChild(this.tooltipContainerEl);
      this.eventBus.on('seriesPointHovered', this.onSeriesPointHovered);
    }
  }, {
    key: "removeTooltip",
    value: function removeTooltip() {
      this.tooltipContainerEl.innerHTML = '';
    }
  }, {
    key: "setTooltipTransition",
    value: function setTooltipTransition(options) {
      var _options$tooltip;

      var transition = (_options$tooltip = options.tooltip) === null || _options$tooltip === void 0 ? void 0 : _options$tooltip.transition;

      if (isBoolean(transition) && transition) {
        this.tooltipContainerEl.style.transition = DEFAULT_TOOLTIP_TRANSITION;
      } else if (isString(transition)) {
        this.tooltipContainerEl.style.transition = transition;
      }
    }
  }, {
    key: "render",
    value: function render(_ref3) {
      var _options$tooltip$temp, _options$tooltip2, _options$tooltip$offs, _options$tooltip3, _options$tooltip$offs2, _options$tooltip4, _options$tooltip5;

      var layout = _ref3.layout,
          options = _ref3.options,
          theme = _ref3.theme;
      this.setTooltipTransition(options);
      this.rect = layout.plot;
      this.theme = theme.tooltip;
      this.templateFunc = (_options$tooltip$temp = options === null || options === void 0 ? void 0 : (_options$tooltip2 = options.tooltip) === null || _options$tooltip2 === void 0 ? void 0 : _options$tooltip2.template) !== null && _options$tooltip$temp !== void 0 ? _options$tooltip$temp : tooltipTemplates['default'];
      this.offsetX = (_options$tooltip$offs = options === null || options === void 0 ? void 0 : (_options$tooltip3 = options.tooltip) === null || _options$tooltip3 === void 0 ? void 0 : _options$tooltip3.offsetX) !== null && _options$tooltip$offs !== void 0 ? _options$tooltip$offs : 10;
      this.offsetY = (_options$tooltip$offs2 = options === null || options === void 0 ? void 0 : (_options$tooltip4 = options.tooltip) === null || _options$tooltip4 === void 0 ? void 0 : _options$tooltip4.offsetY) !== null && _options$tooltip$offs2 !== void 0 ? _options$tooltip$offs2 : 0;
      this.formatter = options === null || options === void 0 ? void 0 : (_options$tooltip5 = options.tooltip) === null || _options$tooltip5 === void 0 ? void 0 : _options$tooltip5.formatter;
    }
  }, {
    key: "getFormattedValue",
    value: function getFormattedValue(value, tooltipDataInfo) {
      return this.formatter ? this.formatter(value, tooltipDataInfo) : getValueString(value);
    }
  }]);

  return Tooltip;
}(component_Component);


// CONCATENATED MODULE: ./src/component/plot.ts























function plot_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { plot_typeof = function _typeof(obj) { return typeof obj; }; } else { plot_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return plot_typeof(obj); }

function plot_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function plot_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { plot_ownKeys(Object(source), true).forEach(function (key) { plot_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { plot_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function component_plot_toConsumableArray(arr) { return component_plot_arrayWithoutHoles(arr) || component_plot_iterableToArray(arr) || component_plot_unsupportedIterableToArray(arr) || component_plot_nonIterableSpread(); }

function component_plot_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function component_plot_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function component_plot_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return component_plot_arrayLikeToArray(arr); }

function component_plot_slicedToArray(arr, i) { return component_plot_arrayWithHoles(arr) || component_plot_iterableToArrayLimit(arr, i) || component_plot_unsupportedIterableToArray(arr, i) || component_plot_nonIterableRest(); }

function component_plot_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function component_plot_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return component_plot_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return component_plot_arrayLikeToArray(o, minLen); }

function component_plot_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function component_plot_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function component_plot_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function plot_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function plot_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function plot_createClass(Constructor, protoProps, staticProps) { if (protoProps) plot_defineProperties(Constructor.prototype, protoProps); if (staticProps) plot_defineProperties(Constructor, staticProps); return Constructor; }

function plot_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) plot_setPrototypeOf(subClass, superClass); }

function plot_setPrototypeOf(o, p) { plot_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return plot_setPrototypeOf(o, p); }

function plot_createSuper(Derived) { var hasNativeReflectConstruct = plot_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = plot_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = plot_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return plot_possibleConstructorReturn(this, result); }; }

function plot_possibleConstructorReturn(self, call) { if (call && (plot_typeof(call) === "object" || typeof call === "function")) { return call; } return plot_assertThisInitialized(self); }

function plot_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function plot_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function plot_getPrototypeOf(o) { plot_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return plot_getPrototypeOf(o); }

function plot_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





function getValidIndex(index) {
  var startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return ~~index ? index - startIndex : index;
}

function validXPosition(_ref) {
  var axisData = _ref.axisData,
      offsetSize = _ref.offsetSize,
      value = _ref.value,
      xAxisLimit = _ref.xAxisLimit,
      _ref$startIndex = _ref.startIndex,
      startIndex = _ref$startIndex === void 0 ? 0 : _ref$startIndex;
  var dataIndex = getValidIndex(value, startIndex);
  var x = getXPosition(axisData, offsetSize, xAxisLimit, value, dataIndex);
  return x > 0 ? Math.min(offsetSize, x) : 0;
}

function getPlotAxisData(vertical, axes) {
  return vertical ? axes.xAxis : axes.yAxis;
}

var plot_Plot = /*#__PURE__*/function (_Component) {
  plot_inherits(Plot, _Component);

  var _super = plot_createSuper(Plot);

  function Plot() {
    var _this;

    plot_classCallCheck(this, Plot);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    plot_defineProperty(plot_assertThisInitialized(_this), "models", {
      plot: [],
      line: [],
      band: []
    });

    plot_defineProperty(plot_assertThisInitialized(_this), "startIndex", 0);

    plot_defineProperty(plot_assertThisInitialized(_this), "theme", void 0);

    return _this;
  }

  plot_createClass(Plot, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'plot';
    }
  }, {
    key: "getPlotAxisSize",
    value: function getPlotAxisSize(vertical) {
      return {
        offsetSize: vertical ? this.rect.width : this.rect.height,
        anchorSize: vertical ? this.rect.height : this.rect.width
      };
    }
  }, {
    key: "renderLines",
    value: function renderLines(axes, xAxisLimit, categories) {
      var _this2 = this;

      var lines = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      return lines.map(function (_ref2) {
        var value = _ref2.value,
            color = _ref2.color;

        var _this2$getPlotAxisSiz = _this2.getPlotAxisSize(true),
            offsetSize = _this2$getPlotAxisSiz.offsetSize;

        var position = validXPosition({
          axisData: getPlotAxisData(true, axes),
          offsetSize: offsetSize,
          value: value,
          xAxisLimit: xAxisLimit,
          categories: categories,
          startIndex: _this2.startIndex
        });
        return _this2.makeLineModel(true, position, {
          color: color
        });
      });
    }
  }, {
    key: "renderBands",
    value: function renderBands(axes, xAxisLimit, categories) {
      var _this3 = this;

      var bands = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

      var _this$getPlotAxisSize = this.getPlotAxisSize(true),
          offsetSize = _this$getPlotAxisSize.offsetSize,
          anchorSize = _this$getPlotAxisSize.anchorSize;

      return bands.map(function (_ref3) {
        var range = _ref3.range,
            color = _ref3.color;

        var _map = range.map(function (value) {
          return validXPosition({
            axisData: getPlotAxisData(true, axes),
            offsetSize: offsetSize,
            value: value,
            xAxisLimit: xAxisLimit,
            categories: categories,
            startIndex: _this3.startIndex
          });
        }),
            _map2 = component_plot_slicedToArray(_map, 2),
            start = _map2[0],
            end = _map2[1];

        return {
          type: 'rect',
          x: crispPixel(start),
          y: crispPixel(0),
          width: end - start,
          height: anchorSize,
          color: color
        };
      });
    }
  }, {
    key: "renderPlotLineModels",
    value: function renderPlotLineModels(relativePositions, vertical) {
      var _ref5,
          _this4 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var size = options.size,
          startPosition = options.startPosition,
          axes = options.axes;
      var _ref4 = this.theme[vertical ? 'vertical' : 'horizontal'],
          color = _ref4.lineColor,
          lineWidth = _ref4.lineWidth,
          dashSegments = _ref4.dashSegments;
      var tickInterval = ((_ref5 = vertical ? axes === null || axes === void 0 ? void 0 : axes.xAxis : axes === null || axes === void 0 ? void 0 : axes.yAxis) === null || _ref5 === void 0 ? void 0 : _ref5.tickInterval) || 1;
      return relativePositions.filter(function (_, idx) {
        return !(idx % tickInterval);
      }).map(function (position) {
        return _this4.makeLineModel(vertical, position, {
          color: color,
          lineWidth: lineWidth,
          dashSegments: dashSegments
        }, size !== null && size !== void 0 ? size : _this4.rect.width, startPosition !== null && startPosition !== void 0 ? startPosition : 0);
      });
    }
  }, {
    key: "renderPlotsForCenterYAxis",
    value: function renderPlotsForCenterYAxis(axes) {
      var _ref6 = axes.centerYAxis,
          xAxisHalfSize = _ref6.xAxisHalfSize,
          secondStartX = _ref6.secondStartX,
          yAxisHeight = _ref6.yAxisHeight; // vertical

      var xAxisTickCount = axes.xAxis.tickCount;
      var verticalLines = [].concat(component_plot_toConsumableArray(this.renderPlotLineModels(makeTickPixelPositions(xAxisHalfSize, xAxisTickCount), true)), component_plot_toConsumableArray(this.renderPlotLineModels(makeTickPixelPositions(xAxisHalfSize, xAxisTickCount, secondStartX), true))); // horizontal

      var yAxisTickCount = axes.yAxis.tickCount;
      var yAxisTickPixelPositions = makeTickPixelPositions(yAxisHeight, yAxisTickCount);
      var horizontalLines = [].concat(component_plot_toConsumableArray(this.renderPlotLineModels(yAxisTickPixelPositions, false, {
        size: xAxisHalfSize
      })), component_plot_toConsumableArray(this.renderPlotLineModels(yAxisTickPixelPositions, false, {
        size: xAxisHalfSize,
        startPosition: secondStartX
      })));
      return [].concat(component_plot_toConsumableArray(verticalLines), component_plot_toConsumableArray(horizontalLines));
    }
  }, {
    key: "renderPlots",
    value: function renderPlots(axes) {
      var vertical = true;
      return axes.centerYAxis ? this.renderPlotsForCenterYAxis(axes) : [].concat(component_plot_toConsumableArray(this.renderPlotLineModels(this.getTickPixelPositions(!vertical, axes), !vertical, {
        axes: axes
      })), component_plot_toConsumableArray(this.renderPlotLineModels(this.getTickPixelPositions(vertical, axes), vertical, {
        axes: axes
      })));
    }
  }, {
    key: "getTickPixelPositions",
    value: function getTickPixelPositions(vertical, axes) {
      var _this$getPlotAxisSize2 = this.getPlotAxisSize(vertical),
          offsetSize = _this$getPlotAxisSize2.offsetSize;

      var axisData = getPlotAxisData(vertical, axes);
      return makeTickPixelPositions(offsetSize, axisData.tickCount);
    }
  }, {
    key: "renderPlotBackgroundRect",
    value: function renderPlotBackgroundRect() {
      return plot_objectSpread(plot_objectSpread({
        type: 'rect',
        x: 0,
        y: 0
      }, pick(this.rect, 'width', 'height')), {}, {
        color: this.theme.backgroundColor
      });
    }
  }, {
    key: "render",
    value: function render(state) {
      var _ref7, _scale$xAxis;

      var layout = state.layout,
          axes = state.axes,
          plot = state.plot,
          scale = state.scale,
          zoomRange = state.zoomRange,
          theme = state.theme;

      if (!plot) {
        return;
      }

      this.rect = layout.plot;
      this.startIndex = zoomRange ? zoomRange[0] : 0;
      this.theme = theme.plot;
      var categories = (_ref7 = state.categories) !== null && _ref7 !== void 0 ? _ref7 : [];
      var lines = plot.lines,
          bands = plot.bands,
          visible = plot.visible;
      var xAxisLimit = scale === null || scale === void 0 ? void 0 : (_scale$xAxis = scale.xAxis) === null || _scale$xAxis === void 0 ? void 0 : _scale$xAxis.limit;
      this.models.line = this.renderLines(axes, xAxisLimit, categories, lines);
      this.models.band = this.renderBands(axes, xAxisLimit, categories, bands);

      if (visible) {
        this.models.plot = [this.renderPlotBackgroundRect()].concat(component_plot_toConsumableArray(this.renderPlots(axes)));
      }
    }
  }, {
    key: "makeLineModel",
    value: function makeLineModel(vertical, position, _ref8, sizeWidth) {
      var color = _ref8.color,
          _ref8$dashSegments = _ref8.dashSegments,
          dashSegments = _ref8$dashSegments === void 0 ? [] : _ref8$dashSegments,
          _ref8$lineWidth = _ref8.lineWidth,
          lineWidth = _ref8$lineWidth === void 0 ? 1 : _ref8$lineWidth;
      var xPos = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var x = vertical ? crispPixel(position) : crispPixel(xPos);
      var y = vertical ? crispPixel(0) : crispPixel(position);
      var width = vertical ? 0 : sizeWidth !== null && sizeWidth !== void 0 ? sizeWidth : this.rect.width;
      var height = vertical ? this.rect.height : 0;
      return {
        type: 'line',
        x: x,
        y: y,
        x2: x + width,
        y2: y + height,
        strokeStyle: color,
        lineWidth: lineWidth,
        dashSegments: dashSegments
      };
    }
  }, {
    key: "beforeDraw",
    value: function beforeDraw(painter) {
      painter.ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
      painter.ctx.lineWidth = 1;
    }
  }]);

  return Plot;
}(component_Component);


// CONCATENATED MODULE: ./src/helpers/legend.ts









function helpers_legend_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function helpers_legend_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { helpers_legend_ownKeys(Object(source), true).forEach(function (key) { helpers_legend_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { helpers_legend_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function helpers_legend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getActiveSeriesMap(legend) {
  return legend.data.reduce(function (acc, _ref) {
    var active = _ref.active,
        label = _ref.label;
    return helpers_legend_objectSpread(helpers_legend_objectSpread({}, acc), {}, helpers_legend_defineProperty({}, label, active));
  }, {});
}
// CONCATENATED MODULE: ./src/helpers/responders.ts













function responders_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function responders_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { responders_ownKeys(Object(source), true).forEach(function (key) { responders_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { responders_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function responders_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



// eslint-disable-next-line complexity
function isSameSeriesResponder(_ref) {
  var models = _ref.models,
      comparisonModel = _ref.comparisonModel,
      name = _ref.name,
      eventDetectType = _ref.eventDetectType;

  switch (name) {
    case 'heatmap':
      return isClickSameNameResponder(models, comparisonModel);

    case 'bullet':
      return eventDetectType === 'grouped' ? isClickSameGroupedRectResponder(models, comparisonModel) : isClickSameNameResponder(models, comparisonModel);

    case 'radar':
    case 'bubble':
    case 'scatter':
    case 'area':
    case 'line':
      return isClickSameCircleResponder(models, comparisonModel);

    case 'pie':
      return isClickSameDataResponder(models, comparisonModel);

    case 'column':
    case 'bar':
      return eventDetectType === 'grouped' ? isClickSameGroupedRectResponder(models, comparisonModel) : isClickSameDataResponder(models, comparisonModel);

    case 'boxPlot':
      return eventDetectType === 'grouped' ? isClickSameDataResponder(models, comparisonModel) : isClickSameBoxPlotDataResponder(models, comparisonModel);

    case 'treemap':
      return isClickSameLabelResponder(models, comparisonModel);

    default:
      return false;
  }
}
function getNearestResponder(responders, mousePosition, rect) {
  var minDistance = Infinity;
  var result = [];
  responders.forEach(function (responder) {
    var x = responder.x,
        y = responder.y,
        radius = responder.radius;
    var responderPoint = {
      x: x + rect.x,
      y: y + rect.y
    };
    var distance = getDistance(responderPoint, mousePosition);

    if (minDistance > distance) {
      minDistance = distance;
      result = [responder];
    } else if (minDistance === distance) {
      if (result.length && result[0].radius > radius) {
        result = [responder];
      } else {
        result.push(responder);
      }
    }
  });
  return result;
}
function responders_makeRectResponderModel(rect, axis, categories) {
  var vertical = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var pointOnColumn = axis.pointOnColumn,
      tickCount = axis.tickCount,
      tickDistance = axis.tickDistance;
  var width = rect.width,
      height = rect.height;
  var halfDetectAreaIndex = pointOnColumn ? [] : [0, tickCount - 1];
  var halfSize = tickDistance / 2;
  return utils_range(0, tickCount).map(function (index) {
    var half = halfDetectAreaIndex.includes(index);
    var size = half ? halfSize : tickDistance;
    var startPos = 0;

    if (index !== 0) {
      startPos += pointOnColumn ? tickDistance * index : halfSize + tickDistance * (index - 1);
    }

    return {
      type: 'rect',
      y: vertical ? 0 : startPos,
      height: vertical ? height : size,
      x: vertical ? startPos : 0,
      width: vertical ? size : width,
      index: index,
      label: categories[index]
    };
  });
}
function makeTooltipCircleMap(seriesCircleModel, tooltipDataArr) {
  var dataMap = tooltipDataArr.reduce(function (acc, cur) {
    var index = cur.index,
        seriesIndex = cur.seriesIndex;

    if (!acc[seriesIndex]) {
      acc[seriesIndex] = [];
    }

    acc[seriesIndex][index] = cur;
    return acc;
  }, []);
  return seriesCircleModel.reduce(function (acc, model) {
    var seriesIndex = model.seriesIndex,
        index = model.index;
    var data = dataMap[seriesIndex][index];
    var category = data.category;

    if (!category) {
      return acc;
    }

    if (!acc[category]) {
      acc[category] = [];
    }

    acc[category].push(responders_objectSpread(responders_objectSpread({}, model), {}, {
      data: data
    }));
    return acc;
  }, {});
}
function getDeepestNode(responders) {
  return responders.reduce(function (acc, responder) {
    if (!acc.length || responder.depth > acc[0].depth) {
      return [responder];
    }

    return acc;
  }, []);
}
function isClickSameNameResponder(responders, selectedSeries) {
  return responders.length && (selectedSeries === null || selectedSeries === void 0 ? void 0 : selectedSeries.length) && responders[0].name === selectedSeries[0].name;
}
function isClickSameCircleResponder(responders, selectedSeries) {
  var same = false;

  if (responders.length && (selectedSeries === null || selectedSeries === void 0 ? void 0 : selectedSeries.length) && responders.length === selectedSeries.length) {
    same = responders.reduce(function (acc, cur, idx) {
      return acc && cur.seriesIndex === selectedSeries[idx].seriesIndex && cur.index === selectedSeries[idx].index;
    }, true);
  }

  return same;
}
function isClickSameDataResponder(responders, selectedSeries) {
  var same = false;

  if (responders.length && (selectedSeries === null || selectedSeries === void 0 ? void 0 : selectedSeries.length) && responders.length === selectedSeries.length) {
    same = responders.reduce(function (acc, cur, idx) {
      var _cur$data, _selectedSeries$idx$d, _cur$data2, _selectedSeries$idx$d2;

      return acc && ((_cur$data = cur.data) === null || _cur$data === void 0 ? void 0 : _cur$data.label) === ((_selectedSeries$idx$d = selectedSeries[idx].data) === null || _selectedSeries$idx$d === void 0 ? void 0 : _selectedSeries$idx$d.label) && ((_cur$data2 = cur.data) === null || _cur$data2 === void 0 ? void 0 : _cur$data2.category) === ((_selectedSeries$idx$d2 = selectedSeries[idx].data) === null || _selectedSeries$idx$d2 === void 0 ? void 0 : _selectedSeries$idx$d2.category);
    }, true);
  }

  return same;
}
function isClickSameLabelResponder(responders, selectedSeries) {
  return responders.length && (selectedSeries === null || selectedSeries === void 0 ? void 0 : selectedSeries.length) && responders[0].label === selectedSeries[0].label;
}
function isClickSameGroupedRectResponder(responders, selectedSeries) {
  return responders.length && (selectedSeries === null || selectedSeries === void 0 ? void 0 : selectedSeries.length) && responders[0].index === selectedSeries[0].index;
}
function isClickSameBoxPlotDataResponder(responders, selectedSeries) {
  var same = false;

  if (responders.length && (selectedSeries === null || selectedSeries === void 0 ? void 0 : selectedSeries.length)) {
    var _selectedSeries$0$dat, _selectedSeries$0$dat2;

    var _responders$ = responders[0],
        type = _responders$.type,
        data = _responders$.data;
    same = type === selectedSeries[0].type && (data === null || data === void 0 ? void 0 : data.label) === ((_selectedSeries$0$dat = selectedSeries[0].data) === null || _selectedSeries$0$dat === void 0 ? void 0 : _selectedSeries$0$dat.label) && (data === null || data === void 0 ? void 0 : data.category) === ((_selectedSeries$0$dat2 = selectedSeries[0].data) === null || _selectedSeries$0$dat2 === void 0 ? void 0 : _selectedSeries$0$dat2.category);
  }

  return same;
}
// CONCATENATED MODULE: ./src/helpers/dataLabels.ts










function dataLabels_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function dataLabels_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { dataLabels_ownKeys(Object(source), true).forEach(function (key) { dataLabels_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { dataLabels_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function dataLabels_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var RADIUS_PADDING = 30;
var CALLOUT_LENGTH = 20;

function getDefaultAnchor(type) {
  var withStack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var anchor = 'auto';

  switch (type) {
    case 'point':
      anchor = 'center';
      break;

    case 'rect':
      anchor = !withStack ? 'auto' : 'center';
      break;

    case 'sector':
    case 'treemapSeriesName':
      anchor = 'center';
      break;

    case 'stackTotal':
      anchor = 'auto';
      break;
  }

  return anchor;
}

function getAnchor(dataLabelOptions, type) {
  var withStack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return type !== 'stackTotal' && includes(['center', 'start', 'end', 'auto', 'outer'], dataLabelOptions.anchor) ? dataLabelOptions.anchor : getDefaultAnchor(type, withStack);
}

function getDefaultDataLabelsOptions(dataLabelOptions, type) {
  var _pieSeriesName;

  var withStack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var anchor = getAnchor(dataLabelOptions, type, withStack);
  var _dataLabelOptions$off = dataLabelOptions.offsetX,
      offsetX = _dataLabelOptions$off === void 0 ? 0 : _dataLabelOptions$off,
      _dataLabelOptions$off2 = dataLabelOptions.offsetY,
      offsetY = _dataLabelOptions$off2 === void 0 ? 0 : _dataLabelOptions$off2;
  var formatter = isFunction(dataLabelOptions.formatter) ? dataLabelOptions.formatter : function (value) {
    return String(value) || '';
  };
  var options = {
    anchor: anchor,
    offsetX: offsetX,
    offsetY: offsetY,
    formatter: formatter
  };

  if (withStack) {
    var stackTotal = dataLabelOptions.stackTotal;
    options.stackTotal = {
      visible: isBoolean(stackTotal === null || stackTotal === void 0 ? void 0 : stackTotal.visible) ? stackTotal.visible : true,
      formatter: isFunction(stackTotal === null || stackTotal === void 0 ? void 0 : stackTotal.formatter) ? stackTotal.formatter : formatter
    };
  }

  if (type === 'sector' && ((_pieSeriesName = dataLabelOptions.pieSeriesName) === null || _pieSeriesName === void 0 ? void 0 : _pieSeriesName.visible)) {
    options.pieSeriesName = dataLabels_objectSpread(dataLabels_objectSpread({}, {
      anchor: 'center'
    }), dataLabelOptions.pieSeriesName);
  }

  return options;
}
function makePointLabelInfo(point, dataLabelOptions, rect) {
  var width = rect.width,
      height = rect.height;
  var anchor = dataLabelOptions.anchor,
      _dataLabelOptions$off3 = dataLabelOptions.offsetX,
      offsetX = _dataLabelOptions$off3 === void 0 ? 0 : _dataLabelOptions$off3,
      _dataLabelOptions$off4 = dataLabelOptions.offsetY,
      offsetY = _dataLabelOptions$off4 === void 0 ? 0 : _dataLabelOptions$off4,
      formatter = dataLabelOptions.formatter;
  var name = point.name,
      theme = point.theme;
  var textBaseline = 'middle';

  if (anchor === 'end') {
    textBaseline = 'bottom';
  } else if (anchor === 'start') {
    textBaseline = 'top';
  }

  var xWithOffset = point.x + offsetX;
  var yWithOffset = point.y + offsetY;
  var x = xWithOffset < 0 || xWithOffset > width ? point.x : xWithOffset;
  var y = yWithOffset < 0 || yWithOffset > height ? point.y : yWithOffset;
  return {
    type: 'point',
    x: x,
    y: y,
    text: formatter(point.value),
    textAlign: 'center',
    textBaseline: textBaseline,
    name: name,
    theme: theme
  };
}

function isHorizontal(direction) {
  return includes(['left', 'right'], direction);
}

function makeHorizontalRectPosition(rect, anchor) {
  var x = rect.x,
      y = rect.y,
      width = rect.width,
      height = rect.height,
      direction = rect.direction;
  var textBaseline = 'middle';
  var posY = y + height / 2;
  var textAlign = 'center';
  var posX;

  if (direction === 'right') {
    switch (anchor) {
      case 'start':
        textAlign = 'left';
        posX = x;
        break;

      case 'end':
        textAlign = 'right';
        posX = x + width;
        break;

      case 'center':
        textAlign = 'center';
        posX = x + width / 2;
        break;

      default:
        textAlign = 'left';
        posX = x + width;
    }
  } else {
    switch (anchor) {
      case 'start':
        textAlign = 'right';
        posX = x + width;
        break;

      case 'end':
        textAlign = 'left';
        posX = x;
        break;

      case 'center':
        textAlign = 'center';
        posX = x + width / 2;
        break;

      default:
        textAlign = 'right';
        posX = x;
    }
  }

  return {
    x: posX,
    y: posY,
    textAlign: textAlign,
    textBaseline: textBaseline
  };
}

function makeVerticalRectPosition(rect, anchor) {
  var x = rect.x,
      y = rect.y,
      width = rect.width,
      height = rect.height,
      direction = rect.direction;
  var textAlign = 'center';
  var posX = x + width / 2;
  var textBaseline = 'middle';
  var posY = 0;

  if (direction === 'top') {
    switch (anchor) {
      case 'end':
        textBaseline = 'top';
        posY = y;
        break;

      case 'start':
        textBaseline = 'bottom';
        posY = y + height;
        break;

      case 'center':
        textBaseline = 'middle';
        posY = y + height / 2;
        break;

      default:
        textBaseline = 'bottom';
        posY = y;
    }
  } else {
    switch (anchor) {
      case 'end':
        textBaseline = 'bottom';
        posY = y + height;
        break;

      case 'start':
        textBaseline = 'top';
        posY = y;
        break;

      case 'center':
        textBaseline = 'middle';
        posY = y + height / 2;
        break;

      default:
        textBaseline = 'top';
        posY = y + height;
        break;
    }
  }

  return {
    x: posX,
    y: posY,
    textAlign: textAlign,
    textBaseline: textBaseline
  };
}

function adjustOverflowHorizontalRect(rect, dataLabelOptions, position) {
  var width = rect.width,
      value = rect.value,
      direction = rect.direction,
      plot = rect.plot,
      theme = rect.theme;
  var formatter = dataLabelOptions.formatter;
  var font = getFont(theme);
  var text = isString(value) ? value : formatter(value);
  var textWidth = getTextWidth(text, font);
  var x = position.x,
      textAlign = position.textAlign;
  var isOverflow = direction === 'left' && x - textWidth < 0 || x + textWidth > plot.size;

  if (isOverflow) {
    x = rect.x + width;
    textAlign = 'right';

    if (direction === 'left' && width >= textWidth) {
      x = rect.x;
      textAlign = 'left';
    }
  }

  return {
    x: x,
    textAlign: textAlign
  };
}

function adjustOverflowVerticalRect(rect, dataLabelOptions, position) {
  var height = rect.height,
      direction = rect.direction,
      plot = rect.plot,
      theme = rect.theme,
      value = rect.value;
  var font = getFont(theme);
  var plotSize = plot.size;
  var textHeight = getTextHeight("".concat(value), font); // @TODO: formatter 값해서 넘기기

  var y = position.y,
      textBaseline = position.textBaseline;
  var isOverflow = !(direction === 'bottom') && y - textHeight < 0 || y + textHeight > plotSize;

  if (isOverflow) {
    y = rect.y;
    textBaseline = 'top';

    if (y + textHeight > plotSize) {
      y = rect.y;
      textBaseline = 'bottom';
    }

    if (direction === 'bottom') {
      y = rect.y + height;
      textBaseline = 'bottom';
    }
  }

  return {
    y: y,
    textBaseline: textBaseline
  };
}

function makeHorizontalRectLabelInfo(rect, dataLabelOptions) {
  var anchor = dataLabelOptions.anchor,
      _dataLabelOptions$off5 = dataLabelOptions.offsetX,
      offsetX = _dataLabelOptions$off5 === void 0 ? 0 : _dataLabelOptions$off5,
      _dataLabelOptions$off6 = dataLabelOptions.offsetY,
      offsetY = _dataLabelOptions$off6 === void 0 ? 0 : _dataLabelOptions$off6;
  var direction = rect.direction,
      _rect$plot = rect.plot,
      _rect$plot$x = _rect$plot.x,
      startOffsetX = _rect$plot$x === void 0 ? 0 : _rect$plot$x,
      _rect$plot$y = _rect$plot.y,
      startOffsetY = _rect$plot$y === void 0 ? 0 : _rect$plot$y;
  var position = makeHorizontalRectPosition(rect, anchor);
  var posX = position.x,
      posY = position.y,
      textAlign = position.textAlign;

  if (anchor === 'auto') {
    var adjustRect = adjustOverflowHorizontalRect(rect, dataLabelOptions, {
      x: posX,
      textAlign: textAlign
    });
    posX = adjustRect.x;
    textAlign = adjustRect.textAlign;
  }

  posY += offsetY;

  if (direction === 'left') {
    posX = posX - offsetX;
  } else {
    posX = posX + offsetX;
  }

  var padding = 10;

  if (textAlign === 'right') {
    posX -= padding;
  } else if (textAlign === 'left') {
    posX += padding;
  }

  posX -= startOffsetX;
  posY -= startOffsetY;
  return {
    x: posX,
    y: posY,
    textAlign: textAlign,
    textBaseline: position.textBaseline
  };
}

function makeVerticalRectLabelInfo(rect, dataLabelOptions) {
  var anchor = dataLabelOptions.anchor,
      _dataLabelOptions$off7 = dataLabelOptions.offsetX,
      offsetX = _dataLabelOptions$off7 === void 0 ? 0 : _dataLabelOptions$off7,
      _dataLabelOptions$off8 = dataLabelOptions.offsetY,
      offsetY = _dataLabelOptions$off8 === void 0 ? 0 : _dataLabelOptions$off8;
  var direction = rect.direction,
      _rect$plot2 = rect.plot,
      _rect$plot2$x = _rect$plot2.x,
      startOffsetX = _rect$plot2$x === void 0 ? 0 : _rect$plot2$x,
      _rect$plot2$y = _rect$plot2.y,
      startOffsetY = _rect$plot2$y === void 0 ? 0 : _rect$plot2$y;
  var position = makeVerticalRectPosition(rect, anchor);
  var posX = position.x,
      posY = position.y,
      textBaseline = position.textBaseline;

  if (anchor === 'auto') {
    var adjustRect = adjustOverflowVerticalRect(rect, dataLabelOptions, position);
    posY = adjustRect.y;
    textBaseline = adjustRect.textBaseline;
  }

  posX += offsetX;

  if (direction === 'top') {
    posY = posY + offsetY;
  } else if (direction === 'bottom') {
    posY = posY - offsetY;
  }

  var padding = 5;

  if (textBaseline === 'bottom') {
    posY -= padding;
  } else if (textBaseline === 'top') {
    posY += padding;
  }

  posX -= startOffsetX;
  posY -= startOffsetY;
  return {
    x: posX,
    y: posY,
    textAlign: position.textAlign,
    textBaseline: textBaseline
  };
}

function makeRectLabelInfo(rect, dataLabelOptions) {
  var type = rect.type,
      value = rect.value,
      direction = rect.direction,
      name = rect.name,
      theme = rect.theme;
  var horizontal = isHorizontal(direction);
  var labelPosition = horizontal ? makeHorizontalRectLabelInfo(rect, dataLabelOptions) : makeVerticalRectLabelInfo(rect, dataLabelOptions);
  var formatter = type === 'stackTotal' ? dataLabelOptions.stackTotal.formatter : dataLabelOptions.formatter;
  return dataLabels_objectSpread(dataLabels_objectSpread({
    type: type
  }, labelPosition), {}, {
    text: isString(value) ? value : formatter(value),
    name: name,
    seriesColor: rect.color,
    theme: theme
  });
}
function makeSectorLabelPosition(model, dataLabelOptions) {
  var anchor = dataLabelOptions.anchor;
  var position = getRadialAnchorPosition(makeAnchorPositionParam(anchor, dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
    radius: dataLabels_objectSpread(dataLabels_objectSpread({}, model.radius), {}, {
      outer: anchor === 'outer' ? model.radius.outer + RADIUS_PADDING : model.radius.outer
    })
  })));
  var textAlign = getPieDataLabelAlign(model, anchor);
  return dataLabels_objectSpread(dataLabels_objectSpread({}, position), {}, {
    textAlign: textAlign,
    textBaseline: hasSameAnchorPieDataLabel(dataLabelOptions) ? 'bottom' : 'middle'
  });
}

function getPieDataLabelAlign(model, anchor) {
  var totalAngle = model.totalAngle,
      _model$degree = model.degree,
      start = _model$degree.start,
      end = _model$degree.end,
      drawingStartAngle = model.drawingStartAngle;
  var textAlign = 'center';

  if (anchor !== 'outer') {
    return textAlign;
  }

  var radian0 = calculateDegreeToRadian(0, drawingStartAngle);
  var halfRadian = calculateDegreeToRadian(totalAngle / 2, drawingStartAngle);
  var halfDegree = (end + start) / 2;
  var radian = calculateDegreeToRadian(halfDegree, drawingStartAngle);

  if (drawingStartAngle >= -90 && drawingStartAngle < 90) {
    if (radian0 < radian && halfRadian > radian) {
      textAlign = 'left';
    } else if (halfRadian < radian) {
      textAlign = 'right';
    }
  } else if (radian0 < radian && halfRadian > radian) {
    textAlign = 'right';
  } else if (halfRadian < radian) {
    textAlign = 'left';
  }

  return textAlign;
}

function makeSectorLabelInfo(model, dataLabelOptions) {
  var formatter = dataLabelOptions.formatter;
  var labelPosition = makeSectorLabelPosition(model, dataLabelOptions);
  var value = model.value,
      name = model.name,
      dataLabelTheme = model.theme;
  var anchor = dataLabelOptions.anchor;

  var theme = dataLabels_objectSpread(dataLabels_objectSpread({}, dataLabelTheme), {}, {
    color: dataLabelTheme.useSeriesColor ? model.color : dataLabelTheme.color
  });

  return dataLabels_objectSpread(dataLabels_objectSpread({
    type: 'sector'
  }, labelPosition), {}, {
    text: formatter(value),
    name: name,
    callout: hasSectorCallout(dataLabelOptions) ? getPieDataLabelCallout(model, anchor) : null,
    theme: theme
  });
}
function makePieSeriesNameLabelInfo(model, dataLabelOptions) {
  var _dataLabelOptions$pie;

  var seriesNameAnchor = (_dataLabelOptions$pie = dataLabelOptions.pieSeriesName) === null || _dataLabelOptions$pie === void 0 ? void 0 : _dataLabelOptions$pie.anchor;
  var hasOuterAnchor = seriesNameAnchor === 'outer';
  var position = getRadialAnchorPosition(makeAnchorPositionParam(seriesNameAnchor, dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
    radius: dataLabels_objectSpread(dataLabels_objectSpread({}, model.radius), {}, {
      outer: hasOuterAnchor ? model.radius.outer + RADIUS_PADDING : model.radius.outer
    })
  })));
  var textAlign = getPieDataLabelAlign(model, seriesNameAnchor);
  var pieSeriesNameTheme = model.theme.pieSeriesName;

  var theme = dataLabels_objectSpread(dataLabels_objectSpread({}, pieSeriesNameTheme), {}, {
    color: pieSeriesNameTheme.useSeriesColor ? model.color : pieSeriesNameTheme.color
  });

  return dataLabels_objectSpread(dataLabels_objectSpread({
    type: 'pieSeriesName'
  }, position), {}, {
    text: model.name,
    callout: hasPieSeriesNameCallout(dataLabelOptions) ? getPieDataLabelCallout(model, seriesNameAnchor) : null,
    textAlign: textAlign,
    textBaseline: hasSameAnchorPieDataLabel(dataLabelOptions) ? 'top' : 'middle',
    theme: theme
  });
}
function getDataLabelsOptions(options, name) {
  var _options$series, _options$series$name, _options$series2;

  return (options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : (_options$series$name = _options$series[name]) === null || _options$series$name === void 0 ? void 0 : _options$series$name.dataLabels) || (options === null || options === void 0 ? void 0 : (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : _options$series2.dataLabels) || {};
}
function makeLineLabelInfo(model, dataLabelOptions) {
  var value = model.value,
      textAlign = model.textAlign,
      textBaseline = model.textBaseline;
  var formatter = dataLabelOptions.formatter;
  return dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
    x: model.x,
    y: (model.y + model.y2) / 2,
    textAlign: textAlign !== null && textAlign !== void 0 ? textAlign : 'center',
    textBaseline: textBaseline !== null && textBaseline !== void 0 ? textBaseline : 'middle',
    text: isString(value) ? value : formatter(value)
  });
}

function hasSameAnchorPieDataLabel(dataLabelOptions) {
  var _dataLabelOptions$pie2;

  return dataLabelOptions.anchor === ((_dataLabelOptions$pie2 = dataLabelOptions.pieSeriesName) === null || _dataLabelOptions$pie2 === void 0 ? void 0 : _dataLabelOptions$pie2.anchor);
}

function hasSectorCallout(dataLabelOptions) {
  var _dataLabelOptions$pie3;

  return dataLabelOptions.anchor === 'outer' || ((_dataLabelOptions$pie3 = dataLabelOptions.pieSeriesName) === null || _dataLabelOptions$pie3 === void 0 ? void 0 : _dataLabelOptions$pie3.anchor) !== 'outer';
}

function hasPieSeriesNameCallout(dataLabelOptions) {
  var _dataLabelOptions$pie4;

  return dataLabelOptions.anchor !== 'outer' || ((_dataLabelOptions$pie4 = dataLabelOptions.pieSeriesName) === null || _dataLabelOptions$pie4 === void 0 ? void 0 : _dataLabelOptions$pie4.anchor) === 'outer';
}

function getPieDataLabelCallout(model, anchor) {
  if (anchor !== 'outer') {
    return null;
  }

  var _getRadialAnchorPosit = getRadialAnchorPosition(makeAnchorPositionParam('outer', dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
    radius: dataLabels_objectSpread(dataLabels_objectSpread({}, model.radius), {}, {
      outer: model.radius.outer + CALLOUT_LENGTH
    })
  }))),
      x = _getRadialAnchorPosit.x,
      y = _getRadialAnchorPosit.y;

  var _getRadialAnchorPosit2 = getRadialAnchorPosition(makeAnchorPositionParam('outer', dataLabels_objectSpread({}, model))),
      x2 = _getRadialAnchorPosit2.x,
      y2 = _getRadialAnchorPosit2.y;

  var callout = model.theme.callout;

  var theme = dataLabels_objectSpread(dataLabels_objectSpread({}, callout), {}, {
    lineColor: callout.useSeriesColor ? model.color : callout.lineColor
  });

  return {
    x: x,
    y: y,
    x2: x2,
    y2: y2,
    theme: theme
  };
}
// CONCATENATED MODULE: ./src/helpers/validation.ts

function isAvailableShowTooltipInfo(info, eventDetectType, targetChartType) {
  var index = info.index,
      seriesIndex = info.seriesIndex,
      chartType = info.chartType;
  return isNumber(index) && (eventDetectType === 'grouped' || isNumber(seriesIndex)) && (isUndefined(chartType) || chartType === targetChartType);
}
function isAvailableSelectSeries(info, targetChartType) {
  var index = info.index,
      seriesIndex = info.seriesIndex,
      chartType = info.chartType;
  return isNumber(index) && isNumber(seriesIndex) && (isUndefined(chartType) || chartType === targetChartType);
}
// CONCATENATED MODULE: ./src/component/lineSeries.ts

























function lineSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { lineSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { lineSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return lineSeries_typeof(obj); }

function lineSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function lineSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { lineSeries_ownKeys(Object(source), true).forEach(function (key) { lineSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { lineSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function lineSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lineSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function lineSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) lineSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) lineSeries_defineProperties(Constructor, staticProps); return Constructor; }

function lineSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) lineSeries_setPrototypeOf(subClass, superClass); }

function lineSeries_setPrototypeOf(o, p) { lineSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return lineSeries_setPrototypeOf(o, p); }

function lineSeries_createSuper(Derived) { var hasNativeReflectConstruct = lineSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = lineSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = lineSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return lineSeries_possibleConstructorReturn(this, result); }; }

function lineSeries_possibleConstructorReturn(self, call) { if (call && (lineSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return lineSeries_assertThisInitialized(self); }

function lineSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function lineSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function lineSeries_getPrototypeOf(o) { lineSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return lineSeries_getPrototypeOf(o); }

function lineSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













var lineSeries_LineSeries = /*#__PURE__*/function (_Component) {
  lineSeries_inherits(LineSeries, _Component);

  var _super = lineSeries_createSuper(LineSeries);

  function LineSeries() {
    var _this;

    lineSeries_classCallCheck(this, LineSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "models", {
      rect: [],
      series: [],
      dot: []
    });

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "drawModels", void 0);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "responders", void 0);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "theme", void 0);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "activatedResponders", []);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "eventDetectType", 'nearest');

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "tooltipCircleMap", void 0);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "startIndex", void 0);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "yAxisName", 'yAxis');

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "selectSeries", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableSelectSeries(info, 'line')) {
        return;
      }

      var category = _this.getResponderCategoryByIndex(index);

      if (!category) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      var model = _this.tooltipCircleMap[category][seriesIndex];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: [model],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableShowTooltipInfo(info, _this.eventDetectType, 'line')) {
        return;
      }

      var category = _this.getResponderCategoryByIndex(index);

      if (!category) {
        return;
      }

      var models = _this.eventDetectType === 'grouped' ? _this.tooltipCircleMap[category] : [_this.tooltipCircleMap[category][seriesIndex]];

      if (!(models === null || models === void 0 ? void 0 : models.length)) {
        return;
      }

      _this.onMousemoveNearType(models);

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  lineSeries_createClass(LineSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'line';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      this.drawModels.rect[0].width = this.models.rect[0].width * delta;
    }
  }, {
    key: "setEventDetectType",
    value: function setEventDetectType(series, options) {
      var _options$series;

      if (series.area || series.column) {
        this.eventDetectType = 'grouped';
      }

      if (options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }

      if (series.scatter) {
        this.eventDetectType = 'near';
      }
    }
  }, {
    key: "render",
    value: function render(chartState, computed) {
      var _ref;

      var viewRange = computed.viewRange;
      var layout = chartState.layout,
          series = chartState.series,
          scale = chartState.scale,
          axes = chartState.axes,
          legend = chartState.legend,
          theme = chartState.theme;

      if (!series.line) {
        throw new Error(message.noDataError(this.name));
      }

      var categories = (_ref = chartState.categories) !== null && _ref !== void 0 ? _ref : [];

      var options = lineSeries_objectSpread({}, chartState.options);

      if ((options === null || options === void 0 ? void 0 : options.series) && 'line' in options.series) {
        options.series = lineSeries_objectSpread(lineSeries_objectSpread({}, options.series), options.series.line);
      }

      this.setEventDetectType(series, options);
      var labelAxisData = axes.xAxis;
      var tickDistance = labelAxisData.tickDistance,
          pointOnColumn = labelAxisData.pointOnColumn,
          labelDistance = labelAxisData.labelDistance;
      var lineSeriesData = series.line.data;
      var renderLineOptions = {
        pointOnColumn: pointOnColumn,
        options: options.series || {},
        tickDistance: tickDistance,
        labelDistance: labelDistance
      };
      this.theme = theme.series.line;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.startIndex = viewRange ? viewRange[0] : 0;
      this.selectable = this.getSelectableOption(options);
      this.yAxisName = getValueAxisName(options, this.name, 'yAxis');
      var lineSeriesModel = this.renderLinePointsModel(lineSeriesData, scale, renderLineOptions, categories);

      var _this$renderCircleMod = this.renderCircleModel(lineSeriesModel, renderLineOptions),
          dotSeriesModel = _this$renderCircleMod.dotSeriesModel,
          responderModel = _this$renderCircleMod.responderModel;

      var tooltipDataArr = this.makeTooltipData(lineSeriesData, categories);
      this.tooltipCircleMap = makeTooltipCircleMap(responderModel, tooltipDataArr);
      this.models = {
        rect: [this.renderClipRectAreaModel()],
        series: lineSeriesModel,
        dot: dotSeriesModel
      };

      if (!this.drawModels) {
        this.drawModels = lineSeries_objectSpread(lineSeries_objectSpread({}, this.models), {}, {
          rect: [this.renderClipRectAreaModel(true)]
        });
      }

      if (getDataLabelsOptions(options, this.name).visible) {
        this.renderDataLabels(this.getDataLabels(lineSeriesModel));
      }

      this.responders = this.getResponders(labelAxisData, responderModel, tooltipDataArr, categories);
    }
  }, {
    key: "getResponders",
    value: function getResponders(axisData, seriesCircleModel, tooltipDataArr, categories) {
      var res;

      if (this.eventDetectType === 'near') {
        res = this.makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr);
      } else if (this.eventDetectType === 'point') {
        res = this.makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr, 0);
      } else {
        res = responders_makeRectResponderModel(this.rect, axisData, categories);
      }

      return res;
    }
  }, {
    key: "makeNearTypeResponderModel",
    value: function makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr, detectionSize) {
      return seriesCircleModel.map(function (m, index) {
        return lineSeries_objectSpread(lineSeries_objectSpread({}, m), {}, {
          data: tooltipDataArr[index],
          detectionSize: detectionSize
        });
      });
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData(lineSeriesData, categories) {
      var _this2 = this;

      return lineSeriesData.flatMap(function (_ref2, seriesIndex) {
        var rawData = _ref2.rawData,
            name = _ref2.name,
            color = _ref2.color;
        return rawData.map(function (datum, index) {
          return isNull(datum) ? {} : {
            label: name,
            color: color,
            value: getCoordinateYValue(datum),
            category: categories[getCoordinateDataIndex(datum, categories, index, _this2.startIndex)],
            seriesIndex: seriesIndex,
            index: index
          };
        });
      });
    }
  }, {
    key: "renderClipRectAreaModel",
    value: function renderClipRectAreaModel(isDrawModel) {
      return {
        type: 'clipRectArea',
        x: 0,
        y: 0,
        width: isDrawModel ? 0 : this.rect.width,
        height: this.rect.height
      };
    }
  }, {
    key: "renderLinePointsModel",
    value: function renderLinePointsModel(seriesRawData, scale, renderOptions, categories) {
      var _scale$xAxis,
          _this3 = this;

      var spline = renderOptions.options.spline;
      var yAxisLimit = scale[this.yAxisName].limit;
      var xAxisLimit = scale === null || scale === void 0 ? void 0 : (_scale$xAxis = scale.xAxis) === null || _scale$xAxis === void 0 ? void 0 : _scale$xAxis.limit;
      var _this$theme = this.theme,
          lineWidth = _this$theme.lineWidth,
          dashSegments = _this$theme.dashSegments;
      return seriesRawData.map(function (_ref3, seriesIndex) {
        var rawData = _ref3.rawData,
            name = _ref3.name,
            seriesColor = _ref3.color;
        var points = [];
        var active = _this3.activeSeriesMap[name];
        rawData.forEach(function (datum, idx) {
          if (isNull(datum)) {
            return points.push(null);
          }

          var value = getCoordinateYValue(datum);
          var yValueRatio = getValueRatio(value, yAxisLimit);
          var y = (1 - yValueRatio) * _this3.rect.height;
          var x = getXPosition(pick(renderOptions, 'pointOnColumn', 'tickDistance', 'labelDistance'), _this3.rect.width, xAxisLimit, getCoordinateXValue(datum), getCoordinateDataIndex(datum, categories, idx, _this3.startIndex));
          points.push({
            x: x,
            y: y,
            value: value
          });
        });

        if (spline) {
          setSplineControlPoint(points);
        }

        return {
          type: 'linePoints',
          points: points,
          seriesIndex: seriesIndex,
          name: name,
          color: getRGBA(seriesColor, active ? 1 : 0.3),
          lineWidth: lineWidth,
          dashSegments: dashSegments
        };
      });
    }
  }, {
    key: "renderCircleModel",
    value: function renderCircleModel(lineSeriesModel, _ref4) {
      var _this4 = this;

      var options = _ref4.options;
      var dotSeriesModel = [];
      var responderModel = [];
      var showDot = !!options.showDot;
      var _this$theme2 = this.theme,
          hover = _this$theme2.hover,
          dotTheme = _this$theme2.dot;
      var hoverDotTheme = hover.dot;
      lineSeriesModel.forEach(function (_ref5, seriesIndex) {
        var color = _ref5.color,
            name = _ref5.name,
            points = _ref5.points;
        var active = _this4.activeSeriesMap[name];
        points.forEach(function (point, index) {
          var _hoverDotTheme$color;

          if (isNull(point)) {
            return;
          }

          var x = point.x,
              y = point.y;
          var model = {
            type: 'circle',
            x: x,
            y: y,
            seriesIndex: seriesIndex,
            name: name,
            index: index
          };

          if (showDot) {
            var _dotTheme$borderColor;

            dotSeriesModel.push(lineSeries_objectSpread(lineSeries_objectSpread({}, model), {}, {
              radius: dotTheme.radius,
              color: getRGBA(color, active ? 1 : 0.3),
              style: [{
                lineWidth: dotTheme.borderWidth,
                strokeStyle: (_dotTheme$borderColor = dotTheme.borderColor) !== null && _dotTheme$borderColor !== void 0 ? _dotTheme$borderColor : color
              }]
            }));
          }

          responderModel.push(lineSeries_objectSpread(lineSeries_objectSpread({}, model), {}, {
            radius: hoverDotTheme.radius,
            color: (_hoverDotTheme$color = hoverDotTheme.color) !== null && _hoverDotTheme$color !== void 0 ? _hoverDotTheme$color : getRGBA(color, 1),
            style: ['default']
          }));
        });
      });
      return {
        dotSeriesModel: dotSeriesModel,
        responderModel: responderModel
      };
    }
  }, {
    key: "getCircleModelsFromRectResponders",
    value: function getCircleModelsFromRectResponders(responders, mousePositions) {
      var _this$tooltipCircleMa, _responders$;

      if (!responders.length || !responders[0].label) {
        return [];
      }

      var models = (_this$tooltipCircleMa = this.tooltipCircleMap[(_responders$ = responders[0]) === null || _responders$ === void 0 ? void 0 : _responders$.label]) !== null && _this$tooltipCircleMa !== void 0 ? _this$tooltipCircleMa : [];
      return this.eventDetectType === 'grouped' ? models : getNearestResponder(models, mousePositions, this.rect);
    }
  }, {
    key: "onMousemoveNearType",
    value: function onMousemoveNearType(responders) {
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getResponderSeriesWithTheme(responders, 'hover'),
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = responders;
    }
  }, {
    key: "onMousemoveNearestType",
    value: function onMousemoveNearestType(responders, mousePositions) {
      var circleModels = this.getCircleModelsFromRectResponders(responders, mousePositions);
      this.onMousemoveNearType(circleModels);
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var circleModels = this.getCircleModelsFromRectResponders(responders);
      this.onMousemoveNearType(circleModels);
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref6) {
      var responders = _ref6.responders,
          mousePosition = _ref6.mousePosition;

      if (this.eventDetectType === 'nearest') {
        this.onMousemoveNearestType(responders, mousePosition);
      } else if (includes(['near', 'point'], this.eventDetectType)) {
        this.onMousemoveNearType(responders);
      } else {
        this.onMousemoveGroupedType(responders);
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "getDataLabels",
    value: function getDataLabels(seriesModels) {
      var dataLabelTheme = this.theme.dataLabels;
      return seriesModels.flatMap(function (_ref7) {
        var points = _ref7.points,
            name = _ref7.name,
            color = _ref7.color;
        return points.map(function (point) {
          return isNull(point) ? {} : lineSeries_objectSpread(lineSeries_objectSpread({
            type: 'point'
          }, point), {}, {
            name: name,
            theme: lineSeries_objectSpread(lineSeries_objectSpread({}, dataLabelTheme), {}, {
              color: dataLabelTheme.useSeriesColor ? color : dataLabelTheme.color
            })
          });
        });
      });
    }
  }, {
    key: "getResponderSeriesWithTheme",
    value: function getResponderSeriesWithTheme(models, type) {
      var _ref8 = this.theme[type].dot,
          radius = _ref8.radius,
          color = _ref8.color,
          borderWidth = _ref8.borderWidth,
          borderColor = _ref8.borderColor;
      return models.map(function (model) {
        var modelColor = color !== null && color !== void 0 ? color : model.color;
        return lineSeries_objectSpread(lineSeries_objectSpread({}, model), {}, {
          radius: radius,
          color: modelColor,
          style: [{
            lineWidth: borderWidth,
            strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5)
          }]
        });
      });
    }
  }, {
    key: "onClick",
    value: function onClick(_ref9) {
      var responders = _ref9.responders,
          mousePosition = _ref9.mousePosition;

      if (this.selectable) {
        var models;

        if (this.eventDetectType === 'near') {
          models = responders;
        } else {
          models = this.getCircleModelsFromRectResponders(responders, mousePosition);
        }

        this.eventBus.emit('renderSelectedSeries', {
          models: this.getResponderSeriesWithTheme(models, 'select'),
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "getResponderCategoryByIndex",
    value: function getResponderCategoryByIndex(index) {
      var _responder$data;

      var responder = Object.values(this.tooltipCircleMap).flatMap(function (val) {
        return val;
      }).find(function (model) {
        return model.index === index;
      });
      return responder === null || responder === void 0 ? void 0 : (_responder$data = responder.data) === null || _responder$data === void 0 ? void 0 : _responder$data.category;
    }
  }]);

  return LineSeries;
}(component_Component);


// CONCATENATED MODULE: ./src/component/legend.ts























function legend_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { legend_typeof = function _typeof(obj) { return typeof obj; }; } else { legend_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return legend_typeof(obj); }

function component_legend_toConsumableArray(arr) { return component_legend_arrayWithoutHoles(arr) || component_legend_iterableToArray(arr) || component_legend_unsupportedIterableToArray(arr) || component_legend_nonIterableSpread(); }

function component_legend_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function component_legend_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return component_legend_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return component_legend_arrayLikeToArray(o, minLen); }

function component_legend_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function component_legend_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return component_legend_arrayLikeToArray(arr); }

function component_legend_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function component_legend_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function component_legend_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { component_legend_ownKeys(Object(source), true).forEach(function (key) { component_legend_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { component_legend_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function legend_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function legend_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function legend_createClass(Constructor, protoProps, staticProps) { if (protoProps) legend_defineProperties(Constructor.prototype, protoProps); if (staticProps) legend_defineProperties(Constructor, staticProps); return Constructor; }

function legend_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) legend_setPrototypeOf(subClass, superClass); }

function legend_setPrototypeOf(o, p) { legend_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return legend_setPrototypeOf(o, p); }

function legend_createSuper(Derived) { var hasNativeReflectConstruct = legend_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = legend_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = legend_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return legend_possibleConstructorReturn(this, result); }; }

function legend_possibleConstructorReturn(self, call) { if (call && (legend_typeof(call) === "object" || typeof call === "function")) { return call; } return legend_assertThisInitialized(self); }

function legend_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function legend_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function legend_getPrototypeOf(o) { legend_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return legend_getPrototypeOf(o); }

function component_legend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var legend_Legend = /*#__PURE__*/function (_Component) {
  legend_inherits(Legend, _Component);

  var _super = legend_createSuper(Legend);

  function Legend() {
    var _this;

    legend_classCallCheck(this, Legend);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    component_legend_defineProperty(legend_assertThisInitialized(_this), "models", void 0);

    component_legend_defineProperty(legend_assertThisInitialized(_this), "responders", void 0);

    component_legend_defineProperty(legend_assertThisInitialized(_this), "theme", void 0);

    component_legend_defineProperty(legend_assertThisInitialized(_this), "activatedResponders", []);

    component_legend_defineProperty(legend_assertThisInitialized(_this), "seriesColorMap", {});

    component_legend_defineProperty(legend_assertThisInitialized(_this), "seriesIconTypeMap", {});

    component_legend_defineProperty(legend_assertThisInitialized(_this), "onClickCheckbox", function (responders) {
      var _responders$ = responders[0],
          label = _responders$.label,
          checked = _responders$.checked;

      _this.store.dispatch('setAllLegendActiveState', true);

      _this.store.dispatch('setLegendCheckedState', {
        name: label,
        checked: !checked
      });

      if (checked) {
        _this.store.dispatch('disableSeries', label);
      } else {
        _this.store.dispatch('enableSeries', label);
      }

      _this.eventBus.emit('needDraw');
    });

    component_legend_defineProperty(legend_assertThisInitialized(_this), "onClickLabel", function (responders) {
      var label = responders[0].label;

      _this.eventBus.emit('resetSelectedSeries');

      if (_this.activatedResponders.length && _this.activatedResponders[0].label === label) {
        _this.store.dispatch('setAllLegendActiveState', true);

        _this.activatedResponders = [];
      } else {
        _this.store.dispatch('setAllLegendActiveState', false);

        _this.store.dispatch('setLegendActiveState', {
          name: label,
          active: true
        });

        _this.activatedResponders = responders;
      }

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  legend_createClass(Legend, [{
    key: "onClick",
    value: function onClick(_ref) {
      var responders = _ref.responders;

      if (responders.length) {
        var data = responders[0].data;

        if ((data === null || data === void 0 ? void 0 : data.name) === 'checkbox') {
          this.eventBus.emit('clickLegendCheckbox', makeObservableObjectToNormal(responders));
        } else {
          this.eventBus.emit('clickLegendLabel', makeObservableObjectToNormal(responders));
        }
      }
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this.type = 'legend';
      this.name = 'legend';
      this.eventBus.on('clickLegendCheckbox', this.onClickCheckbox);
      this.eventBus.on('clickLegendLabel', this.onClickLabel);
    }
  }, {
    key: "initColorAndIconTypeMap",
    value: function initColorAndIconTypeMap(legendData) {
      var _this2 = this;

      this.seriesColorMap = {};
      this.seriesIconTypeMap = {};
      legendData.forEach(function (_ref2) {
        var label = _ref2.label,
            color = _ref2.color,
            iconType = _ref2.iconType;
        _this2.seriesColorMap[label] = color;
        _this2.seriesIconTypeMap[label] = iconType;
      });
    }
  }, {
    key: "renderLegendModel",
    value: function renderLegendModel(legend) {
      var _this3 = this;

      var defaultX = 0;
      var data = legend.data,
          showCheckbox = legend.showCheckbox,
          align = legend.align,
          useScatterChartIcon = legend.useScatterChartIcon;
      var verticalAlign = isVerticalAlign(align);
      var legendWidths = data.map(function (_ref3) {
        var width = _ref3.width;
        return width;
      });
      var itemHeight = getLegendItemHeight(this.theme.label.fontSize);
      return [component_legend_objectSpread({
        type: 'legend',
        align: align,
        showCheckbox: showCheckbox,
        data: data.map(function (datum, idx) {
          var _this3$seriesIconType;

          var xOffset = sum(legendWidths.slice(0, idx)) + LEGEND_ITEM_MARGIN_X * idx;
          return component_legend_objectSpread(component_legend_objectSpread({}, datum), {}, {
            iconType: (_this3$seriesIconType = _this3.seriesIconTypeMap[datum.label]) !== null && _this3$seriesIconType !== void 0 ? _this3$seriesIconType : datum.iconType,
            color: _this3.seriesColorMap[datum.label],
            x: verticalAlign ? defaultX + xOffset : defaultX,
            y: verticalAlign ? layout_padding.Y : layout_padding.Y + itemHeight * idx,
            useScatterChartIcon: useScatterChartIcon
          });
        })
      }, this.theme.label)];
    }
  }, {
    key: "makeCheckboxResponder",
    value: function makeCheckboxResponder(data, showCheckbox) {
      return showCheckbox ? data.map(function (m) {
        return component_legend_objectSpread(component_legend_objectSpread({}, m), {}, {
          type: 'rect',
          x: m.x,
          y: m.y,
          width: LEGEND_CHECKBOX_SIZE,
          height: LEGEND_CHECKBOX_SIZE,
          data: {
            name: 'checkbox'
          }
        });
      }) : [];
    }
  }, {
    key: "makeLabelResponder",
    value: function makeLabelResponder(data, showCheckbox) {
      var font = getTitleFontString(this.theme.label);
      return data.map(function (m) {
        return component_legend_objectSpread(component_legend_objectSpread({}, m), {}, {
          type: 'rect',
          x: m.x + (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) + LEGEND_ICON_SIZE + LEGEND_MARGIN_X,
          y: m.y,
          width: getTextWidth(m.label, font),
          data: {
            name: 'label'
          },
          height: LEGEND_CHECKBOX_SIZE
        });
      });
    }
  }, {
    key: "render",
    value: function render(_ref4) {
      var layout = _ref4.layout,
          legend = _ref4.legend,
          theme = _ref4.theme;
      this.isShow = legend.visible;

      if (!this.isShow) {
        return;
      } // @TODO: stack 일 떄 라벨 순서 역순으로(스택이 쌓인 순서대로) 되어야


      var showCheckbox = legend.showCheckbox,
          legendData = legend.data;
      this.rect = layout.legend;
      this.theme = theme.legend;
      this.initColorAndIconTypeMap(legendData);
      this.models = this.renderLegendModel(legend);
      var data = this.models[0].data;
      var checkboxResponder = this.makeCheckboxResponder(data, showCheckbox);
      var labelResponder = this.makeLabelResponder(data, showCheckbox);
      this.responders = [].concat(component_legend_toConsumableArray(checkboxResponder), component_legend_toConsumableArray(labelResponder));
    }
  }]);

  return Legend;
}(component_Component);


// CONCATENATED MODULE: ./src/component/dataLabels.ts


























function dataLabels_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { dataLabels_typeof = function _typeof(obj) { return typeof obj; }; } else { dataLabels_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return dataLabels_typeof(obj); }

function component_dataLabels_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function component_dataLabels_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { component_dataLabels_ownKeys(Object(source), true).forEach(function (key) { component_dataLabels_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { component_dataLabels_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function dataLabels_toConsumableArray(arr) { return dataLabels_arrayWithoutHoles(arr) || dataLabels_iterableToArray(arr) || dataLabels_unsupportedIterableToArray(arr) || dataLabels_nonIterableSpread(); }

function dataLabels_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function dataLabels_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dataLabels_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dataLabels_arrayLikeToArray(o, minLen); }

function dataLabels_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function dataLabels_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return dataLabels_arrayLikeToArray(arr); }

function dataLabels_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function dataLabels_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function dataLabels_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function dataLabels_createClass(Constructor, protoProps, staticProps) { if (protoProps) dataLabels_defineProperties(Constructor.prototype, protoProps); if (staticProps) dataLabels_defineProperties(Constructor, staticProps); return Constructor; }

function dataLabels_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) dataLabels_setPrototypeOf(subClass, superClass); }

function dataLabels_setPrototypeOf(o, p) { dataLabels_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return dataLabels_setPrototypeOf(o, p); }

function dataLabels_createSuper(Derived) { var hasNativeReflectConstruct = dataLabels_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = dataLabels_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = dataLabels_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return dataLabels_possibleConstructorReturn(this, result); }; }

function dataLabels_possibleConstructorReturn(self, call) { if (call && (dataLabels_typeof(call) === "object" || typeof call === "function")) { return call; } return dataLabels_assertThisInitialized(self); }

function dataLabels_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function dataLabels_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function dataLabels_getPrototypeOf(o) { dataLabels_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return dataLabels_getPrototypeOf(o); }

function component_dataLabels_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







function getLabelInfo(model, labelOptions, rect) {
  var type = model.type;
  var dataLabel = [];

  if (type === 'point') {
    dataLabel.push(makePointLabelInfo(model, labelOptions, rect));
  } else if (type === 'sector') {
    var _labelOptions$pieSeri;

    dataLabel.push(makeSectorLabelInfo(model, labelOptions));

    if ((_labelOptions$pieSeri = labelOptions.pieSeriesName) === null || _labelOptions$pieSeri === void 0 ? void 0 : _labelOptions$pieSeri.visible) {
      var seriesNameLabel = makePieSeriesNameLabelInfo(model, labelOptions);
      dataLabel.push(seriesNameLabel);
    }
  } else if (type === 'line') {
    dataLabel.push(makeLineLabelInfo(model, labelOptions));
  } else {
    dataLabel.push(makeRectLabelInfo(model, labelOptions));
  }

  return dataLabel;
}

var dataLabels_DataLabels = /*#__PURE__*/function (_Component) {
  dataLabels_inherits(DataLabels, _Component);

  var _super = dataLabels_createSuper(DataLabels);

  function DataLabels() {
    var _this;

    dataLabels_classCallCheck(this, DataLabels);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "models", void 0);

    component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "drawModels", void 0);

    component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "options", void 0);

    component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "dataLabelsMap", {});

    component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "renderSeriesDataLabels", function (seriesDataLabel) {
      _this.appendDataLabels(seriesDataLabel);

      _this.models = _this.renderLabelModel();

      if (!_this.drawModels) {
        _this.drawModels = _this.getDrawModelsAppliedOpacity(0);
      } else {
        _this.sync();
      }
    });

    return _this;
  }

  dataLabels_createClass(DataLabels, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'dataLabels';
      this.name = 'dataLabels';
      this.eventBus.on('renderDataLabels', this.renderSeriesDataLabels);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      if (!this.drawModels) {
        return;
      }

      this.drawModels = this.getDrawModelsAppliedOpacity(delta);
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout,
          options = _ref.options,
          series = _ref.series,
          nestedPieSeries = _ref.nestedPieSeries;
      this.rect = layout.plot;
      this.options = options;
      this.isShow = this.visibleDataLabels(series, nestedPieSeries);
    }
  }, {
    key: "visibleDataLabels",
    value: function visibleDataLabels(series, nestedPieSeries) {
      var _this$options$series,
          _this$options$series$,
          _this2 = this;

      var visibleCommonSeriesDataLabels = !!((_this$options$series = this.options.series) === null || _this$options$series === void 0 ? void 0 : (_this$options$series$ = _this$options$series.dataLabels) === null || _this$options$series$ === void 0 ? void 0 : _this$options$series$.visible);
      var visibleComboSeriesDataLabels = Object.keys(series).some(function (seriesName) {
        var _this2$options$series, _this2$options$series2, _this2$options$series3;

        return !!((_this2$options$series = _this2.options.series) === null || _this2$options$series === void 0 ? void 0 : (_this2$options$series2 = _this2$options$series[seriesName]) === null || _this2$options$series2 === void 0 ? void 0 : (_this2$options$series3 = _this2$options$series2.dataLabels) === null || _this2$options$series3 === void 0 ? void 0 : _this2$options$series3.visible);
      });
      var visibleNestedPieSeriesDataLabels = !!(nestedPieSeries && Object.keys(nestedPieSeries).some(function (alias) {
        var _this2$options$series4, _this2$options$series5, _this2$options$series6;

        return !!((_this2$options$series4 = _this2.options.series) === null || _this2$options$series4 === void 0 ? void 0 : (_this2$options$series5 = _this2$options$series4[alias]) === null || _this2$options$series5 === void 0 ? void 0 : (_this2$options$series6 = _this2$options$series5.dataLabels) === null || _this2$options$series6 === void 0 ? void 0 : _this2$options$series6.visible);
      }));
      return visibleCommonSeriesDataLabels || visibleComboSeriesDataLabels || visibleNestedPieSeriesDataLabels;
    }
  }, {
    key: "appendDataLabels",
    value: function appendDataLabels(_ref2) {
      var _this3 = this;

      var name = _ref2.name,
          data = _ref2.data;
      var dataLabelOptions = getDataLabelsOptions(this.options, name);
      var withStack = !!pickStackOption(this.options);
      var labels = [];
      data.forEach(function (model) {
        var _labelOptions$stackTo;

        var type = model.type,
            value = model.value;
        var labelOptions = getDefaultDataLabelsOptions(dataLabelOptions, type, withStack);
        var disableStackTotal = type === 'stackTotal' && !((_labelOptions$stackTo = labelOptions.stackTotal) === null || _labelOptions$stackTo === void 0 ? void 0 : _labelOptions$stackTo.visible);

        if (disableStackTotal || isUndefined(value)) {
          return;
        }

        labels.splice.apply(labels, [labels.length, 0].concat(dataLabels_toConsumableArray(getLabelInfo(model, labelOptions, _this3.rect))));
      });
      this.dataLabelsMap[name] = {
        data: labels,
        options: dataLabelOptions
      };
    }
  }, {
    key: "getDrawModelsAppliedOpacity",
    value: function getDrawModelsAppliedOpacity(opacity) {
      var _this4 = this;

      return Object.keys(this.models).reduce(function (acc, key) {
        return component_dataLabels_objectSpread(component_dataLabels_objectSpread({}, acc), {}, component_dataLabels_defineProperty({}, key, _this4.models[key].map(function (m) {
          return component_dataLabels_objectSpread(component_dataLabels_objectSpread({}, m), {}, {
            opacity: opacity
          });
        })));
      }, {
        series: [],
        total: []
      });
    }
  }, {
    key: "renderLabelModel",
    value: function renderLabelModel() {
      var _this5 = this;

      return Object.keys(this.dataLabelsMap).map(function (seriesName) {
        var data = _this5.dataLabelsMap[seriesName].data;
        return _this5.makeLabelModel(data);
      }).reduce(function (acc, cur) {
        return {
          series: [].concat(dataLabels_toConsumableArray(acc.series), dataLabels_toConsumableArray(cur.series)),
          total: [].concat(dataLabels_toConsumableArray(acc.total), dataLabels_toConsumableArray(cur.total))
        };
      }, {
        series: [],
        total: []
      });
    }
  }, {
    key: "makeLabelModel",
    value: function makeLabelModel(dataLabels) {
      var _this6 = this;

      return dataLabels.reduce(function (acc, dataLabel) {
        var _acc$modelName;

        var type = dataLabel.type,
            x = dataLabel.x,
            y = dataLabel.y,
            text = dataLabel.text,
            textAlign = dataLabel.textAlign,
            textBaseline = dataLabel.textBaseline,
            name = dataLabel.name,
            callout = dataLabel.callout,
            theme = dataLabel.theme;

        if (!isModelExistingInRect(_this6.rect, {
          x: x,
          y: y
        })) {
          return acc;
        }

        var modelName = type === 'stackTotal' ? 'total' : 'series';
        return component_dataLabels_objectSpread(component_dataLabels_objectSpread({}, acc), {}, component_dataLabels_defineProperty({}, modelName, [].concat(dataLabels_toConsumableArray((_acc$modelName = acc[modelName]) !== null && _acc$modelName !== void 0 ? _acc$modelName : []), [{
          type: 'dataLabel',
          dataLabelType: type,
          text: text,
          x: x,
          y: y,
          textAlign: textAlign,
          textBaseline: textBaseline,
          opacity: 1,
          name: name,
          callout: callout,
          theme: theme
        }])));
      }, {
        series: [],
        total: []
      });
    }
  }]);

  return DataLabels;
}(component_Component);


// CONCATENATED MODULE: ./src/component/axisTitle.ts
















function axisTitle_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { axisTitle_typeof = function _typeof(obj) { return typeof obj; }; } else { axisTitle_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return axisTitle_typeof(obj); }

function axisTitle_slicedToArray(arr, i) { return axisTitle_arrayWithHoles(arr) || axisTitle_iterableToArrayLimit(arr, i) || axisTitle_unsupportedIterableToArray(arr, i) || axisTitle_nonIterableRest(); }

function axisTitle_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function axisTitle_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return axisTitle_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return axisTitle_arrayLikeToArray(o, minLen); }

function axisTitle_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function axisTitle_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function axisTitle_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function axisTitle_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function axisTitle_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function axisTitle_createClass(Constructor, protoProps, staticProps) { if (protoProps) axisTitle_defineProperties(Constructor.prototype, protoProps); if (staticProps) axisTitle_defineProperties(Constructor, staticProps); return Constructor; }

function axisTitle_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) axisTitle_setPrototypeOf(subClass, superClass); }

function axisTitle_setPrototypeOf(o, p) { axisTitle_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return axisTitle_setPrototypeOf(o, p); }

function axisTitle_createSuper(Derived) { var hasNativeReflectConstruct = axisTitle_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = axisTitle_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = axisTitle_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return axisTitle_possibleConstructorReturn(this, result); }; }

function axisTitle_possibleConstructorReturn(self, call) { if (call && (axisTitle_typeof(call) === "object" || typeof call === "function")) { return call; } return axisTitle_assertThisInitialized(self); }

function axisTitle_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function axisTitle_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function axisTitle_getPrototypeOf(o) { axisTitle_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return axisTitle_getPrototypeOf(o); }

function axisTitle_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var axisTitle_AxisTitle = /*#__PURE__*/function (_Component) {
  axisTitle_inherits(AxisTitle, _Component);

  var _super = axisTitle_createSuper(AxisTitle);

  function AxisTitle() {
    var _this;

    axisTitle_classCallCheck(this, AxisTitle);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    axisTitle_defineProperty(axisTitle_assertThisInitialized(_this), "models", void 0);

    axisTitle_defineProperty(axisTitle_assertThisInitialized(_this), "isYAxis", void 0);

    axisTitle_defineProperty(axisTitle_assertThisInitialized(_this), "theme", void 0);

    return _this;
  }

  axisTitle_createClass(AxisTitle, [{
    key: "initialize",
    value: function initialize(_ref) {
      var name = _ref.name;
      this.type = 'axisTitle';
      this.name = name;
      this.isYAxis = includes([AxisType.Y, AxisType.SECONDARY_Y], name);
    }
  }, {
    key: "renderAxisTitle",
    value: function renderAxisTitle(option, textAlign) {
      var text = option.text,
          offsetX = option.offsetX,
          offsetY = option.offsetY;

      var _ref2 = this.isYAxis ? [this.name === AxisType.Y ? offsetX : this.rect.width + offsetX, offsetY] : [this.rect.width + offsetX, offsetY],
          _ref3 = axisTitle_slicedToArray(_ref2, 2),
          x = _ref3[0],
          y = _ref3[1];

      var font = getTitleFontString(this.theme);
      var fillStyle = this.theme.color;
      return [{
        type: 'label',
        text: text,
        x: x,
        y: y,
        style: ['axisTitle', {
          textAlign: textAlign,
          fillStyle: fillStyle,
          font: font
        }]
      }];
    }
  }, {
    key: "getTextAlign",
    value: function getTextAlign() {
      var hasCenterYAxis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var result = 'right';

      if (this.name === AxisType.Y) {
        result = hasCenterYAxis ? 'center' : 'left';
      }

      return result;
    }
  }, {
    key: "render",
    value: function render(_ref4) {
      var _axes$this$name;

      var axes = _ref4.axes,
          layout = _ref4.layout,
          theme = _ref4.theme;
      var titleOption = (_axes$this$name = axes[this.name]) === null || _axes$this$name === void 0 ? void 0 : _axes$this$name.title;
      this.isShow = !!titleOption;

      if (!this.isShow) {
        return;
      }

      this.rect = layout["".concat(this.name, "Title")];
      this.theme = getAxisTheme(theme, this.name).title;
      this.models = this.renderAxisTitle(titleOption, this.getTextAlign(!!axes.centerYAxis));
    }
  }]);

  return AxisTitle;
}(component_Component);


// CONCATENATED MODULE: ./src/component/title.ts














function title_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { title_typeof = function _typeof(obj) { return typeof obj; }; } else { title_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return title_typeof(obj); }

function title_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function title_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function title_createClass(Constructor, protoProps, staticProps) { if (protoProps) title_defineProperties(Constructor.prototype, protoProps); if (staticProps) title_defineProperties(Constructor, staticProps); return Constructor; }

function title_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) title_setPrototypeOf(subClass, superClass); }

function title_setPrototypeOf(o, p) { title_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return title_setPrototypeOf(o, p); }

function title_createSuper(Derived) { var hasNativeReflectConstruct = title_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = title_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = title_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return title_possibleConstructorReturn(this, result); }; }

function title_possibleConstructorReturn(self, call) { if (call && (title_typeof(call) === "object" || typeof call === "function")) { return call; } return title_assertThisInitialized(self); }

function title_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function title_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function title_getPrototypeOf(o) { title_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return title_getPrototypeOf(o); }

function title_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var title_Title = /*#__PURE__*/function (_Component) {
  title_inherits(Title, _Component);

  var _super = title_createSuper(Title);

  function Title() {
    var _this;

    title_classCallCheck(this, Title);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    title_defineProperty(title_assertThisInitialized(_this), "models", void 0);

    title_defineProperty(title_assertThisInitialized(_this), "theme", void 0);

    return _this;
  }

  title_createClass(Title, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'title';
      this.name = 'title';
    }
  }, {
    key: "renderTitle",
    value: function renderTitle(options) {
      var text = '';
      var x = 0;
      var y = 0;
      var align = 'left';

      if (isString(options)) {
        text = options;
      } else {
        var _options$align, _options$offsetX, _options$offsetY;

        text = options.text;
        align = (_options$align = options.align) !== null && _options$align !== void 0 ? _options$align : 'left';
        x += (_options$offsetX = options.offsetX) !== null && _options$offsetX !== void 0 ? _options$offsetX : 0;
        y += (_options$offsetY = options.offsetY) !== null && _options$offsetY !== void 0 ? _options$offsetY : 0;
      }

      var font = getTitleFontString(this.theme);
      var textWidth = getTextWidth(text, font);

      if (align === 'center') {
        x += (this.rect.width - textWidth) / 2;
      } else if (align === 'right') {
        x += this.rect.width - textWidth;
      }

      return [{
        type: 'label',
        x: x,
        y: y,
        text: text,
        style: ['title', {
          font: font,
          fillStyle: this.theme.color
        }]
      }];
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var _options$chart;

      var options = _ref.options,
          layout = _ref.layout,
          theme = _ref.theme;
      this.isShow = !!((_options$chart = options.chart) === null || _options$chart === void 0 ? void 0 : _options$chart.title);

      if (!this.isShow) {
        return;
      }

      this.theme = theme.title;
      this.rect = layout.title;
      this.models = this.renderTitle(options.chart.title);
    }
  }]);

  return Title;
}(component_Component);


// CONCATENATED MODULE: ./src/component/hoveredSeries.ts






















function hoveredSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { hoveredSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { hoveredSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return hoveredSeries_typeof(obj); }

function hoveredSeries_slicedToArray(arr, i) { return hoveredSeries_arrayWithHoles(arr) || hoveredSeries_iterableToArrayLimit(arr, i) || hoveredSeries_unsupportedIterableToArray(arr, i) || hoveredSeries_nonIterableRest(); }

function hoveredSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function hoveredSeries_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function hoveredSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function hoveredSeries_toConsumableArray(arr) { return hoveredSeries_arrayWithoutHoles(arr) || hoveredSeries_iterableToArray(arr) || hoveredSeries_unsupportedIterableToArray(arr) || hoveredSeries_nonIterableSpread(); }

function hoveredSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function hoveredSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return hoveredSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return hoveredSeries_arrayLikeToArray(o, minLen); }

function hoveredSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function hoveredSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return hoveredSeries_arrayLikeToArray(arr); }

function hoveredSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function hoveredSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function hoveredSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function hoveredSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) hoveredSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) hoveredSeries_defineProperties(Constructor, staticProps); return Constructor; }

function hoveredSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) hoveredSeries_setPrototypeOf(subClass, superClass); }

function hoveredSeries_setPrototypeOf(o, p) { hoveredSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return hoveredSeries_setPrototypeOf(o, p); }

function hoveredSeries_createSuper(Derived) { var hasNativeReflectConstruct = hoveredSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = hoveredSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = hoveredSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return hoveredSeries_possibleConstructorReturn(this, result); }; }

function hoveredSeries_possibleConstructorReturn(self, call) { if (call && (hoveredSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return hoveredSeries_assertThisInitialized(self); }

function hoveredSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function hoveredSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function hoveredSeries_getPrototypeOf(o) { hoveredSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return hoveredSeries_getPrototypeOf(o); }

function hoveredSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var guideLineType = {
  line: 'circle',
  area: 'circle',
  boxPlot: 'boxPlot'
};

var hoveredSeries_HoveredSeries = /*#__PURE__*/function (_Component) {
  hoveredSeries_inherits(HoveredSeries, _Component);

  var _super = hoveredSeries_createSuper(HoveredSeries);

  function HoveredSeries() {
    var _this;

    hoveredSeries_classCallCheck(this, HoveredSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "models", {
      guideLine: []
    });

    hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "isShow", false);

    hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "modelForGuideLine", void 0);

    hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "renderHoveredSeries", function (_ref) {
      var models = _ref.models,
          name = _ref.name,
          eventDetectType = _ref.eventDetectType;

      var prevModels = _this.getSeriesModels(name);

      _this.models[name] = hoveredSeries_toConsumableArray(models);
      _this.isShow = !!_this.getSeriesModels().length;
      var isSame = !!(prevModels === null || prevModels === void 0 ? void 0 : prevModels.length) && !!models.length && isSameSeriesResponder({
        models: models,
        comparisonModel: prevModels,
        eventDetectType: eventDetectType,
        name: name
      });

      if ((prevModels === null || prevModels === void 0 ? void 0 : prevModels.length) && !models.length) {
        _this.eventBus.emit('unhoverSeries', makeObservableObjectToNormal(prevModels));
      } else if (models.length && !isSame) {
        _this.eventBus.emit('hoverSeries', makeObservableObjectToNormal(models));
      }

      _this.modelForGuideLine = _this.getModelForGuideLine(name);

      if (eventDetectType === 'grouped') {
        _this.renderGroupedModels(name);
      }
    });

    hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "resetHoveredSeries", function () {
      _this.models = {
        guideLine: []
      };
    });

    return _this;
  }

  hoveredSeries_createClass(HoveredSeries, [{
    key: "getSeriesModels",
    value: function getSeriesModels(type) {
      var _ref2;

      var _this$models = this.models,
          guideLine = _this$models.guideLine,
          models = _objectWithoutProperties(_this$models, ["guideLine"]);

      return (_ref2 = type ? models[type] : Object.values(models)) === null || _ref2 === void 0 ? void 0 : _ref2.flatMap(function (val) {
        return val;
      });
    }
  }, {
    key: "hasGuideLine",
    value: function hasGuideLine() {
      var _this$getSeriesModels = this.getSeriesModels().filter(function (_ref3) {
        var type = _ref3.type;
        return type === 'rect';
      }),
          _this$getSeriesModels2 = hoveredSeries_slicedToArray(_this$getSeriesModels, 1),
          rectModel = _this$getSeriesModels2[0];

      return !isUndefined(this.modelForGuideLine) && isUndefined(rectModel);
    }
  }, {
    key: "getModelForGuideLine",
    value: function getModelForGuideLine(name) {
      return this.getSeriesModels().filter(function (_ref4) {
        var type = _ref4.type;
        return type === guideLineType[name];
      })[0];
    }
  }, {
    key: "renderGroupedModels",
    value: function renderGroupedModels(name) {
      if (includes(Object.keys(guideLineType), name)) {
        if (this.isShow && this.hasGuideLine()) {
          this.models.guideLine = [this.renderGuideLineModel(this.modelForGuideLine)];
        } else {
          this.models.guideLine = [];
        }
      }
    }
  }, {
    key: "renderGuideLineModel",
    value: function renderGuideLineModel(model) {
      var x = crispPixel(model.type === 'boxPlot' && model.boxPlotDetection ? model.boxPlotDetection.x + model.boxPlotDetection.width / 2 : model.x);
      return {
        type: 'line',
        x: x,
        y: 0,
        x2: x,
        y2: this.rect.height,
        strokeStyle: '#ddd',
        lineWidth: 1
      };
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this.type = 'hoveredSeries';
      this.name = 'hoveredSeries';
      this.eventBus.on('renderHoveredSeries', this.renderHoveredSeries);
      this.eventBus.on('resetHoveredSeries', this.resetHoveredSeries);
    }
  }, {
    key: "render",
    value: function render(_ref5) {
      var layout = _ref5.layout;
      this.rect = layout.plot;
    }
  }]);

  return HoveredSeries;
}(component_Component);


// CONCATENATED MODULE: ./src/component/zoom.ts


























function zoom_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { zoom_typeof = function _typeof(obj) { return typeof obj; }; } else { zoom_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return zoom_typeof(obj); }

function zoom_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function zoom_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { zoom_ownKeys(Object(source), true).forEach(function (key) { zoom_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { zoom_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function zoom_toConsumableArray(arr) { return zoom_arrayWithoutHoles(arr) || zoom_iterableToArray(arr) || zoom_unsupportedIterableToArray(arr) || zoom_nonIterableSpread(); }

function zoom_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function zoom_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function zoom_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return zoom_arrayLikeToArray(arr); }

function zoom_slicedToArray(arr, i) { return zoom_arrayWithHoles(arr) || zoom_iterableToArrayLimit(arr, i) || zoom_unsupportedIterableToArray(arr, i) || zoom_nonIterableRest(); }

function zoom_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function zoom_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return zoom_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return zoom_arrayLikeToArray(o, minLen); }

function zoom_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function zoom_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function zoom_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function zoom_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function zoom_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function zoom_createClass(Constructor, protoProps, staticProps) { if (protoProps) zoom_defineProperties(Constructor.prototype, protoProps); if (staticProps) zoom_defineProperties(Constructor, staticProps); return Constructor; }

function zoom_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) zoom_setPrototypeOf(subClass, superClass); }

function zoom_setPrototypeOf(o, p) { zoom_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return zoom_setPrototypeOf(o, p); }

function zoom_createSuper(Derived) { var hasNativeReflectConstruct = zoom_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = zoom_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = zoom_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return zoom_possibleConstructorReturn(this, result); }; }

function zoom_possibleConstructorReturn(self, call) { if (call && (zoom_typeof(call) === "object" || typeof call === "function")) { return call; } return zoom_assertThisInitialized(self); }

function zoom_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function zoom_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function zoom_getPrototypeOf(o) { zoom_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return zoom_getPrototypeOf(o); }

function zoom_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var DRAG_MIN_WIDTH = 15;

var zoom_Zoom = /*#__PURE__*/function (_Component) {
  zoom_inherits(Zoom, _Component);

  var _super = zoom_createSuper(Zoom);

  function Zoom() {
    var _this;

    zoom_classCallCheck(this, Zoom);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    zoom_defineProperty(zoom_assertThisInitialized(_this), "models", {
      selectionArea: []
    });

    zoom_defineProperty(zoom_assertThisInitialized(_this), "responders", void 0);

    zoom_defineProperty(zoom_assertThisInitialized(_this), "dragStartPosition", null);

    zoom_defineProperty(zoom_assertThisInitialized(_this), "dragStartPoint", null);

    zoom_defineProperty(zoom_assertThisInitialized(_this), "isDragging", false);

    return _this;
  }

  zoom_createClass(Zoom, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'zoom';
    }
  }, {
    key: "render",
    value: function render(state) {
      if (!state.zoomRange) {
        return;
      }

      this.resetSelectionArea();
      var layout = state.layout,
          axes = state.axes,
          categories = state.categories;
      this.rect = layout.plot;
      var _ref = axes.xAxis,
          tickDistance = _ref.tickDistance,
          pointOnColumn = _ref.pointOnColumn,
          tickCount = _ref.tickCount;
      this.responders = this.makeRectResponderModel(categories, {
        pointOnColumn: pointOnColumn,
        tickDistance: tickDistance,
        tickCount: tickCount
      });
    }
  }, {
    key: "resetSelectionArea",
    value: function resetSelectionArea() {
      this.dragStartPosition = null;
      this.dragStartPoint = null;
      this.models.selectionArea = [];
      this.isDragging = false;
    }
  }, {
    key: "onMousedown",
    value: function onMousedown(_ref2) {
      var responders = _ref2.responders,
          mousePosition = _ref2.mousePosition;

      if (responders.length) {
        this.dragStartPoint = responders.find(function (responder) {
          return responder.data.name === 'selectionArea';
        });
        this.dragStartPosition = mousePosition;
      }
    }
  }, {
    key: "onMouseup",
    value: function onMouseup(_ref3) {
      var _this2 = this;

      var responders = _ref3.responders;

      if (this.isDragging && this.dragStartPoint && responders.length) {
        var dragRange = [this.dragStartPoint, responders[0]].sort(function (a, b) {
          return a.index - b.index;
        }).map(function (m) {
          var _m$data;

          return (_m$data = m.data) === null || _m$data === void 0 ? void 0 : _m$data.value;
        });
        this.store.dispatch('zoom', dragRange);
        this.eventBus.emit('zoom', makeObservableObjectToNormal(dragRange));
        this.eventBus.emit('resetHoveredSeries');
        this.eventBus.emit('hideTooltip'); // @TODO: Should occur after the series' click event
        // Additional logic to control the sequence of events with each other is required.

        setTimeout(function () {
          _this2.eventBus.emit('resetSelectedSeries');
        });
      }

      this.resetSelectionArea();
    }
  }, {
    key: "makeRectResponderModel",
    value: function makeRectResponderModel(categories, renderOptions) {
      var categorySize = categories.length;
      var pointOnColumn = renderOptions.pointOnColumn,
          tickDistance = renderOptions.tickDistance;
      var height = this.rect.height;
      var halfDetectAreaIndex = pointOnColumn ? [] : [0, categorySize - 1];
      var halfWidth = tickDistance / 2;
      return utils_range(0, categorySize).map(function (index) {
        var half = halfDetectAreaIndex.includes(index);
        var width = half ? halfWidth : tickDistance;
        var startX = 0;

        if (index !== 0) {
          startX += pointOnColumn ? tickDistance * index : halfWidth + tickDistance * (index - 1);
        }

        return {
          type: 'rect',
          x: startX,
          y: 0,
          height: height,
          width: width,
          index: index,
          data: {
            name: 'selectionArea',
            value: categories[index]
          }
        };
      });
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref4) {
      var responders = _ref4.responders,
          mousePosition = _ref4.mousePosition;

      if (!responders.length) {
        return;
      }

      if (this.dragStartPosition && !this.isDragging) {
        var x = mousePosition.x;
        var startX = this.dragStartPosition.x;
        this.isDragging = Math.abs(startX - x) > DRAG_MIN_WIDTH;
      }

      if (this.isDragging) {
        var startIndex = this.dragStartPoint.index;
        var endIndex = responders[0].index;

        var _sort = [startIndex, endIndex].sort(sortNumber),
            _sort2 = zoom_slicedToArray(_sort, 2),
            start = _sort2[0],
            end = _sort2[1];

        var includedResponders = this.responders.slice(start, end + 1);
        this.models.selectionArea = zoom_toConsumableArray(includedResponders.map(function (m) {
          return zoom_objectSpread(zoom_objectSpread({}, m), {}, {
            x: m.x,
            y: 0,
            type: 'rect',
            color: 'rgba(0, 0, 0, 0.2)'
          });
        }));
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "onMouseoutComponent",
    value: function onMouseoutComponent() {
      this.resetSelectionArea();
    }
  }]);

  return Zoom;
}(component_Component);


// CONCATENATED MODULE: ./src/component/resetButton.ts














function resetButton_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { resetButton_typeof = function _typeof(obj) { return typeof obj; }; } else { resetButton_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return resetButton_typeof(obj); }

function resetButton_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function resetButton_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function resetButton_createClass(Constructor, protoProps, staticProps) { if (protoProps) resetButton_defineProperties(Constructor.prototype, protoProps); if (staticProps) resetButton_defineProperties(Constructor, staticProps); return Constructor; }

function resetButton_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) resetButton_setPrototypeOf(subClass, superClass); }

function resetButton_setPrototypeOf(o, p) { resetButton_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return resetButton_setPrototypeOf(o, p); }

function resetButton_createSuper(Derived) { var hasNativeReflectConstruct = resetButton_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = resetButton_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = resetButton_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return resetButton_possibleConstructorReturn(this, result); }; }

function resetButton_possibleConstructorReturn(self, call) { if (call && (resetButton_typeof(call) === "object" || typeof call === "function")) { return call; } return resetButton_assertThisInitialized(self); }

function resetButton_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function resetButton_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function resetButton_getPrototypeOf(o) { resetButton_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return resetButton_getPrototypeOf(o); }

function resetButton_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var resetButton_ResetButton = /*#__PURE__*/function (_Component) {
  resetButton_inherits(ResetButton, _Component);

  var _super = resetButton_createSuper(ResetButton);

  function ResetButton() {
    var _this;

    resetButton_classCallCheck(this, ResetButton);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    resetButton_defineProperty(resetButton_assertThisInitialized(_this), "responders", void 0);

    resetButton_defineProperty(resetButton_assertThisInitialized(_this), "models", void 0);

    return _this;
  }

  resetButton_createClass(ResetButton, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'resetButton';
      this.name = 'resetButton';
    }
  }, {
    key: "onClick",
    value: function onClick(_ref) {
      var responders = _ref.responders;

      if (responders.length) {
        this.eventBus.emit('resetZoom');
        this.store.dispatch('resetZoom');
      }
    }
  }, {
    key: "render",
    value: function render(_ref2, computed) {
      var options = _ref2.options,
          layout = _ref2.layout;

      if (!isUsingResetButton(options)) {
        return;
      }

      this.rect = layout.resetButton;
      this.isShow = computed.isLineTypeSeriesZooming;
      this.models = this.isShow ? [{
        type: 'resetButton',
        x: 0,
        y: 0
      }] : [];
      this.responders = this.isShow ? [{
        type: 'rect',
        x: 0,
        y: 0,
        width: BUTTON_RECT_SIZE,
        height: BUTTON_RECT_SIZE
      }] : [];
    }
  }]);

  return ResetButton;
}(component_Component);


// CONCATENATED MODULE: ./src/component/selectedSeries.ts























function selectedSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { selectedSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { selectedSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return selectedSeries_typeof(obj); }

function selectedSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function selectedSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { selectedSeries_ownKeys(Object(source), true).forEach(function (key) { selectedSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { selectedSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function selectedSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function selectedSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function selectedSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) selectedSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) selectedSeries_defineProperties(Constructor, staticProps); return Constructor; }

function selectedSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) selectedSeries_setPrototypeOf(subClass, superClass); }

function selectedSeries_setPrototypeOf(o, p) { selectedSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return selectedSeries_setPrototypeOf(o, p); }

function selectedSeries_createSuper(Derived) { var hasNativeReflectConstruct = selectedSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = selectedSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = selectedSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return selectedSeries_possibleConstructorReturn(this, result); }; }

function selectedSeries_possibleConstructorReturn(self, call) { if (call && (selectedSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return selectedSeries_assertThisInitialized(self); }

function selectedSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function selectedSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function selectedSeries_getPrototypeOf(o) { selectedSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return selectedSeries_getPrototypeOf(o); }

function selectedSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var selectedSeries_SelectedSeries = /*#__PURE__*/function (_Component) {
  selectedSeries_inherits(SelectedSeries, _Component);

  var _super = selectedSeries_createSuper(SelectedSeries);

  function SelectedSeries() {
    var _this;

    selectedSeries_classCallCheck(this, SelectedSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "models", {});

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "activeSeriesNames", {});

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "isShow", false);

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "renderSelectedSeries", function (selectedSeriesEventModel) {
      var name = selectedSeriesEventModel.name,
          alias = selectedSeriesEventModel.alias;

      var models = _this.getSelectedSeriesModels(selectedSeriesEventModel);

      _this.models[alias || name] = isSameSeriesResponder(selectedSeries_objectSpread(selectedSeries_objectSpread({}, selectedSeriesEventModel), {}, {
        models: models,
        comparisonModel: _this.models[alias || name]
      })) ? [] : models;
      _this.isShow = !!Object.values(_this.models).flatMap(function (value) {
        return value;
      }).length;

      _this.eventBus.emit(_this.isShow ? 'selectSeries' : 'unselectSeries', makeObservableObjectToNormal(_this.models));

      _this.activeSeriesNames[name] = _this.getSeriesNames(selectedSeriesEventModel.models, name);

      _this.setActiveState();
    });

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "resetSelectedSeries", function () {
      _this.models = {};

      _this.store.dispatch('setAllLegendActiveState', true);
    });

    return _this;
  }

  selectedSeries_createClass(SelectedSeries, [{
    key: "getSeriesNames",
    value: function getSeriesNames(selectedSeries, name) {
      var _this2 = this;

      var names = [];

      if (includes(['line', 'area', 'radar', 'bubble', 'scatter', 'bullet', 'boxPlot'], name)) {
        selectedSeries.forEach(function (model) {
          var label = model.name;

          if (label) {
            names.push(label);
          }
        });
      } else if (includes(['bar', 'column'], name)) {
        selectedSeries.forEach(function (model) {
          var _data;

          var label = (_data = model.data) === null || _data === void 0 ? void 0 : _data.label;

          if (label) {
            names.push(label);
          }
        });
      } else if (name === 'pie') {
        Object.keys(this.models).flatMap(function (key) {
          return _this2.models[key];
        }).forEach(function (model) {
          var _data2, _data3;

          var label = ((_data2 = model.data) === null || _data2 === void 0 ? void 0 : _data2.rootParentName) || ((_data3 = model.data) === null || _data3 === void 0 ? void 0 : _data3.label);

          if (label) {
            names.push(label);
          }
        });
      }

      return names;
    }
  }, {
    key: "getSelectedSeriesModels",
    value: function getSelectedSeriesModels(selectedSeriesEventModel) {
      var models = selectedSeriesEventModel.models,
          eventDetectType = selectedSeriesEventModel.eventDetectType,
          name = selectedSeriesEventModel.name;
      var selectedSeriesModels = models;

      if ((name === 'column' || name === 'bar' || name === 'bullet') && eventDetectType === 'grouped') {
        selectedSeriesModels = models.filter(function (model) {
          return !model.data;
        });
      }

      return selectedSeriesModels;
    }
  }, {
    key: "setActiveState",
    value: function setActiveState() {
      var _this3 = this;

      if (this.isShow) {
        this.store.dispatch('setAllLegendActiveState', false);
        Object.values(this.activeSeriesNames).forEach(function (names) {
          names.forEach(function (name) {
            _this3.store.dispatch('setLegendActiveState', {
              name: name,
              active: true
            });
          });
        });
      } else {
        this.store.dispatch('setAllLegendActiveState', true);
      }

      this.eventBus.emit('needDraw');
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this.type = 'selectedSeries';
      this.name = 'selectedSeries';
      this.eventBus.on('renderSelectedSeries', this.renderSelectedSeries);
      this.eventBus.on('resetSelectedSeries', this.resetSelectedSeries);
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout;
      this.rect = layout.plot;
    }
  }]);

  return SelectedSeries;
}(component_Component);


// CONCATENATED MODULE: ./src/component/background.ts




















function background_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { background_typeof = function _typeof(obj) { return typeof obj; }; } else { background_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return background_typeof(obj); }

function background_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function background_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { background_ownKeys(Object(source), true).forEach(function (key) { background_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { background_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function background_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function background_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function background_createClass(Constructor, protoProps, staticProps) { if (protoProps) background_defineProperties(Constructor.prototype, protoProps); if (staticProps) background_defineProperties(Constructor, staticProps); return Constructor; }

function background_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) background_setPrototypeOf(subClass, superClass); }

function background_setPrototypeOf(o, p) { background_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return background_setPrototypeOf(o, p); }

function background_createSuper(Derived) { var hasNativeReflectConstruct = background_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = background_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = background_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return background_possibleConstructorReturn(this, result); }; }

function background_possibleConstructorReturn(self, call) { if (call && (background_typeof(call) === "object" || typeof call === "function")) { return call; } return background_assertThisInitialized(self); }

function background_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function background_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function background_getPrototypeOf(o) { background_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return background_getPrototypeOf(o); }

function background_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var Background = /*#__PURE__*/function (_Component) {
  background_inherits(Background, _Component);

  var _super = background_createSuper(Background);

  function Background() {
    var _this;

    background_classCallCheck(this, Background);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    background_defineProperty(background_assertThisInitialized(_this), "models", void 0);

    background_defineProperty(background_assertThisInitialized(_this), "theme", void 0);

    return _this;
  }

  background_createClass(Background, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'background';
      this.name = 'background';
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout,
          theme = _ref.theme;
      var _layout$chart = layout.chart,
          width = _layout$chart.width,
          height = _layout$chart.height;
      this.theme = theme.chart;
      this.rect = {
        x: 0,
        y: 0,
        width: width,
        height: height
      };
      this.models = [background_objectSpread(background_objectSpread({
        type: 'rect'
      }, this.rect), {}, {
        color: this.theme.backgroundColor
      })];
    }
  }]);

  return Background;
}(component_Component);


// CONCATENATED MODULE: ./src/brushes/lineSeries.ts




function lineSeries_linePoints(ctx, pointsModel) {
  var strokeStyle = pointsModel.color,
      lineWidth = pointsModel.lineWidth,
      points = pointsModel.points,
      _pointsModel$dashSegm = pointsModel.dashSegments,
      dashSegments = _pointsModel$dashSegm === void 0 ? [] : _pointsModel$dashSegm;
  ctx.lineCap = 'round';
  ctx.beginPath();

  if (dashSegments) {
    setLineDash(ctx, dashSegments);
  }

  var start = false;
  points.forEach(function (point, idx) {
    var _points, _points$controlPoint;

    if (isNull(point)) {
      start = false;
      return;
    }

    if (!start) {
      ctx.moveTo(point.x, point.y);
      start = true;
      return;
    }

    if (point.controlPoint && ((_points = points[idx - 1]) === null || _points === void 0 ? void 0 : (_points$controlPoint = _points.controlPoint) === null || _points$controlPoint === void 0 ? void 0 : _points$controlPoint.next)) {
      var _next = points[idx - 1].controlPoint.next,
          prevX = _next.x,
          prevY = _next.y;
      var controlPoint = point.controlPoint,
          x = point.x,
          y = point.y;
      ctx.bezierCurveTo(prevX, prevY, controlPoint.prev.x, controlPoint.prev.y, x, y);
    } else {
      ctx.lineTo(point.x, point.y);
    }
  });
  strokeWithOptions(ctx, {
    lineWidth: lineWidth,
    strokeStyle: strokeStyle
  });
  ctx.closePath();
  setLineDash(ctx, []);
}
function lineSeries_areaPoints(ctx, areaPointsModel) {
  var fillColor = areaPointsModel.fillColor;
  ctx.beginPath();
  lineSeries_linePoints(ctx, areaPointsModel);
  style_fillStyle(ctx, fillColor);
  ctx.closePath();
}
// CONCATENATED MODULE: ./src/brushes/exportMenu.ts








function exportMenu_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function exportMenu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { exportMenu_ownKeys(Object(source), true).forEach(function (key) { brushes_exportMenu_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { exportMenu_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function brushes_exportMenu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




function drawXIcon(ctx, icon, rectSize) {
  var startX = icon.x,
      startY = icon.y,
      _icon$theme = icon.theme,
      strokeStyle = _icon$theme.color,
      lineWidth = _icon$theme.lineWidth;
  var offset = rectSize / 3;
  var x = startX + offset;
  var y = startY + offset;
  var x2 = startX + offset * 2;
  var y2 = startY + offset * 2;
  var points = [{
    x: x,
    y: y,
    x2: x2,
    y2: y2
  }, {
    x: x,
    y: y2,
    x2: x2,
    y2: y
  }];
  points.forEach(function (p) {
    basic_line(ctx, exportMenu_objectSpread(exportMenu_objectSpread({
      type: 'line'
    }, p), {}, {
      strokeStyle: strokeStyle,
      lineWidth: lineWidth
    }));
  });
}

function drawMoreIcon(ctx, icon, rectSize) {
  var x = icon.x,
      y = icon.y,
      _icon$theme2 = icon.theme,
      color = _icon$theme2.color,
      width = _icon$theme2.width,
      height = _icon$theme2.height,
      gap = _icon$theme2.gap;
  var paddingX = (rectSize - width) / 2;
  var paddingY = (rectSize - (height * 3 + gap * 2)) / 2;
  var centerX = x + paddingX;
  var points = [{
    x: centerX,
    y: y + paddingY
  }, {
    x: centerX,
    y: y + paddingY + height + gap
  }, {
    x: centerX,
    y: y + paddingY + (height + gap) * 2
  }];
  points.forEach(function (p) {
    basic_rect(ctx, exportMenu_objectSpread(exportMenu_objectSpread({
      type: 'rect'
    }, p), {}, {
      color: color,
      width: width,
      height: height
    }));
  });
}

function exportMenuButton(ctx, exportMenuButtonModel) {
  var opened = exportMenuButtonModel.opened,
      xPos = exportMenuButtonModel.x,
      yPos = exportMenuButtonModel.y,
      theme = exportMenuButtonModel.theme;
  var _ref = theme,
      borderColor = _ref.borderColor,
      backgroundColor = _ref.backgroundColor,
      borderWidth = _ref.borderWidth,
      borderRadius = _ref.borderRadius,
      xIcon = _ref.xIcon,
      dotIcon = _ref.dotIcon;
  var x = xPos + borderWidth;
  var y = yPos + borderWidth;
  var rectSize = BUTTON_RECT_SIZE - 2 * borderWidth;
  pathRect(ctx, {
    type: 'pathRect',
    x: x,
    y: y,
    fill: backgroundColor,
    stroke: borderColor,
    width: rectSize,
    height: rectSize,
    radius: borderRadius,
    lineWidth: borderWidth
  });

  if (opened) {
    drawXIcon(ctx, {
      x: x,
      y: y,
      theme: xIcon
    }, rectSize);
  } else {
    drawMoreIcon(ctx, {
      x: x,
      y: y,
      theme: dotIcon
    }, rectSize);
  }
}
// CONCATENATED MODULE: ./src/brushes/resetButton.ts



var ARROW_HEIGHT = 3;
var ARROW_WIDTH = 6;

function drawResetIcon(ctx, point) {
  var x = point.x,
      y = point.y;
  var centerX = x + BUTTON_RECT_SIZE / 2;
  var centerY = y + BUTTON_RECT_SIZE / 2;
  var tickSize = BUTTON_RECT_SIZE / 10;
  var color = '#545454';
  basic_circle(ctx, {
    type: 'circle',
    x: centerX,
    y: centerY,
    radius: tickSize * 2,
    angle: {
      start: 0,
      end: Math.PI / 2
    },
    color: 'transparent',
    style: [{
      lineWidth: 2,
      strokeStyle: color
    }]
  });
  var pointStartX = centerX + tickSize * 2;
  var pointStartY = centerY;
  var points = [{
    x: pointStartX - ARROW_WIDTH / 2,
    y: pointStartY
  }, {
    x: pointStartX + ARROW_WIDTH / 2,
    y: pointStartY
  }, {
    x: pointStartX,
    y: pointStartY + ARROW_HEIGHT
  }];
  lineSeries_areaPoints(ctx, {
    type: 'areaPoints',
    points: points,
    lineWidth: 1,
    color: color,
    fillColor: color
  });
}

function drawBackIcon(ctx, point) {
  var barWidth = 4;
  var radius = BUTTON_RECT_SIZE / 7;
  var x = point.x,
      y = point.y;
  var centerX = x + BUTTON_RECT_SIZE / 2;
  var centerY = y + BUTTON_RECT_SIZE / 2;
  var color = '#545454';
  basic_line(ctx, {
    type: 'line',
    lineWidth: 2,
    x: centerX - barWidth / 2,
    y: centerY + radius,
    x2: centerX + barWidth / 2,
    y2: centerY + radius,
    strokeStyle: color
  });
  basic_line(ctx, {
    type: 'line',
    lineWidth: 2,
    x: centerX - barWidth / 2,
    y: centerY - radius,
    x2: centerX + barWidth / 2,
    y2: centerY - radius,
    strokeStyle: color
  });
  basic_circle(ctx, {
    type: 'circle',
    x: centerX + barWidth / 2,
    y: centerY,
    radius: radius,
    angle: {
      start: Math.PI / 2,
      end: Math.PI * 3 / 2
    },
    color: 'transparent',
    style: [{
      lineWidth: 2,
      strokeStyle: color
    }]
  });
  var pointStartX = centerX - barWidth / 2;
  var pointStartY = centerY - radius;
  var points = [{
    x: pointStartX - ARROW_HEIGHT,
    y: pointStartY
  }, {
    x: pointStartX,
    y: pointStartY - ARROW_WIDTH / 2
  }, {
    x: pointStartX,
    y: pointStartY + ARROW_WIDTH / 2
  }];
  lineSeries_areaPoints(ctx, {
    type: 'areaPoints',
    points: points,
    lineWidth: 1,
    color: color,
    fillColor: color
  });
}

function backButton(ctx, backButtonModel) {
  var x = backButtonModel.x,
      y = backButtonModel.y;
  pathRect(ctx, {
    type: 'pathRect',
    x: x,
    y: y,
    fill: '#f4f4f4',
    stroke: '#f4f4f4',
    width: BUTTON_RECT_SIZE,
    height: BUTTON_RECT_SIZE,
    radius: 5
  });
  drawBackIcon(ctx, {
    x: x,
    y: y
  });
}
function resetButton_resetButton(ctx, resetButtonModel) {
  var x = resetButtonModel.x,
      y = resetButtonModel.y;
  pathRect(ctx, {
    type: 'pathRect',
    x: x,
    y: y,
    fill: '#f4f4f4',
    stroke: '#f4f4f4',
    width: BUTTON_RECT_SIZE,
    height: BUTTON_RECT_SIZE,
    radius: 5
  });
  drawResetIcon(ctx, {
    x: x,
    y: y
  });
}
// CONCATENATED MODULE: ./src/charts/lineChart.ts



















function lineChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { lineChart_typeof = function _typeof(obj) { return typeof obj; }; } else { lineChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return lineChart_typeof(obj); }

function lineChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function lineChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { lineChart_ownKeys(Object(source), true).forEach(function (key) { lineChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { lineChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function lineChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lineChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function lineChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) lineChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) lineChart_defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = lineChart_getPrototypeOf(object); if (object === null) break; } return object; }

function lineChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) lineChart_setPrototypeOf(subClass, superClass); }

function lineChart_setPrototypeOf(o, p) { lineChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return lineChart_setPrototypeOf(o, p); }

function lineChart_createSuper(Derived) { var hasNativeReflectConstruct = lineChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = lineChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = lineChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return lineChart_possibleConstructorReturn(this, result); }; }

function lineChart_possibleConstructorReturn(self, call) { if (call && (lineChart_typeof(call) === "object" || typeof call === "function")) { return call; } return lineChart_assertThisInitialized(self); }

function lineChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function lineChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function lineChart_getPrototypeOf(o) { lineChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return lineChart_getPrototypeOf(o); }

function lineChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





























/**
 * @class
 * @classdesc Line Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Line Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<number|Object|Array>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Line Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.showDot=false] - Whether to show dot or not.
 *       @param {boolean} [props.options.series.spline=false] - Whether to make spline chart or not.
 *       @param {boolean} [props.options.series.zoomable=false] - Whether to use zoom feature or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'near', 'nearest', 'grouped', 'point' is available.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *       @param {Array<Object>} [props.options.plot.lines] - Plot lines information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Line Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var lineChart_LineChart = /*#__PURE__*/function (_Chart) {
  lineChart_inherits(LineChart, _Chart);

  var _super = lineChart_createSuper(LineChart);

  function LineChart(props) {
    var _props$data;

    var _this;

    lineChart_classCallCheck(this, LineChart);

    _this = _super.call(this, {
      el: props.el,
      options: props.options,
      series: {
        line: props.data.series
      },
      categories: (_props$data = props.data) === null || _props$data === void 0 ? void 0 : _props$data.categories,
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });

    lineChart_defineProperty(lineChart_assertThisInitialized(_this), "addData", function (data, category) {
      var _this$store$state$opt;

      if ((_this$store$state$opt = _this.store.state.options.series) === null || _this$store$state$opt === void 0 ? void 0 : _this$store$state$opt.showDot) {
        _this.animationControlFlag.updating = true;
      }

      _this.resetSeries();

      _this.store.dispatch('addData', {
        data: data,
        category: category
      });
    });

    lineChart_defineProperty(lineChart_assertThisInitialized(_this), "hideSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    });

    lineChart_defineProperty(lineChart_assertThisInitialized(_this), "showSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    });

    lineChart_defineProperty(lineChart_assertThisInitialized(_this), "setOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('initOptions', options);
    });

    lineChart_defineProperty(lineChart_assertThisInitialized(_this), "updateOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', options);
    });

    lineChart_defineProperty(lineChart_assertThisInitialized(_this), "showTooltip", function (seriesInfo) {
      _this.eventBus.emit('showTooltip', lineChart_objectSpread({}, seriesInfo));
    });

    lineChart_defineProperty(lineChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  lineChart_createClass(LineChart, [{
    key: "initialize",
    value: function initialize() {
      _get(lineChart_getPrototypeOf(LineChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(title_Title);
      this.componentManager.add(plot_Plot);
      this.componentManager.add(legend_Legend);
      this.componentManager.add(lineSeries_LineSeries);
      this.componentManager.add(axis_Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(dataLabels_DataLabels);
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(exportMenu_ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(hoveredSeries_HoveredSeries);
      this.componentManager.add(selectedSeries_SelectedSeries);
      this.componentManager.add(tooltip_Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(zoom_Zoom);
      this.componentManager.add(resetButton_ResetButton);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_resetButton_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<number|Object|Array>} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addSeries",

    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number|Object|Array>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          line: series
        },
        categories: categories
      });
    }
    /**
     * Add plot line.
     * @param {Object} data - Plot info.
     *    @param {string|number} data.value - The value where the plot line will be drawn.
     *    @param {string} data.color - Plot line color.
     *    @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
     * @api
     * @example
     * chart.addPlotLine({
     *   value: 2,
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotLine",
    value: function addPlotLine(data) {
      this.store.dispatch('addPlotLine', {
        data: data
      });
    }
    /**
     * Remove plot line with id.
     * @param {string} id - Id of the plot line to be removed.
     * @api
     * @example
     * chart.removePlotLine('plot-1');
     */

  }, {
    key: "removePlotLine",
    value: function removePlotLine(id) {
      this.store.dispatch('removePlotLine', {
        id: id
      });
    }
    /**
     * Add plot band.
     * @param {Object} data - Plot info.
     *   @param {Array<string|number>} data.range - The range to be drawn.
     *   @param {string} data.color - Plot band color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
     * @api
     * @example
     * chart.addPlotBand({
     *   value: [2, 4],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotBand",
    value: function addPlotBand(data) {
      this.store.dispatch('addPlotBand', {
        data: data
      });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - id of the plot band to be removed
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */

  }, {
    key: "removePlotBand",
    value: function removePlotBand(id) {
      this.store.dispatch('removePlotBand', {
        id: id
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }]);

  return LineChart;
}(chart_Chart);


// CONCATENATED MODULE: ./src/component/pieSeries.ts




























function pieSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { pieSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { pieSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return pieSeries_typeof(obj); }

function pieSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function pieSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { pieSeries_ownKeys(Object(source), true).forEach(function (key) { pieSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { pieSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function pieSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function pieSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function pieSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) pieSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) pieSeries_defineProperties(Constructor, staticProps); return Constructor; }

function pieSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) pieSeries_setPrototypeOf(subClass, superClass); }

function pieSeries_setPrototypeOf(o, p) { pieSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return pieSeries_setPrototypeOf(o, p); }

function pieSeries_createSuper(Derived) { var hasNativeReflectConstruct = pieSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = pieSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = pieSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return pieSeries_possibleConstructorReturn(this, result); }; }

function pieSeries_possibleConstructorReturn(self, call) { if (call && (pieSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return pieSeries_assertThisInitialized(self); }

function pieSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function pieSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function pieSeries_getPrototypeOf(o) { pieSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return pieSeries_getPrototypeOf(o); }

function pieSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













function getCalculatedRadiusRange(_ref) {
  var alias = _ref.alias,
      renderOptions = _ref.renderOptions,
      radiusRangeMap = _ref.radiusRangeMap,
      pieIndex = _ref.pieIndex,
      radiusRanges = _ref.radiusRanges,
      totalPieAliasCount = _ref.totalPieAliasCount;
  var radiusRangeLength = Object.keys(radiusRangeMap).length;
  var _renderOptions$defaul = renderOptions.defaultRadius,
      defaultRadius = _renderOptions$defaul === void 0 ? 0 : _renderOptions$defaul;
  var _renderOptions$radius = renderOptions.radiusRange,
      inner = _renderOptions$radius.inner,
      outer = _renderOptions$radius.outer;

  if (!radiusRangeMap[alias]) {
    if (!radiusRangeLength) {
      var radius = defaultRadius / totalPieAliasCount;
      inner = pieIndex * radius;
      outer = (pieIndex + 1) * radius;
    } else {
      var _radiusRanges;

      if (pieIndex && radiusRanges[pieIndex - 1].outer) {
        inner = radiusRanges[pieIndex - 1].outer;
      }

      if ((_radiusRanges = radiusRanges[pieIndex + 1]) === null || _radiusRanges === void 0 ? void 0 : _radiusRanges.inner) {
        outer = radiusRanges[pieIndex + 1].inner;
      } else if (pieIndex === totalPieAliasCount - 1) {
        outer = defaultRadius;
      } else {
        var _radiusRanges$outer, _radiusRanges2, _radiusRanges$inner, _radiusRanges3;

        var _radius = (defaultRadius - ((_radiusRanges$outer = (_radiusRanges2 = radiusRanges[pieIndex - 1]) === null || _radiusRanges2 === void 0 ? void 0 : _radiusRanges2.outer) !== null && _radiusRanges$outer !== void 0 ? _radiusRanges$outer : 0) - ((_radiusRanges$inner = (_radiusRanges3 = radiusRanges[pieIndex + 1]) === null || _radiusRanges3 === void 0 ? void 0 : _radiusRanges3.inner) !== null && _radiusRanges$inner !== void 0 ? _radiusRanges$inner : 0)) / (totalPieAliasCount - radiusRangeLength);

        outer = inner + _radius;
      }
    }
  }

  return {
    inner: inner,
    outer: outer
  };
}

function getPieSeriesOpacityByDepth(originAlpha, depth, indexOfGroup) {
  var brightness = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.85;
  var depthAlpha = Number((originAlpha * Math.pow(brightness, depth)).toFixed(2));
  return Number(Math.pow(depthAlpha, indexOfGroup + 1).toFixed(2));
}

function getMaxDataLabelSize(seriesNameLabels, options, dataLabelTheme) {
  var _options$pieSeriesNam, _options$pieSeriesNam2;

  var outerLabels = [{
    hasOuterLabel: options.visible && options.anchor === 'outer',
    labels: ['00.00%'],
    // up to 5 digits
    theme: dataLabelTheme
  }, {
    hasOuterLabel: ((_options$pieSeriesNam = options.pieSeriesName) === null || _options$pieSeriesNam === void 0 ? void 0 : _options$pieSeriesNam.visible) && ((_options$pieSeriesNam2 = options.pieSeriesName) === null || _options$pieSeriesNam2 === void 0 ? void 0 : _options$pieSeriesNam2.anchor) === 'outer',
    labels: seriesNameLabels,
    theme: dataLabelTheme.pieSeriesName
  }];
  return outerLabels.reduce(function (acc, cur) {
    var width = acc.width,
        height = acc.height;
    var hasOuterLabel = cur.hasOuterLabel,
        labels = cur.labels,
        theme = cur.theme;

    if (hasOuterLabel) {
      var _getMaxLabelSize = getMaxLabelSize(labels, 0, getFont(theme)),
          maxLabelWidth = _getMaxLabelSize.maxLabelWidth,
          maxLabelHeight = _getMaxLabelSize.maxLabelHeight;

      return {
        width: Math.max(maxLabelWidth + RADIUS_PADDING, width),
        height: Math.max(maxLabelHeight + RADIUS_PADDING, height)
      };
    }

    return acc;
  }, {
    width: 0,
    height: 0
  });
}

var pieSeries_PieSeries = /*#__PURE__*/function (_Component) {
  pieSeries_inherits(PieSeries, _Component);

  var _super = pieSeries_createSuper(PieSeries);

  function PieSeries() {
    var _this;

    pieSeries_classCallCheck(this, PieSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "models", {
      series: []
    });

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "drawModels", void 0);

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "responders", void 0);

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "activatedResponders", []);

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "alias", void 0);

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "theme", void 0);

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.alias || _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.alias || _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "selectSeries", function (_ref2) {
      var seriesIndex = _ref2.seriesIndex,
          name = _ref2.name;

      if (!isNumber(seriesIndex) || !isUndefined(name) && name !== _this.alias) {
        return;
      }

      var model = _this.responders[seriesIndex];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getResponderModelsWithTheme([model], 'select'),
        name: _this.name,
        alias: _this.alias
      });

      _this.eventBus.emit('needDraw');
    });

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "showTooltip", function (_ref3) {
      var seriesIndex = _ref3.seriesIndex,
          name = _ref3.name;

      if (!isNumber(seriesIndex) || !isUndefined(name) && name !== _this.alias) {
        return;
      }

      var models = [_this.responders[seriesIndex]];

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: _this.getResponderModelsWithTheme(models, 'hover'),
        name: _this.name,
        alias: _this.alias
      });

      _this.activatedResponders = _this.makeTooltipResponder(models);

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.alias || _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  pieSeries_createClass(PieSeries, [{
    key: "initUpdate",
    value: function initUpdate(delta) {
      if (!this.drawModels) {
        return;
      }

      var currentDegree;
      var index = this.models.series.findIndex(function (_ref4) {
        var clockwise = _ref4.clockwise,
            _ref4$degree = _ref4.degree,
            start = _ref4$degree.start,
            end = _ref4$degree.end,
            totalAngle = _ref4.totalAngle;
        currentDegree = clockwise ? totalAngle * delta : 360 - totalAngle * delta;
        return withinRadian(clockwise, start, end, currentDegree);
      });
      this.syncEndAngle(index < 0 ? this.models.series.length : index);

      if (~index) {
        this.drawModels.series[index].degree.end = currentDegree;
      }
    }
  }, {
    key: "syncEndAngle",
    value: function syncEndAngle(index) {
      if (index < 1) {
        return;
      }

      for (var i = 0; i < index; i += 1) {
        var prevTargetEndDegree = this.models.series[i].degree.end;

        if (this.drawModels.series[i].degree.end !== prevTargetEndDegree) {
          this.drawModels.series[i].degree.end = prevTargetEndDegree;
        }
      }
    }
  }, {
    key: "initialize",
    value: function initialize(param) {
      var _param$alias;

      this.type = 'series';
      this.name = 'pie';
      this.alias = (_param$alias = param === null || param === void 0 ? void 0 : param.alias) !== null && _param$alias !== void 0 ? _param$alias : '';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var _ref5,
          _this2 = this;

      var layout = chartState.layout,
          series = chartState.series,
          legend = chartState.legend,
          options = chartState.options,
          nestedPieSeries = chartState.nestedPieSeries,
          theme = chartState.theme;
      var categories = (_ref5 = chartState.categories) !== null && _ref5 !== void 0 ? _ref5 : [];

      if (!series.pie) {
        throw new Error(message.noDataError(this.name));
      }

      var pieTheme = theme.series.pie;
      this.theme = this.alias ? pieTheme[this.alias] : pieTheme;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var seriesModel, tooltipDataModel;
      var dataLabelsOptions = getDataLabelsOptions(options, this.alias);

      if (nestedPieSeries) {
        var data = nestedPieSeries[this.alias].data;
        var pieAlias = Object.keys(nestedPieSeries);
        var pieIndex = pieAlias.findIndex(function (alias) {
          return alias === _this2.alias;
        }); // check the data label of the last Pie series

        var lastAlias = last(pieAlias);
        var lastSeries = nestedPieSeries[lastAlias];
        var maxPieDataLabelSize = getMaxDataLabelSize(lastSeries.data.map(function (_ref6) {
          var name = _ref6.name;
          return name;
        }), getDataLabelsOptions(options, lastAlias), this.theme.dataLabels);
        var renderOptionsMap = this.getRenderOptionsMap(options, pieAlias, maxPieDataLabelSize);
        seriesModel = this.renderPieModel(data, renderOptionsMap[this.alias], pieIndex);
        tooltipDataModel = makePieTooltipData(data, categories === null || categories === void 0 ? void 0 : categories[pieIndex]);
      } else {
        var _series$pie;

        var pieData = (_series$pie = series.pie) === null || _series$pie === void 0 ? void 0 : _series$pie.data;

        var _getMaxDataLabelSize = getMaxDataLabelSize(pieData.map(function (_ref7) {
          var name = _ref7.name;
          return name;
        }), dataLabelsOptions, this.theme.dataLabels),
            width = _getMaxDataLabelSize.width,
            height = _getMaxDataLabelSize.height;

        var renderOptions = this.makeRenderOptions(options, width, height);
        seriesModel = this.renderPieModel(pieData, renderOptions);
        tooltipDataModel = makePieTooltipData(pieData, categories === null || categories === void 0 ? void 0 : categories[0]);
      }

      this.models.series = seriesModel;

      if (!this.drawModels) {
        this.drawModels = {
          series: this.models.series.map(function (m) {
            return pieSeries_objectSpread(pieSeries_objectSpread({}, m), {}, {
              degree: pieSeries_objectSpread(pieSeries_objectSpread({}, m.degree), {}, {
                end: m.degree.start
              })
            });
          })
        };
      }

      if (dataLabelsOptions.visible) {
        var dataLabelData = seriesModel.map(function (m) {
          return pieSeries_objectSpread(pieSeries_objectSpread({}, m), {}, {
            value: "".concat(pieTooltipLabelFormatter(m.percentValue)),
            theme: _this2.theme.dataLabels
          });
        });
        this.renderDataLabels(dataLabelData, this.alias);
      }

      this.responders = seriesModel.map(function (m, index) {
        return pieSeries_objectSpread(pieSeries_objectSpread({}, m), {}, {
          type: 'sector',
          radius: m.radius,
          seriesIndex: index,
          data: pieSeries_objectSpread(pieSeries_objectSpread({}, tooltipDataModel[index]), {}, {
            percentValue: m.percentValue
          }),
          color: getRGBA(m.color, 1)
        });
      });
    }
  }, {
    key: "getRadiusRangeMap",
    value: function getRadiusRangeMap(options, pieAlias) {
      var _this3 = this;

      return pieAlias.reduce(function (acc, alias) {
        var seriesOptions = _this3.getOptions(options, alias).series;

        if (seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.radiusRange) {
          acc[alias] = seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.radiusRange;
        }

        return acc;
      }, {});
    }
  }, {
    key: "getRenderOptionsMap",
    value: function getRenderOptionsMap(options, pieAlias, maxPieDataLabelSize) {
      var renderOptionsMap = this.initRenderOptionsMap(options, pieAlias, maxPieDataLabelSize);
      var radiusRangeMap = this.getRadiusRangeMap(options, pieAlias);
      pieAlias.forEach(function (alias, pieIndex) {
        var radiusRanges = Object.values(renderOptionsMap).map(function (_ref8) {
          var radiusRange = _ref8.radiusRange;
          return radiusRange;
        });
        renderOptionsMap[alias].radiusRange = getCalculatedRadiusRange({
          alias: alias,
          renderOptions: renderOptionsMap[alias],
          radiusRangeMap: radiusRangeMap,
          pieIndex: pieIndex,
          radiusRanges: radiusRanges,
          totalPieAliasCount: pieAlias.length
        });
      });
      return renderOptionsMap;
    }
  }, {
    key: "initRenderOptionsMap",
    value: function initRenderOptionsMap(options, pieAlias, _ref9) {
      var _this4 = this;

      var width = _ref9.width,
          height = _ref9.height;
      return pieAlias.reduce(function (acc, alias) {
        return pieSeries_objectSpread(pieSeries_objectSpread({}, acc), {}, pieSeries_defineProperty({}, alias, _this4.makeRenderOptions(_this4.getOptions(options, alias), width, height)));
      }, {});
    }
  }, {
    key: "getOptions",
    value: function getOptions(chartOptions, alias) {
      var options = pieSeries_objectSpread({}, chartOptions);

      if ((options === null || options === void 0 ? void 0 : options.series) && alias) {
        options.series = pieSeries_objectSpread(pieSeries_objectSpread({}, options.series), options.series[alias]);
      }

      return options;
    }
  }, {
    key: "makeRenderOptions",
    value: function makeRenderOptions(options) {
      var _seriesOptions$clockw, _seriesOptions$angleR, _seriesOptions$angleR2, _seriesOptions$angleR3, _seriesOptions$angleR4, _seriesOptions$radius, _seriesOptions$radius2, _seriesOptions$radius3, _seriesOptions$radius4;

      var maxDataLabelWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var maxDataLabelHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var seriesOptions = options.series;
      var clockwise = (_seriesOptions$clockw = seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.clockwise) !== null && _seriesOptions$clockw !== void 0 ? _seriesOptions$clockw : true;
      var startAngle = (_seriesOptions$angleR = seriesOptions === null || seriesOptions === void 0 ? void 0 : (_seriesOptions$angleR2 = seriesOptions.angleRange) === null || _seriesOptions$angleR2 === void 0 ? void 0 : _seriesOptions$angleR2.start) !== null && _seriesOptions$angleR !== void 0 ? _seriesOptions$angleR : 0;
      var endAngle = (_seriesOptions$angleR3 = seriesOptions === null || seriesOptions === void 0 ? void 0 : (_seriesOptions$angleR4 = seriesOptions.angleRange) === null || _seriesOptions$angleR4 === void 0 ? void 0 : _seriesOptions$angleR4.end) !== null && _seriesOptions$angleR3 !== void 0 ? _seriesOptions$angleR3 : 360;
      var totalAngle = getTotalAngle(clockwise, startAngle, endAngle);
      var isSemiCircular = isSemiCircle(clockwise, startAngle, endAngle);
      var _this$rect = this.rect,
          width = _this$rect.width,
          height = _this$rect.height;
      var defaultRadius = getDefaultRadius(this.rect, isSemiCircular, maxDataLabelWidth, maxDataLabelHeight);
      var innerRadius = calculateSizeWithPercentString(defaultRadius, (_seriesOptions$radius = seriesOptions === null || seriesOptions === void 0 ? void 0 : (_seriesOptions$radius2 = seriesOptions.radiusRange) === null || _seriesOptions$radius2 === void 0 ? void 0 : _seriesOptions$radius2.inner) !== null && _seriesOptions$radius !== void 0 ? _seriesOptions$radius : 0);
      var outerRadius = calculateSizeWithPercentString(defaultRadius, (_seriesOptions$radius3 = seriesOptions === null || seriesOptions === void 0 ? void 0 : (_seriesOptions$radius4 = seriesOptions.radiusRange) === null || _seriesOptions$radius4 === void 0 ? void 0 : _seriesOptions$radius4.outer) !== null && _seriesOptions$radius3 !== void 0 ? _seriesOptions$radius3 : this.alias ? 0 : defaultRadius);
      var cx = width / 2;
      var cy = isSemiCircular ? getSemiCircleCenterY(this.rect.height, clockwise) : height / 2;
      return {
        clockwise: clockwise,
        cx: cx,
        cy: cy,
        drawingStartAngle: startAngle - 90,
        radiusRange: {
          inner: innerRadius,
          outer: outerRadius
        },
        angleRange: {
          start: startAngle,
          end: endAngle
        },
        totalAngle: totalAngle,
        defaultRadius: defaultRadius
      };
    }
  }, {
    key: "renderPieModel",
    value: function renderPieModel(seriesRawData, renderOptions, pieIndex) {
      var _this5 = this;

      var sectorModels = [];
      var total = seriesRawData.reduce(function (sum, _ref10) {
        var data = _ref10.data;
        return sum + (data !== null && data !== void 0 ? data : 0);
      }, 0);
      var clockwise = renderOptions.clockwise,
          cx = renderOptions.cx,
          cy = renderOptions.cy,
          drawingStartAngle = renderOptions.drawingStartAngle,
          _renderOptions$radius2 = renderOptions.radiusRange,
          inner = _renderOptions$radius2.inner,
          outer = _renderOptions$radius2.outer,
          totalAngle = renderOptions.totalAngle;
      var defaultStartDegree = clockwise ? 0 : 360;
      var _this$theme = this.theme,
          lineWidth = _this$theme.lineWidth,
          strokeStyle = _this$theme.strokeStyle;
      seriesRawData.forEach(function (rawData, seriesIndex) {
        var color = _this5.alias ? _this5.getAliasSeriesColor(rawData, seriesRawData, pieIndex) : _this5.getSeriesColor(rawData);
        var data = rawData.data,
            name = rawData.name;

        if (!isNull(data)) {
          var degree = Math.max(data / total * totalAngle, 1) * (clockwise ? 1 : -1);
          var percentValue = data / total * 100;
          var prevModel = sectorModels[sectorModels.length - 1];
          var startDegree = seriesIndex && prevModel ? prevModel.degree.end : defaultStartDegree;
          var endDegree = clockwise ? Math.min(startDegree + degree, 360) : Math.max(startDegree + degree, 0);
          sectorModels.push({
            type: 'sector',
            name: name,
            color: color,
            x: cx,
            y: cy,
            degree: {
              start: startDegree,
              end: endDegree
            },
            radius: {
              inner: inner,
              outer: outer
            },
            value: data,
            style: [{
              lineWidth: lineWidth,
              strokeStyle: strokeStyle
            }],
            clockwise: clockwise,
            drawingStartAngle: drawingStartAngle,
            totalAngle: totalAngle,
            percentValue: percentValue
          });
        }
      });
      return sectorModels;
    }
  }, {
    key: "makeTooltipResponder",
    value: function makeTooltipResponder(responders) {
      var _this6 = this;

      return responders.map(function (responder) {
        return pieSeries_objectSpread(pieSeries_objectSpread({}, responder), getRadialAnchorPosition(makeAnchorPositionParam('center', _this6.models.series[responder.seriesIndex])));
      });
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref11) {
      var responders = _ref11.responders;
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getResponderModelsWithTheme(responders, 'hover'),
        name: this.alias || this.name
      });
      this.activatedResponders = this.makeTooltipResponder(responders);
      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.alias || this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref12) {
      var responders = _ref12.responders;

      if (this.selectable) {
        this.eventBus.emit('renderSelectedSeries', {
          models: this.getResponderModelsWithTheme(responders, 'select'),
          name: this.name,
          alias: this.alias
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "getResponderModelsWithTheme",
    value: function getResponderModelsWithTheme(responders, type) {
      var theme = this.theme[type];
      var lineWidth = theme.lineWidth;
      var isSameLineWidth = this.theme.lineWidth === lineWidth;
      var thickness = isSameLineWidth ? 0 : lineWidth * 0.5;
      return responders.map(function (m) {
        var _theme$color;

        return pieSeries_objectSpread(pieSeries_objectSpread({}, m), {}, {
          color: (_theme$color = theme === null || theme === void 0 ? void 0 : theme.color) !== null && _theme$color !== void 0 ? _theme$color : m.color,
          style: [pick(theme, 'lineWidth', 'strokeStyle', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY')],
          radius: {
            inner: Math.max(m.radius.inner - thickness, 0),
            outer: m.radius.outer + thickness
          }
        });
      });
    }
  }, {
    key: "getOpacity",
    value: function getOpacity(active, selectedState) {
      var _this$theme2 = this.theme,
          select = _this$theme2.select,
          areaOpacity = _this$theme2.areaOpacity;
      var _ref13 = select,
          selectedAreaOpacity = _ref13.areaOpacity,
          restAreaOpacity = _ref13.restSeries.areaOpacity;
      var selectThemeOpacity = active ? selectedAreaOpacity : restAreaOpacity;
      return selectedState ? selectThemeOpacity : areaOpacity;
    }
  }, {
    key: "getIndexOfGroup",
    value: function getIndexOfGroup(seriesRawData, parentName, name) {
      return seriesRawData.filter(function (datum) {
        return parentName === datum.parentName;
      }).findIndex(function (datum) {
        return name === datum.name;
      });
    }
  }, {
    key: "getSeriesColor",
    value: function getSeriesColor(rawData) {
      var color = rawData.color,
          name = rawData.name;
      var active = this.activeSeriesMap[name];
      var opacity = this.getOpacity(active, this.hasActiveSeries());
      return getRGBA(color, opacity);
    }
  }, {
    key: "getAliasSeriesColor",
    value: function getAliasSeriesColor(rawData, seriesRawData, pieIndex) {
      var color = rawData.color,
          name = rawData.name;
      var selectedColor = this.theme.select.color;
      var rootParentName = rawData.rootParentName,
          parentName = rawData.parentName;
      var indexOfGroup = this.getIndexOfGroup(seriesRawData, parentName, name);
      var opacity = this.getAliasSeriesOpacity(rootParentName, parentName, pieIndex, indexOfGroup, name);
      var active = this.activeSeriesMap[rootParentName !== null && rootParentName !== void 0 ? rootParentName : name];
      var seriesColor = active ? selectedColor !== null && selectedColor !== void 0 ? selectedColor : color : color;
      return getRGBA(seriesColor, opacity);
    }
  }, {
    key: "getAliasSeriesOpacity",
    value: function getAliasSeriesOpacity(rootParentName, parentName, pieIndex, indexOfGroup, name) {
      var active = this.activeSeriesMap[rootParentName !== null && rootParentName !== void 0 ? rootParentName : name];
      var opacity = this.getOpacity(active, this.hasActiveSeries());
      return pieIndex && parentName ? getPieSeriesOpacityByDepth(opacity, pieIndex, indexOfGroup) : opacity;
    }
  }, {
    key: "hasActiveSeries",
    value: function hasActiveSeries() {
      return Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
    }
  }]);

  return PieSeries;
}(component_Component);


// CONCATENATED MODULE: ./src/brushes/sector.ts





function sector_sector(ctx, sectorModel) {
  var _sectorModel$degree = sectorModel.degree,
      start = _sectorModel$degree.start,
      end = _sectorModel$degree.end,
      color = sectorModel.color,
      style = sectorModel.style;

  if (start === end) {
    return;
  }

  var isCircle = Math.abs(start - end) === 360;
  ctx.beginPath();

  if (style) {
    var styleObj = makeStyleObj(style, {});
    Object.keys(styleObj).forEach(function (key) {
      ctx[key] = styleObj[key];
    });
  }

  if (isCircle) {
    drawCircle(ctx, sectorModel);
  } else {
    drawSector(ctx, sectorModel);
  }

  ctx.closePath();
  style_fillStyle(ctx, color);
  ctx.stroke();
}

function drawSector(ctx, sectorModel) {
  var x = sectorModel.x,
      y = sectorModel.y,
      _sectorModel$radius = sectorModel.radius,
      inner = _sectorModel$radius.inner,
      outer = _sectorModel$radius.outer,
      _sectorModel$degree2 = sectorModel.degree,
      start = _sectorModel$degree2.start,
      end = _sectorModel$degree2.end,
      clockwise = sectorModel.clockwise,
      drawingStartAngle = sectorModel.drawingStartAngle;

  if (inner <= 0 && outer <= 0) {
    return;
  }

  var startRadian = calculateDegreeToRadian(start, drawingStartAngle);
  var endRadian = calculateDegreeToRadian(end, drawingStartAngle);

  if (!inner) {
    ctx.moveTo(x, y);
  }

  ctx.arc(x, y, outer, startRadian, endRadian, !clockwise);

  if (inner) {
    ctx.arc(x, y, inner, endRadian, startRadian, clockwise);
  }
}

function drawCircle(ctx, sectorModel) {
  var x = sectorModel.x,
      y = sectorModel.y,
      _sectorModel$radius2 = sectorModel.radius,
      inner = _sectorModel$radius2.inner,
      outer = _sectorModel$radius2.outer,
      clockwise = sectorModel.clockwise;
  ctx.arc(x, y, outer, 0, 2 * Math.PI, !clockwise);

  if (inner) {
    var _getRadialPosition = getRadialPosition(x, y, inner, 0),
        innerStartPosX = _getRadialPosition.x,
        innerStartPosY = _getRadialPosition.y;

    var startX = inner ? innerStartPosX : x;
    var startY = inner ? innerStartPosY : y;
    ctx.moveTo(startX, startY);
    ctx.arc(x, y, inner, 0, 2 * Math.PI, clockwise);
  }
}
// CONCATENATED MODULE: ./src/charts/pieChart.ts



















function pieChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { pieChart_typeof = function _typeof(obj) { return typeof obj; }; } else { pieChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return pieChart_typeof(obj); }

function pieChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function pieChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { pieChart_ownKeys(Object(source), true).forEach(function (key) { pieChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { pieChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function pieChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function pieChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function pieChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) pieChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) pieChart_defineProperties(Constructor, staticProps); return Constructor; }

function pieChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { pieChart_get = Reflect.get; } else { pieChart_get = function _get(target, property, receiver) { var base = pieChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return pieChart_get(target, property, receiver || target); }

function pieChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = pieChart_getPrototypeOf(object); if (object === null) break; } return object; }

function pieChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) pieChart_setPrototypeOf(subClass, superClass); }

function pieChart_setPrototypeOf(o, p) { pieChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return pieChart_setPrototypeOf(o, p); }

function pieChart_createSuper(Derived) { var hasNativeReflectConstruct = pieChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = pieChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = pieChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return pieChart_possibleConstructorReturn(this, result); }; }

function pieChart_possibleConstructorReturn(self, call) { if (call && (pieChart_typeof(call) === "object" || typeof call === "function")) { return call; } return pieChart_assertThisInitialized(self); }

function pieChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function pieChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function pieChart_getPrototypeOf(o) { pieChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return pieChart_getPrototypeOf(o); }

function pieChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


















/**
 * @class
 * @classdesc Pie Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Pie Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Pie Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {Array<number>|Array<string>} [props.options.series.radiusRange] - Specifies the radius of the circle drawn. It is specified by entering a number or percent string value in start and end.
 *       @param {Array<number>} [props.options.series.angleRange] - The range of angles to which the circle will be drawn. It is specified by putting number in start and end.
 *       @param {boolean} [props.options.series.clockwise] - Whether it will be drawn clockwise.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Pie Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var pieChart_PieChart = /*#__PURE__*/function (_Chart) {
  pieChart_inherits(PieChart, _Chart);

  var _super = pieChart_createSuper(PieChart);

  function PieChart(_ref) {
    var _this;

    var el = _ref.el,
        _options = _ref.options,
        data = _ref.data;

    pieChart_classCallCheck(this, PieChart);

    _this = _super.call(this, {
      el: el,
      options: _options,
      series: {
        pie: data.series
      },
      categories: data.categories
    });

    pieChart_defineProperty(pieChart_assertThisInitialized(_this), "hideSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    });

    pieChart_defineProperty(pieChart_assertThisInitialized(_this), "showSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    });

    pieChart_defineProperty(pieChart_assertThisInitialized(_this), "setOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('initOptions', options);
    });

    pieChart_defineProperty(pieChart_assertThisInitialized(_this), "updateOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', options);
    });

    pieChart_defineProperty(pieChart_assertThisInitialized(_this), "showTooltip", function (seriesInfo) {
      _this.eventBus.emit('showTooltip', pieChart_objectSpread(pieChart_objectSpread({}, seriesInfo), {}, {
        state: _this.store.state
      }));
    });

    pieChart_defineProperty(pieChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  pieChart_createClass(PieChart, [{
    key: "initialize",
    value: function initialize() {
      pieChart_get(pieChart_getPrototypeOf(PieChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(title_Title);
      this.componentManager.add(legend_Legend);
      this.componentManager.add(pieSeries_PieSeries);
      this.componentManager.add(exportMenu_ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(hoveredSeries_HoveredSeries);
      this.componentManager.add(selectedSeries_SelectedSeries);
      this.componentManager.add(dataLabels_DataLabels);
      this.componentManager.add(tooltip_Tooltip, {
        chartEl: this.el
      });
      this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, brushes_sector_namespaceObject, dataLabel_namespaceObject]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: 10,
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['A'],
     *   series: [
     *     {name: 'a', data: 10},
     *     {name: 'b', data: 20},
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          pie: series
        },
        categories: categories
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }]);

  return PieChart;
}(chart_Chart);


// CONCATENATED MODULE: ./src/store/heatmapAxes.ts









function heatmapAxes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function heatmapAxes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { heatmapAxes_ownKeys(Object(source), true).forEach(function (key) { heatmapAxes_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { heatmapAxes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function heatmapAxes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






function getHeatmapAxisData(stateProp, axisType) {
  var _options$axisType$lab, _options$axisType, _options$axisType$lab2, _options$axisType2, _options$axisType$tic, _options$axisType3, _options$axisType3$ti, _options$axisType$lab3, _options$axisType4, _options$axisType4$la, _options$xAxis;

  var categories = stateProp.categories,
      axisSize = stateProp.axisSize,
      options = stateProp.options,
      theme = stateProp.theme;
  var isLabelAxis = axisType === AxisType.X;
  var axisName = isLabelAxis ? 'x' : 'y';
  var formatter = (_options$axisType$lab = (_options$axisType = options[axisType]) === null || _options$axisType === void 0 ? void 0 : (_options$axisType$lab2 = _options$axisType.label) === null || _options$axisType$lab2 === void 0 ? void 0 : _options$axisType$lab2.formatter) !== null && _options$axisType$lab !== void 0 ? _options$axisType$lab : function (value) {
    return value;
  };
  var labelsBeforeFormatting = makeFormattedCategory(categories[axisName], (_options$axisType2 = options[axisType]) === null || _options$axisType2 === void 0 ? void 0 : _options$axisType2.date);
  var labels = labelsBeforeFormatting.map(function (label, index) {
    return formatter(label, {
      index: index,
      labels: labelsBeforeFormatting,
      axisName: axisType
    });
  });
  var tickIntervalCount = labels.length;
  var tickDistance = tickIntervalCount ? axisSize / tickIntervalCount : axisSize;
  var labelDistance = axisSize / tickIntervalCount;
  var pointOnColumn = true;
  var tickCount = tickIntervalCount + 1;
  var tickInterval = (_options$axisType$tic = (_options$axisType3 = options[axisType]) === null || _options$axisType3 === void 0 ? void 0 : (_options$axisType3$ti = _options$axisType3.tick) === null || _options$axisType3$ti === void 0 ? void 0 : _options$axisType3$ti.interval) !== null && _options$axisType$tic !== void 0 ? _options$axisType$tic : 1;
  var labelInterval = (_options$axisType$lab3 = (_options$axisType4 = options[axisType]) === null || _options$axisType4 === void 0 ? void 0 : (_options$axisType4$la = _options$axisType4.label) === null || _options$axisType4$la === void 0 ? void 0 : _options$axisType4$la.interval) !== null && _options$axisType$lab3 !== void 0 ? _options$axisType$lab3 : 1;
  var viewLabels = getViewAxisLabels({
    labels: labels,
    pointOnColumn: pointOnColumn,
    tickDistance: tickDistance,
    tickCount: tickCount,
    tickInterval: tickInterval,
    labelInterval: labelInterval
  }, axisSize);
  var labelXMargin = getLabelXMargin(axisType, options);

  var _getMaxLabelSize = getMaxLabelSize(labels, labelXMargin, getTitleFontString(theme.label)),
      maxLabelWidth = _getMaxLabelSize.maxLabelWidth,
      maxLabelHeight = _getMaxLabelSize.maxLabelHeight;

  var axisData = {
    labels: labels,
    viewLabels: viewLabels,
    pointOnColumn: pointOnColumn,
    isLabelAxis: isLabelAxis,
    tickCount: tickCount,
    tickDistance: tickDistance,
    labelDistance: labelDistance,
    tickInterval: tickInterval,
    labelInterval: labelInterval,
    title: makeTitleOption((_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : _options$xAxis.title),
    maxLabelWidth: maxLabelWidth,
    maxLabelHeight: maxLabelHeight
  };

  if (axisType === AxisType.X) {
    var _options$xAxis$label$, _options$xAxis2, _options$xAxis2$label;

    var labelMargin = (_options$xAxis$label$ = (_options$xAxis2 = options.xAxis) === null || _options$xAxis2 === void 0 ? void 0 : (_options$xAxis2$label = _options$xAxis2.label) === null || _options$xAxis2$label === void 0 ? void 0 : _options$xAxis2$label.margin) !== null && _options$xAxis$label$ !== void 0 ? _options$xAxis$label$ : 0;
    var offsetY = getAxisLabelAnchorPoint(maxLabelHeight) + labelMargin;
    var distance = axisSize / viewLabels.length;
    var rotationData = makeRotationData(maxLabelWidth, maxLabelHeight, distance, getRotatableOption(options));
    var needRotateLabel = rotationData.needRotateLabel,
        rotationHeight = rotationData.rotationHeight;
    var maxHeight = (needRotateLabel ? rotationHeight : maxLabelHeight) + offsetY;
    return heatmapAxes_objectSpread(heatmapAxes_objectSpread(heatmapAxes_objectSpread({}, axisData), rotationData), {}, {
      maxHeight: maxHeight,
      offsetY: offsetY
    });
  }

  return axisData;
}

var heatmapAxes_axes = {
  name: 'axes',
  state: function state() {
    return {
      axes: {
        xAxis: {},
        yAxis: {}
      }
    };
  },
  action: {
    setAxesData: function setAxesData(_ref) {
      var state = _ref.state;
      var layout = state.layout,
          theme = state.theme;
      var _layout$plot = layout.plot,
          width = _layout$plot.width,
          height = _layout$plot.height;
      var categories = state.categories;
      var options = state.options;
      var xAxisData = getHeatmapAxisData({
        axisSize: width,
        categories: categories,
        options: options,
        theme: getAxisTheme(theme, AxisType.X)
      }, AxisType.X);
      var yAxisData = getHeatmapAxisData({
        axisSize: height,
        categories: categories,
        options: options,
        theme: getAxisTheme(theme, AxisType.X)
      }, AxisType.Y);
      var axesState = {
        xAxis: xAxisData,
        yAxis: yAxisData
      };

      if (hasAxesLayoutChanged(state.axes, axesState)) {
        this.notify(state, 'layout');
      }

      state.axes = axesState;
    }
  },
  computed: {},
  observe: {
    updateAxes: function updateAxes() {
      this.dispatch('setAxesData');
    }
  }
};
/* harmony default export */ var heatmapAxes = (heatmapAxes_axes);
// CONCATENATED MODULE: ./src/store/heatmapSeriesData.ts



function makeHeatmapSeries(series, categories, viewRange) {
  if (!series.heatmap) {
    return [];
  }

  return series.heatmap.data.map(function (rowSeries, y) {
    var yCategory = rowSeries.yCategory,
        data = rowSeries.data;
    return getDataInRange(data, viewRange).map(function (colorValue, x) {
      return {
        colorValue: colorValue,
        category: {
          x: categories.x[x],
          y: yCategory
        },
        indexes: [x, y]
      };
    });
  });
}

var heatmapSeriesData = {
  name: 'heatmapSeriesData',
  state: function state() {
    return {
      heatmapSeries: []
    };
  },
  action: {
    setHeatmapSeriesData: function setHeatmapSeriesData(_ref) {
      var state = _ref.state,
          computed = _ref.computed;
      state.heatmapSeries = makeHeatmapSeries(state.series, state.categories, computed.viewRange);
    }
  },
  observe: {
    updateTreemapSeriesData: function updateTreemapSeriesData() {
      this.dispatch('setHeatmapSeriesData');
    }
  }
};
/* harmony default export */ var store_heatmapSeriesData = (heatmapSeriesData);
// CONCATENATED MODULE: ./src/store/treemapSeriesData.ts





















function treemapSeriesData_toConsumableArray(arr) { return treemapSeriesData_arrayWithoutHoles(arr) || treemapSeriesData_iterableToArray(arr) || treemapSeriesData_unsupportedIterableToArray(arr) || treemapSeriesData_nonIterableSpread(); }

function treemapSeriesData_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function treemapSeriesData_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return treemapSeriesData_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return treemapSeriesData_arrayLikeToArray(o, minLen); }

function treemapSeriesData_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function treemapSeriesData_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return treemapSeriesData_arrayLikeToArray(arr); }

function treemapSeriesData_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


var TREEMAP_ID_PREFIX = '__TOAST_UI_TREEMAP';
var TREEMAP_ROOT_ID = "".concat(TREEMAP_ID_PREFIX, "_ROOT");

function makeTreeModel(series, indexes, depth, parentId) {
  var _series$data;

  var idx = last(indexes);
  var id = parentId ? "".concat(parentId, "_").concat(idx) : "".concat(TREEMAP_ID_PREFIX, "_").concat(idx);
  var colorValue = series.colorValue;
  var models = [{
    label: series.label,
    hasChild: !!series.children,
    id: id,
    indexes: indexes,
    parentId: parentId ? parentId : TREEMAP_ROOT_ID,
    depth: depth,
    data: (_series$data = series.data) !== null && _series$data !== void 0 ? _series$data : 0,
    colorValue: colorValue
  }];

  if (series.children) {
    series.children.forEach(function (child, childIdx) {
      if (!isNull(child.data)) {
        models.push.apply(models, treemapSeriesData_toConsumableArray(makeTreeModel(child, [].concat(treemapSeriesData_toConsumableArray(indexes), [childIdx]), depth + 1, id)));
      }
    });
  }

  return models;
}

function setParentSeriesData(treemapSeries) {
  treemapSeries.forEach(function (_ref) {
    var parentId = _ref.parentId,
        data = _ref.data;

    if (parentId !== TREEMAP_ROOT_ID) {
      treemapSeries.find(function (_ref2) {
        var id = _ref2.id;
        return id === parentId;
      }).data += data;
    }
  });
}

function setParentColorValue(treemapSeries) {
  treemapSeries.forEach(function (datum) {
    var id = datum.id,
        colorValue = datum.colorValue;

    if (isUndefined(colorValue)) {
      var series = treemapSeries.filter(function (_ref3) {
        var parentId = _ref3.parentId;
        return parentId === id;
      });
      var totalColorValue = series.reduce(function (acc, cur) {
        return acc + (isUndefined(cur.colorValue) ? 0 : cur.colorValue);
      }, 0);
      datum.colorValue = totalColorValue / series.length;
    }
  });
}

function setRatio(treemapSeries) {
  var rootTotal = treemapSeries.filter(function (_ref4) {
    var parentId = _ref4.parentId;
    return parentId === TREEMAP_ROOT_ID;
  }).reduce(function (acc, _ref5) {
    var data = _ref5.data;
    return acc + data;
  }, 0);
  treemapSeries.forEach(function (series) {
    var total = series.parentId === TREEMAP_ROOT_ID ? rootTotal : treemapSeries.find(function (_ref6) {
      var id = _ref6.id;
      return id === series.parentId;
    }).data;
    series.ratio = series.data / total;
  });
}

function makeTreemapSeries(series, options) {
  var _options$series;

  if (!series.treemap) {
    return [];
  }

  var treemapSeries = series.treemap.data.filter(function (datum) {
    return !isNull(datum.data);
  }).map(function (datum, idx) {
    return makeTreeModel(datum, [idx], 0);
  }).flatMap(function (s) {
    return s;
  }).sort(function (a, b) {
    return b.depth - a.depth;
  });
  setParentSeriesData(treemapSeries);
  setRatio(treemapSeries);

  if ((_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.useColorValue) {
    setParentColorValue(treemapSeries);
  }

  return treemapSeries;
}

var treemapSeriesData = {
  name: 'treemapSeriesData',
  state: function state() {
    return {
      treemapSeries: []
    };
  },
  action: {
    setTreemapSeriesData: function setTreemapSeriesData(_ref7) {
      var state = _ref7.state;
      state.treemapSeries = makeTreemapSeries(state.series, state.options);
    }
  },
  observe: {
    updateTreemapSeriesData: function updateTreemapSeriesData() {
      this.dispatch('setTreemapSeriesData');
    }
  }
};
/* harmony default export */ var store_treemapSeriesData = (treemapSeriesData);
// CONCATENATED MODULE: ./src/store/colorValueScale.ts


















function colorValueScale_toConsumableArray(arr) { return colorValueScale_arrayWithoutHoles(arr) || colorValueScale_iterableToArray(arr) || colorValueScale_unsupportedIterableToArray(arr) || colorValueScale_nonIterableSpread(); }

function colorValueScale_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function colorValueScale_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return colorValueScale_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return colorValueScale_arrayLikeToArray(o, minLen); }

function colorValueScale_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function colorValueScale_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return colorValueScale_arrayLikeToArray(arr); }

function colorValueScale_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }






var colorValueScale_colorValueScale = {
  name: 'colorValueScale',
  state: function state() {
    return {
      treemapZoomId: {
        prev: TREEMAP_ROOT_ID,
        cur: TREEMAP_ROOT_ID
      },
      colorValueScale: {}
    };
  },
  action: {
    setColorValueScale: function setColorValueScale(_ref) {
      var state = _ref.state;
      var layout = state.layout,
          treemapSeries = state.treemapSeries,
          legend = state.legend,
          heatmapSeries = state.heatmapSeries;

      if (!legend.useSpectrumLegend) {
        return;
      }

      var series = treemapSeries !== null && treemapSeries !== void 0 ? treemapSeries : heatmapSeries.flatMap(function (value) {
        return value;
      });
      var values = series.reduce(function (acc, _ref2) {
        var colorValue = _ref2.colorValue;
        return colorValue ? [].concat(colorValueScale_toConsumableArray(acc), [colorValue]) : acc;
      }, []);
      var dataRange = getLimitSafely(colorValueScale_toConsumableArray(new Set(values)));
      var offsetSize = isVerticalAlign(legend.align) ? layout.plot.width / 2 : layout.plot.height;
      store_extend(state.colorValueScale, calculateCoordinateScale({
        dataRange: dataRange,
        offsetSize: offsetSize,
        useSpectrumLegend: true,
        scaleOption: {}
      }));
    },
    setTreemapZoomId: function setTreemapZoomId(_ref3, id) {
      var state = _ref3.state;
      state.treemapZoomId.prev = state.treemapZoomId.cur;
      state.treemapZoomId.cur = id;
    },
    zoomBack: function zoomBack(_ref4) {
      var _prevSeries$parentId;

      var state = _ref4.state;
      var treemapSeries = state.treemapSeries,
          treemapZoomId = state.treemapZoomId;
      var prev = treemapZoomId.prev;
      var prevSeries = treemapSeries.find(function (_ref5) {
        var id = _ref5.id;
        return id === prev;
      });
      state.treemapZoomId.prev = (_prevSeries$parentId = prevSeries === null || prevSeries === void 0 ? void 0 : prevSeries.parentId) !== null && _prevSeries$parentId !== void 0 ? _prevSeries$parentId : TREEMAP_ROOT_ID;
      state.treemapZoomId.cur = prev;
    }
  },
  observe: {
    updateColorValueScale: function updateColorValueScale() {
      this.dispatch('setColorValueScale');
    }
  },
  computed: {
    isTreemapSeriesZooming: function isTreemapSeriesZooming(_ref6) {
      var treemapZoomId = _ref6.treemapZoomId;
      return treemapZoomId && treemapZoomId.cur !== treemapZoomId.prev;
    }
  }
};
/* harmony default export */ var store_colorValueScale = (colorValueScale_colorValueScale);
// CONCATENATED MODULE: ./src/component/spectrumLegend.ts

















function spectrumLegend_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { spectrumLegend_typeof = function _typeof(obj) { return typeof obj; }; } else { spectrumLegend_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return spectrumLegend_typeof(obj); }

function spectrumLegend_toConsumableArray(arr) { return spectrumLegend_arrayWithoutHoles(arr) || spectrumLegend_iterableToArray(arr) || spectrumLegend_unsupportedIterableToArray(arr) || spectrumLegend_nonIterableSpread(); }

function spectrumLegend_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function spectrumLegend_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function spectrumLegend_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return spectrumLegend_arrayLikeToArray(arr); }

function spectrumLegend_slicedToArray(arr, i) { return spectrumLegend_arrayWithHoles(arr) || spectrumLegend_iterableToArrayLimit(arr, i) || spectrumLegend_unsupportedIterableToArray(arr, i) || spectrumLegend_nonIterableRest(); }

function spectrumLegend_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function spectrumLegend_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return spectrumLegend_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return spectrumLegend_arrayLikeToArray(o, minLen); }

function spectrumLegend_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function spectrumLegend_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function spectrumLegend_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function spectrumLegend_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function spectrumLegend_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function spectrumLegend_createClass(Constructor, protoProps, staticProps) { if (protoProps) spectrumLegend_defineProperties(Constructor.prototype, protoProps); if (staticProps) spectrumLegend_defineProperties(Constructor, staticProps); return Constructor; }

function spectrumLegend_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) spectrumLegend_setPrototypeOf(subClass, superClass); }

function spectrumLegend_setPrototypeOf(o, p) { spectrumLegend_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return spectrumLegend_setPrototypeOf(o, p); }

function spectrumLegend_createSuper(Derived) { var hasNativeReflectConstruct = spectrumLegend_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = spectrumLegend_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = spectrumLegend_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return spectrumLegend_possibleConstructorReturn(this, result); }; }

function spectrumLegend_possibleConstructorReturn(self, call) { if (call && (spectrumLegend_typeof(call) === "object" || typeof call === "function")) { return call; } return spectrumLegend_assertThisInitialized(self); }

function spectrumLegend_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function spectrumLegend_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function spectrumLegend_getPrototypeOf(o) { spectrumLegend_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return spectrumLegend_getPrototypeOf(o); }

function component_spectrumLegend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var spectrumLegend_SpectrumLegend = /*#__PURE__*/function (_Component) {
  spectrumLegend_inherits(SpectrumLegend, _Component);

  var _super = spectrumLegend_createSuper(SpectrumLegend);

  function SpectrumLegend() {
    var _this;

    spectrumLegend_classCallCheck(this, SpectrumLegend);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    component_spectrumLegend_defineProperty(spectrumLegend_assertThisInitialized(_this), "models", void 0);

    component_spectrumLegend_defineProperty(spectrumLegend_assertThisInitialized(_this), "labels", []);

    component_spectrumLegend_defineProperty(spectrumLegend_assertThisInitialized(_this), "align", void 0);

    component_spectrumLegend_defineProperty(spectrumLegend_assertThisInitialized(_this), "renderSpectrumTooltip", function (_ref) {
      var _ref2 = spectrumLegend_slicedToArray(_ref, 1),
          responderData = _ref2[0];

      if (responderData) {
        var _assertThisInitialize = spectrumLegend_assertThisInitialized(_this),
            labels = _assertThisInitialize.labels,
            align = _assertThisInitialize.align;

        var colorValue = responderData.colorValue,
            color = responderData.color;
        var _this$rect = _this.rect,
            width = _this$rect.width,
            height = _this$rect.height;
        _this.models.tooltip = [{
          type: 'spectrumTooltip',
          width: width,
          height: height,
          x: 0,
          y: 0,
          labels: labels,
          align: align,
          colorRatio: responderData.colorRatio,
          color: color,
          text: String(colorValue),
          verticalAlign: isVerticalAlign(align)
        }];
      } else {
        _this.models.tooltip = [];
      }
    });

    return _this;
  }

  spectrumLegend_createClass(SpectrumLegend, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'spectrumLegend';
      this.name = 'spectrumLegend';
    }
  }, {
    key: "makeLabels",
    value: function makeLabels(scale) {
      var stepCount = scale.stepCount,
          limit = scale.limit,
          stepSize = scale.stepSize;
      var minValue = limit.min;
      return utils_range(0, stepCount + 1).reduce(function (labels, value) {
        return [].concat(spectrumLegend_toConsumableArray(labels), [String(minValue + stepSize * value)]);
      }, []);
    }
  }, {
    key: "renderSpectrumLegendModel",
    value: function renderSpectrumLegendModel(startColor, endColor) {
      var labels = this.labels,
          align = this.align;
      var _this$rect2 = this.rect,
          width = _this$rect2.width,
          height = _this$rect2.height;
      return [{
        type: 'spectrumLegend',
        width: width,
        height: height,
        x: 0,
        y: 0,
        labels: labels,
        align: align,
        startColor: startColor,
        endColor: endColor,
        verticalAlign: isVerticalAlign(this.align)
      }];
    }
  }, {
    key: "render",
    value: function render(_ref3) {
      var _theme$series, _theme$series2;

      var layout = _ref3.layout,
          legend = _ref3.legend,
          colorValueScale = _ref3.colorValueScale,
          theme = _ref3.theme;
      this.rect = layout.legend;
      this.align = legend.align;
      this.isShow = legend.visible;

      if (!this.isShow) {
        return;
      }

      this.labels = this.makeLabels(colorValueScale);

      var _ref4 = ((_theme$series = theme.series) === null || _theme$series === void 0 ? void 0 : _theme$series.heatmap) || ((_theme$series2 = theme.series) === null || _theme$series2 === void 0 ? void 0 : _theme$series2.treemap),
          startColor = _ref4.startColor,
          endColor = _ref4.endColor;

      this.models = {
        legend: this.renderSpectrumLegendModel(startColor, endColor),
        tooltip: []
      };
      this.eventBus.on('renderSpectrumTooltip', this.renderSpectrumTooltip);
    }
  }]);

  return SpectrumLegend;
}(component_Component);


// CONCATENATED MODULE: ./src/helpers/colorSpectrum.ts













function colorSpectrum_toConsumableArray(arr) { return colorSpectrum_arrayWithoutHoles(arr) || colorSpectrum_iterableToArray(arr) || colorSpectrum_unsupportedIterableToArray(arr) || colorSpectrum_nonIterableSpread(); }

function colorSpectrum_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function colorSpectrum_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return colorSpectrum_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return colorSpectrum_arrayLikeToArray(o, minLen); }

function colorSpectrum_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function colorSpectrum_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return colorSpectrum_arrayLikeToArray(arr); }

function colorSpectrum_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



function makeDistances(startRGB, endRGB) {
  return startRGB.map(function (value, index) {
    return endRGB[index] - value;
  });
}
function getColorRatio(limit, value) {
  if (isUndefined(value)) {
    return;
  }

  var divNumber = Math.abs(limit.max - limit.min);
  return divNumber && !isNull(value) ? (value - limit.min) / divNumber : 0;
}
function getSpectrumColor(ratio, distances, startRGB) {
  var rgbColor = startRGB.map(function (start, index) {
    return start + parseInt(String(distances[index] * ratio), 10);
  });
  var color = rgbToHEX.apply(void 0, colorSpectrum_toConsumableArray(rgbColor));
  return isString(color) ? color : '';
}
// CONCATENATED MODULE: ./src/component/heatmapSeries.ts


























function heatmapSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { heatmapSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { heatmapSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return heatmapSeries_typeof(obj); }

function heatmapSeries_slicedToArray(arr, i) { return heatmapSeries_arrayWithHoles(arr) || heatmapSeries_iterableToArrayLimit(arr, i) || heatmapSeries_unsupportedIterableToArray(arr, i) || heatmapSeries_nonIterableRest(); }

function heatmapSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function heatmapSeries_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function heatmapSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function heatmapSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function heatmapSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { heatmapSeries_ownKeys(Object(source), true).forEach(function (key) { heatmapSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { heatmapSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function heatmapSeries_toConsumableArray(arr) { return heatmapSeries_arrayWithoutHoles(arr) || heatmapSeries_iterableToArray(arr) || heatmapSeries_unsupportedIterableToArray(arr) || heatmapSeries_nonIterableSpread(); }

function heatmapSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function heatmapSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return heatmapSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return heatmapSeries_arrayLikeToArray(o, minLen); }

function heatmapSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function heatmapSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return heatmapSeries_arrayLikeToArray(arr); }

function heatmapSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function heatmapSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function heatmapSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function heatmapSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) heatmapSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) heatmapSeries_defineProperties(Constructor, staticProps); return Constructor; }

function heatmapSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) heatmapSeries_setPrototypeOf(subClass, superClass); }

function heatmapSeries_setPrototypeOf(o, p) { heatmapSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return heatmapSeries_setPrototypeOf(o, p); }

function heatmapSeries_createSuper(Derived) { var hasNativeReflectConstruct = heatmapSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = heatmapSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = heatmapSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return heatmapSeries_possibleConstructorReturn(this, result); }; }

function heatmapSeries_possibleConstructorReturn(self, call) { if (call && (heatmapSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return heatmapSeries_assertThisInitialized(self); }

function heatmapSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function heatmapSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function heatmapSeries_getPrototypeOf(o) { heatmapSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return heatmapSeries_getPrototypeOf(o); }

function heatmapSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var heatmapSeries_HeatmapSeries = /*#__PURE__*/function (_Component) {
  heatmapSeries_inherits(HeatmapSeries, _Component);

  var _super = heatmapSeries_createSuper(HeatmapSeries);

  function HeatmapSeries() {
    var _this;

    heatmapSeries_classCallCheck(this, HeatmapSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "models", void 0);

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "responders", void 0);

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "theme", void 0);

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "activatedResponders", []);

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.emitMouseEvent([]);
    });

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var _state$series$heatmap;

      var index = _ref.index,
          seriesIndex = _ref.seriesIndex,
          state = _ref.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var dataSize = (_state$series$heatmap = state.series.heatmap) === null || _state$series$heatmap === void 0 ? void 0 : _state$series$heatmap[0].data.length;
      var responderIndex = seriesIndex * dataSize + index;
      var model = _this.responders[responderIndex];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: _this.getRespondersWithTheme([model], 'select'),
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "showTooltip", function (_ref2) {
      var _state$series$heatmap2;

      var index = _ref2.index,
          seriesIndex = _ref2.seriesIndex,
          state = _ref2.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var dataSize = (_state$series$heatmap2 = state.series.heatmap) === null || _state$series$heatmap2 === void 0 ? void 0 : _state$series$heatmap2[0].data.length;
      var responderIndex = seriesIndex * dataSize + index;
      var model = _this.responders[responderIndex];

      if (model) {
        _this.emitMouseEvent([model]);
      }
    });

    return _this;
  }

  heatmapSeries_createClass(HeatmapSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'heatmap';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var layout = chartState.layout,
          heatmapSeries = chartState.heatmapSeries,
          axes = chartState.axes,
          theme = chartState.theme,
          colorValueScale = chartState.colorValueScale,
          options = chartState.options;

      if (!heatmapSeries.length) {
        throw new Error(message.noDataError(this.name));
      }

      this.theme = theme.series.heatmap;
      this.selectable = this.getSelectableOption(options);
      this.rect = layout.plot;
      var cellSize = {
        height: axes.yAxis.tickDistance,
        width: axes.xAxis.tickDistance
      };
      this.models = {
        series: this.renderHeatmapSeries(heatmapSeries, cellSize, colorValueScale)
      };

      if (getDataLabelsOptions(options, this.name).visible) {
        this.renderDataLabels(this.makeDataLabels());
      }

      this.responders = this.makeHeatmapSeriesResponder();
    }
  }, {
    key: "makeDataLabels",
    value: function makeDataLabels() {
      var dataLabelTheme = this.theme.dataLabels;
      return this.models.series.reduce(function (acc, m) {
        return isNull(m.colorValue) ? acc : [].concat(heatmapSeries_toConsumableArray(acc), [heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, m), {}, {
          type: 'treemapSeriesName',
          value: m.colorValue,
          direction: 'left',
          plot: {
            x: 0,
            y: 0,
            size: 0
          },
          theme: heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, dataLabelTheme), {}, {
            color: dataLabelTheme.useSeriesColor ? m.color : dataLabelTheme.color
          })
        })]);
      }, []);
    }
  }, {
    key: "makeHeatmapSeriesResponder",
    value: function makeHeatmapSeriesResponder() {
      return this.models.series.reduce(function (acc, model) {
        return isNull(model.colorValue) ? acc : [].concat(heatmapSeries_toConsumableArray(acc), [heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, model), {}, {
          data: heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, model), {}, {
            label: model.name,
            value: model.colorValue,
            templateType: 'heatmap'
          }),
          thickness: boxDefault.HOVER_THICKNESS,
          style: ['shadow']
        })]);
      }, []);
    }
  }, {
    key: "renderHeatmapSeries",
    value: function renderHeatmapSeries(seriesData, cellSize, colorValueScale) {
      var _this$theme = this.theme,
          startColor = _this$theme.startColor,
          endColor = _this$theme.endColor,
          borderColor = _this$theme.borderColor,
          borderWidth = _this$theme.borderWidth;
      var startRGB = hexToRGB(startColor);
      var distances = makeDistances(startRGB, hexToRGB(endColor));
      var height = cellSize.height,
          width = cellSize.width;
      return seriesData.flatMap(function (data) {
        return data.flatMap(function (datum) {
          var indexes = datum.indexes,
              colorValue = datum.colorValue,
              category = datum.category;
          var name = "".concat(category.x, ", ").concat(category.y);

          var _indexes = heatmapSeries_slicedToArray(indexes, 2),
              xIndex = _indexes[0],
              yIndex = _indexes[1];

          var colorRatio = getColorRatio(colorValueScale.limit, colorValue);
          var color = isNull(colorValue) ? 'rgba(0, 0, 0, 0)' : getSpectrumColor(colorRatio, distances, startRGB);
          var thickness = borderWidth;
          return {
            type: 'rect',
            name: name,
            width: width - thickness * 2,
            height: height - thickness * 2,
            x: width * xIndex + thickness,
            y: height * yIndex + thickness,
            colorValue: colorValue,
            colorRatio: colorRatio,
            color: color,
            thickness: thickness,
            borderColor: borderColor
          };
        });
      });
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _this2 = this;

      return responders.map(function (responder) {
        return deepMergedCopy(responder, heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, _this2.theme[type]), {}, {
          style: ['shadow']
        }));
      });
    }
  }, {
    key: "onClick",
    value: function onClick(_ref3) {
      var responders = _ref3.responders;

      if (this.selectable) {
        this.eventBus.emit('renderSelectedSeries', {
          models: this.getRespondersWithTheme(responders, 'select'),
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref4) {
      var responders = _ref4.responders;
      this.activatedResponders = responders;
      this.emitMouseEvent(responders);
    }
  }, {
    key: "emitMouseEvent",
    value: function emitMouseEvent(responders) {
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getRespondersWithTheme(responders, 'hover'),
        name: this.name
      });
      this.eventBus.emit('seriesPointHovered', {
        models: responders,
        name: this.name
      });
      this.eventBus.emit('renderSpectrumTooltip', responders);
      this.eventBus.emit('needDraw');
    }
  }]);

  return HeatmapSeries;
}(component_Component);


// CONCATENATED MODULE: ./src/charts/heatmapChart.ts




















function heatmapChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { heatmapChart_typeof = function _typeof(obj) { return typeof obj; }; } else { heatmapChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return heatmapChart_typeof(obj); }

function heatmapChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function heatmapChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { heatmapChart_ownKeys(Object(source), true).forEach(function (key) { heatmapChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { heatmapChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function heatmapChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function heatmapChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function heatmapChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) heatmapChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) heatmapChart_defineProperties(Constructor, staticProps); return Constructor; }

function heatmapChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { heatmapChart_get = Reflect.get; } else { heatmapChart_get = function _get(target, property, receiver) { var base = heatmapChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return heatmapChart_get(target, property, receiver || target); }

function heatmapChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = heatmapChart_getPrototypeOf(object); if (object === null) break; } return object; }

function heatmapChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) heatmapChart_setPrototypeOf(subClass, superClass); }

function heatmapChart_setPrototypeOf(o, p) { heatmapChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return heatmapChart_setPrototypeOf(o, p); }

function heatmapChart_createSuper(Derived) { var hasNativeReflectConstruct = heatmapChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = heatmapChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = heatmapChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return heatmapChart_possibleConstructorReturn(this, result); }; }

function heatmapChart_possibleConstructorReturn(self, call) { if (call && (heatmapChart_typeof(call) === "object" || typeof call === "function")) { return call; } return heatmapChart_assertThisInitialized(self); }

function heatmapChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function heatmapChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function heatmapChart_getPrototypeOf(o) { heatmapChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return heatmapChart_getPrototypeOf(o); }

function heatmapChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
























function getSeriesWithYCategory(series, categories) {
  return series.map(function (rowSeries, y) {
    return {
      data: rowSeries,
      yCategory: categories.y[y]
    };
  }).reverse();
}
/**
 * @class
 * @classdesc Heatmap Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Heatmap Chart.
 *     @param {Object} props.data.categories
 *       @param {Array<string>} props.data.categories.x - X Categories.
 *       @param {Array<string>} props.data.categories.y - Y Categories.
 *     @param {Array<Array<number>>} props.data.series - Series data.
 *   @param {Object} [props.options] - Options for making Heatmap Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {Object} [props.options.yAxis.title] - Axis title.
 *       @param {boolean|Object} [props.options.yAxis.date] - Whether the y axis label is of date type. Format option used for date type. Whether the y axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Heatmap Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */


var heatmapChart_HeatmapChart = /*#__PURE__*/function (_Chart) {
  heatmapChart_inherits(HeatmapChart, _Chart);

  var _super = heatmapChart_createSuper(HeatmapChart);

  function HeatmapChart(props) {
    var _this;

    heatmapChart_classCallCheck(this, HeatmapChart);

    _this = _super.call(this, {
      el: props.el,
      categories: props.data.categories,
      options: props.options,
      series: {
        heatmap: getSeriesWithYCategory(props.data.series, props.data.categories)
      },
      modules: [store_heatmapSeriesData, store_colorValueScale, heatmapAxes]
    });

    heatmapChart_defineProperty(heatmapChart_assertThisInitialized(_this), "addData", function (data, category) {
      _this.animationControlFlag.updating = true;

      _this.resetSeries();

      _this.store.dispatch('addData', {
        data: data,
        category: category
      });
    });

    heatmapChart_defineProperty(heatmapChart_assertThisInitialized(_this), "addSeries", function (data, dataInfo) {
      _this.resetSeries();

      _this.store.dispatch('addHeatmapSeries', heatmapChart_objectSpread({
        data: data
      }, dataInfo));
    });

    heatmapChart_defineProperty(heatmapChart_assertThisInitialized(_this), "hideSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    });

    heatmapChart_defineProperty(heatmapChart_assertThisInitialized(_this), "showSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    });

    heatmapChart_defineProperty(heatmapChart_assertThisInitialized(_this), "setOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('initOptions', options);
    });

    heatmapChart_defineProperty(heatmapChart_assertThisInitialized(_this), "updateOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', options);
    });

    heatmapChart_defineProperty(heatmapChart_assertThisInitialized(_this), "showTooltip", function (seriesInfo) {
      _this.eventBus.emit('showTooltip', heatmapChart_objectSpread(heatmapChart_objectSpread({}, seriesInfo), {}, {
        state: _this.store.state
      }));
    });

    heatmapChart_defineProperty(heatmapChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  heatmapChart_createClass(HeatmapChart, [{
    key: "initialize",
    value: function initialize() {
      heatmapChart_get(heatmapChart_getPrototypeOf(HeatmapChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(title_Title);
      this.componentManager.add(spectrumLegend_SpectrumLegend);
      this.componentManager.add(exportMenu_ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(heatmapSeries_HeatmapSeries);
      this.componentManager.add(axis_Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(hoveredSeries_HoveredSeries);
      this.componentManager.add(selectedSeries_SelectedSeries);
      this.componentManager.add(dataLabels_DataLabels);
      this.componentManager.add(tooltip_Tooltip, {
        chartEl: this.el
      });
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, spectrumLegend_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "setData",

    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     *   @param {Array<string>} data.categories.x - X Categories.
     *   @param {Array<string>} data.categories.y - Y Categories.
     * @param {Array<Array<number>>} data.series - Series data.
     * @api
     * @example
     * chart.setData({
     *   categories: {
     *     x: ['1', '2', '3' ],
     *     y: ['A', 'B'],
     *   },
     *   series: [
     *     [1, 2, 3],
     *     [4, 5, 6],
     *   ]
     * });
     */
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          heatmap: getSeriesWithYCategory(series, categories)
        },
        categories: categories
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }]);

  return HeatmapChart;
}(chart_Chart);


// CONCATENATED MODULE: ./src/component/areaSeries.ts





























function areaSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { areaSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { areaSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return areaSeries_typeof(obj); }

function areaSeries_toConsumableArray(arr) { return areaSeries_arrayWithoutHoles(arr) || areaSeries_iterableToArray(arr) || areaSeries_unsupportedIterableToArray(arr) || areaSeries_nonIterableSpread(); }

function areaSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function areaSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return areaSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return areaSeries_arrayLikeToArray(o, minLen); }

function areaSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function areaSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return areaSeries_arrayLikeToArray(arr); }

function areaSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function areaSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function areaSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { areaSeries_ownKeys(Object(source), true).forEach(function (key) { areaSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { areaSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function areaSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function areaSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function areaSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) areaSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) areaSeries_defineProperties(Constructor, staticProps); return Constructor; }

function areaSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) areaSeries_setPrototypeOf(subClass, superClass); }

function areaSeries_setPrototypeOf(o, p) { areaSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return areaSeries_setPrototypeOf(o, p); }

function areaSeries_createSuper(Derived) { var hasNativeReflectConstruct = areaSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = areaSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = areaSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return areaSeries_possibleConstructorReturn(this, result); }; }

function areaSeries_possibleConstructorReturn(self, call) { if (call && (areaSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return areaSeries_assertThisInitialized(self); }

function areaSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function areaSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function areaSeries_getPrototypeOf(o) { areaSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return areaSeries_getPrototypeOf(o); }

function areaSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












var seriesOpacity = {
  INACTIVE: 0.06,
  ACTIVE: 1
};

var areaSeries_AreaSeries = /*#__PURE__*/function (_Component) {
  areaSeries_inherits(AreaSeries, _Component);

  var _super = areaSeries_createSuper(AreaSeries);

  function AreaSeries() {
    var _this;

    areaSeries_classCallCheck(this, AreaSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "models", {
      rect: [],
      series: [],
      dot: []
    });

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "drawModels", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "theme", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "responders", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "activatedResponders", []);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "eventDetectType", 'nearest');

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "tooltipCircleMap", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "linePointsModel", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "baseYPosition", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "isStackChart", false);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "isRangeChart", false);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "isSplineChart", false);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "startIndex", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "selectSeries", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableSelectSeries(info, 'area')) {
        return;
      }

      var category = _this.getResponderCategoryByIndex(index);

      if (!category) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      var model = _this.tooltipCircleMap[category][seriesIndex];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: [model],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableShowTooltipInfo(info, _this.eventDetectType, 'area')) {
        return;
      }

      var category = _this.getResponderCategoryByIndex(index);

      if (!category) {
        return;
      }

      var models = _this.eventDetectType === 'grouped' ? _this.tooltipCircleMap[category] : [_this.tooltipCircleMap[category][seriesIndex]];

      if (!models.length) {
        return;
      }

      _this.onMousemoveNearType(models);

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  areaSeries_createClass(AreaSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'area';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      if (!this.drawModels) {
        return;
      }

      this.drawModels.rect[0].width = this.models.rect[0].width * delta;
    }
  }, {
    key: "getBaseYPosition",
    value: function getBaseYPosition(limit) {
      var baseValue = limit.min >= 0 ? limit.min : Math.min(limit.max, 0);
      var intervalSize = this.rect.height / (limit.max - limit.min);
      return (limit.max - baseValue) * intervalSize;
    }
  }, {
    key: "getStackValue",
    value: function getStackValue(areaStackSeries, seriesIndex, index) {
      var type = areaStackSeries.stack.type;
      var _areaStackSeries$stac = areaStackSeries.stackData[index],
          values = _areaStackSeries$stac.values,
          sumValue = _areaStackSeries$stac.sum;
      var stackedValue = sum(values.slice(0, seriesIndex + 1));
      return type === 'percent' ? stackedValue * 100 / sumValue : stackedValue;
    }
  }, {
    key: "setEventDetectType",
    value: function setEventDetectType(series, options) {
      var _options$series;

      if (options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }

      if (series.line || this.isStackChart) {
        this.eventDetectType = 'grouped';
      }
    }
  }, {
    key: "getAreaOptions",
    value: function getAreaOptions(options) {
      var _ref;

      var newOptions = areaSeries_objectSpread({}, options);

      if ((_ref = newOptions.series) === null || _ref === void 0 ? void 0 : _ref.area) {
        newOptions.series = areaSeries_objectSpread(areaSeries_objectSpread({}, newOptions.series), newOptions.series.area);
      }

      return newOptions;
    }
  }, {
    key: "render",
    value: function render(chartState, computed) {
      var _options$series$splin, _options$series2, _getFirstValidValue, _options$series3;

      var viewRange = computed.viewRange;
      var layout = chartState.layout,
          series = chartState.series,
          scale = chartState.scale,
          axes = chartState.axes,
          legend = chartState.legend,
          stackSeries = chartState.stackSeries,
          theme = chartState.theme,
          rawCategories = chartState.rawCategories;

      if (!series.area) {
        throw new Error(message.noDataError(this.name));
      }

      var areaStackSeries;
      var options = this.getAreaOptions(chartState.options);
      var categories = chartState.categories;
      this.theme = theme.series.area;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.startIndex = viewRange ? viewRange[0] : 0;
      this.selectable = this.getSelectableOption(options);
      this.isSplineChart = (_options$series$splin = (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : _options$series2.spline) !== null && _options$series$splin !== void 0 ? _options$series$splin : false;
      var limit = scale[getValueAxisName(options, this.name, 'yAxis')].limit;
      var _ref2 = axes.xAxis,
          tickDistance = _ref2.tickDistance,
          pointOnColumn = _ref2.pointOnColumn,
          tickCount = _ref2.tickCount;
      var areaData = series.area.data;
      this.baseYPosition = this.getBaseYPosition(limit);

      if (stackSeries === null || stackSeries === void 0 ? void 0 : stackSeries.area) {
        this.isStackChart = true;
        areaStackSeries = stackSeries.area;
      } else if (isRangeData((_getFirstValidValue = getFirstValidValue(areaData)) === null || _getFirstValidValue === void 0 ? void 0 : _getFirstValidValue.data)) {
        this.isRangeChart = true;
      }

      this.setEventDetectType(series, options);
      var renderOptions = {
        pointOnColumn: pointOnColumn,
        options: options.series || {},
        tickDistance: tickDistance,
        tickCount: tickCount,
        areaStackSeries: areaStackSeries
      };
      this.linePointsModel = this.renderLinePointsModel(areaData, limit, renderOptions);
      var areaSeriesModel = this.renderAreaPointsModel();
      var showDot = !!((_options$series3 = options.series) === null || _options$series3 === void 0 ? void 0 : _options$series3.showDot);

      var _this$renderCircleMod = this.renderCircleModel(showDot),
          dotSeriesModel = _this$renderCircleMod.dotSeriesModel,
          responderModel = _this$renderCircleMod.responderModel;

      var tooltipDataArr = this.makeTooltipData(areaData, rawCategories);
      this.models = deepCopy({
        rect: [this.renderClipRectAreaModel()],
        series: [].concat(areaSeries_toConsumableArray(this.linePointsModel), areaSeries_toConsumableArray(areaSeriesModel)),
        dot: dotSeriesModel
      });

      if (!this.drawModels) {
        this.drawModels = areaSeries_objectSpread(areaSeries_objectSpread({}, this.models), {}, {
          rect: [this.renderClipRectAreaModel(true)]
        });
      }

      if (getDataLabelsOptions(options, this.name).visible) {
        this.renderDataLabels(this.getDataLabels(areaSeriesModel));
      }

      this.tooltipCircleMap = makeTooltipCircleMap(responderModel, tooltipDataArr);
      this.responders = this.eventDetectType === 'near' ? this.makeNearTypeResponderModel(responderModel, tooltipDataArr) : responders_makeRectResponderModel(this.rect, axes.xAxis, categories);
    }
  }, {
    key: "makeNearTypeResponderModel",
    value: function makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr) {
      var tooltipDataLength = tooltipDataArr.length;
      return seriesCircleModel.map(function (m, dataIndex) {
        return areaSeries_objectSpread(areaSeries_objectSpread({}, m), {}, {
          data: tooltipDataArr[dataIndex % tooltipDataLength]
        });
      });
    }
  }, {
    key: "renderClipRectAreaModel",
    value: function renderClipRectAreaModel(isDrawModel) {
      return {
        type: 'clipRectArea',
        x: 0,
        y: 0,
        width: isDrawModel ? 0 : this.rect.width,
        height: this.rect.height
      };
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData(areaData, categories) {
      var _this2 = this;

      return areaData.flatMap(function (_ref3, seriesIndex) {
        var rawData = _ref3.rawData,
            name = _ref3.name,
            color = _ref3.color;
        var tooltipData = [];
        rawData.forEach(function (datum, index) {
          if (!isNull(datum)) {
            var value = _this2.isRangeChart ? "".concat(datum[0], " ~ ").concat(datum[1]) : datum;
            tooltipData.push({
              label: name,
              color: color,
              value: value,
              category: categories[index],
              seriesIndex: seriesIndex,
              index: index
            });
          }
        });
        return tooltipData;
      });
    }
  }, {
    key: "getLinePointModelValue",
    value: function getLinePointModelValue(datum, pairModel) {
      if (this.isRangeChart) {
        return pairModel ? datum[0] : datum[1];
      }

      return datum;
    }
  }, {
    key: "getLinePointModel",
    value: function getLinePointModel(series, seriesIndex, limit, renderOptions) {
      var _this3 = this;

      var pointOnColumn = renderOptions.pointOnColumn,
          tickDistance = renderOptions.tickDistance,
          pairModel = renderOptions.pairModel,
          areaStackSeries = renderOptions.areaStackSeries;
      var rawData = series.rawData,
          name = series.name,
          seriesColor = series.color;
      var active = this.activeSeriesMap[name];
      var points = [];
      var color = getRGBA(seriesColor, active ? seriesOpacity.ACTIVE : seriesOpacity.INACTIVE);
      var _this$theme = this.theme,
          lineWidth = _this$theme.lineWidth,
          dashSegments = _this$theme.dashSegments;
      rawData.forEach(function (datum, idx) {
        if (isNull(datum)) {
          points.push(null);
          return;
        }

        var value = _this3.getLinePointModelValue(datum, pairModel);

        var stackedValue = _this3.isStackChart ? _this3.getStackValue(areaStackSeries, seriesIndex, idx) : value;
        var valueRatio = getValueRatio(stackedValue, limit);
        var x = tickDistance * (idx - _this3.startIndex) + (pointOnColumn ? tickDistance / 2 : 0);
        var y = (1 - valueRatio) * _this3.rect.height;
        points.push({
          x: x,
          y: y,
          value: value
        });
      });

      if (pairModel) {
        points.reverse(); // for range spline
      }

      if (this.isSplineChart) {
        setSplineControlPoint(points);
      }

      return {
        type: 'linePoints',
        lineWidth: lineWidth,
        dashSegments: dashSegments,
        color: color,
        points: points,
        seriesIndex: seriesIndex,
        name: name
      };
    }
  }, {
    key: "renderLinePointsModel",
    value: function renderLinePointsModel(seriesRawData, limit, renderOptions) {
      var _this4 = this;

      var linePointsModels = seriesRawData.map(function (series, seriesIndex) {
        return _this4.getLinePointModel(series, seriesIndex, limit, renderOptions);
      });

      if (this.isRangeChart) {
        var renderOptionsForPair = deepMergedCopy(renderOptions, {
          pairModel: true
        });
        var pair = seriesRawData.map(function (series, seriesIndex) {
          return _this4.getLinePointModel(series, seriesIndex, limit, renderOptionsForPair);
        });
        linePointsModels.push.apply(linePointsModels, areaSeries_toConsumableArray(pair));
      }

      return linePointsModels;
    }
  }, {
    key: "getCombinedPoints",
    value: function getCombinedPoints(start, end) {
      var startPoints = start >= 0 ? this.linePointsModel[start].points : [];

      var reversedEndPoints = areaSeries_toConsumableArray(this.linePointsModel[end].points).reverse();

      return [].concat(areaSeries_toConsumableArray(startPoints), areaSeries_toConsumableArray(reversedEndPoints));
    }
  }, {
    key: "renderRangeAreaSeries",
    value: function renderRangeAreaSeries(linePointsModel) {
      var _this5 = this;

      var model = [];
      linePointsModel.forEach(function (m) {
        var areaPoints = [];
        var points = m.points;
        points.slice(0, points.length / 2 + 1).forEach(function (point, i) {
          var lastPoint = i === points.length / 2 - 1;
          var nullPoint = isNull(point);

          if (!nullPoint) {
            areaPoints.push(point);
          }

          if (areaPoints.length && (lastPoint || nullPoint)) {
            var pairPoints = areaPoints.map(function (areaPoint, idx) {
              var curIdx = points.length / 2 + i - areaPoints.length + idx + (!nullPoint && lastPoint ? 1 : 0);
              return points[curIdx];
            }).reverse();
            model.push(areaSeries_objectSpread(areaSeries_objectSpread({}, m), {}, {
              type: 'areaPoints',
              lineWidth: 0,
              color: 'rgba(0, 0, 0, 0)',
              // make area border transparent
              fillColor: _this5.getAreaOpacity(m.name, m.color),
              points: [].concat(areaSeries_toConsumableArray(areaPoints), areaSeries_toConsumableArray(pairPoints))
            }));
            areaPoints = [];
          }
        });
      });
      return model;
    }
  }, {
    key: "renderAreaSeries",
    value: function renderAreaSeries(linePointsModel) {
      var _this6 = this;

      var model = [];
      var bottomYPoint = [];
      linePointsModel.forEach(function (m) {
        var areaPoints = [];
        var curBottomYPoint = [].concat(bottomYPoint);
        var points = m.points;
        points.forEach(function (point, i) {
          var lastPoint = i === points.length - 1;
          var nullPoint = isNull(point);

          if (!isNull(point)) {
            areaPoints.push(point);
          }

          if (areaPoints.length && (nullPoint || lastPoint)) {
            var pairPoints = areaPoints.map(function (areaPoint, idx) {
              var curIdx = i - areaPoints.length + idx + (!nullPoint && lastPoint ? 1 : 0);
              var bottom = isUndefined(curBottomYPoint[curIdx]) ? _this6.baseYPosition : curBottomYPoint[curIdx];

              if (_this6.isStackChart) {
                bottomYPoint[curIdx] = areaPoint.y;
              }

              return {
                x: areaPoint.x,
                y: bottom
              };
            }).reverse();

            if (_this6.isStackChart && _this6.isSplineChart) {
              setSplineControlPoint(pairPoints); // set spline for new stack pair points
            }

            model.push(areaSeries_objectSpread(areaSeries_objectSpread({}, m), {}, {
              type: 'areaPoints',
              lineWidth: 0,
              color: 'rgba(0, 0, 0, 0)',
              // make area border transparent
              fillColor: _this6.getAreaOpacity(m.name, m.color),
              points: [].concat(areaSeries_toConsumableArray(areaPoints), areaSeries_toConsumableArray(pairPoints))
            }));
            areaPoints = [];
          }
        });
      });
      return model;
    }
  }, {
    key: "getCombinedLinePointsModel",
    value: function getCombinedLinePointsModel() {
      var _this7 = this;

      if (!this.isRangeChart) {
        return this.linePointsModel;
      }

      var len = this.linePointsModel.length / 2;
      return utils_range(0, len).reduce(function (acc, i) {
        var start = i;
        var end = len + i;

        var points = _this7.getCombinedPoints(start, end);

        return [].concat(areaSeries_toConsumableArray(acc), [areaSeries_objectSpread(areaSeries_objectSpread({}, _this7.linePointsModel[i]), {}, {
          points: points
        })]);
      }, []);
    }
  }, {
    key: "getAreaOpacity",
    value: function getAreaOpacity(name, color) {
      var _this$theme2 = this.theme,
          select = _this$theme2.select,
          areaOpacity = _this$theme2.areaOpacity;
      var active = this.activeSeriesMap[name];
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);
    }
  }, {
    key: "renderAreaPointsModel",
    value: function renderAreaPointsModel() {
      var combinedLinePointsModel = this.getCombinedLinePointsModel();
      return this.isRangeChart ? this.renderRangeAreaSeries(combinedLinePointsModel) : this.renderAreaSeries(combinedLinePointsModel);
    }
  }, {
    key: "renderCircleModel",
    value: function renderCircleModel(showDot) {
      var _this8 = this;

      var dotSeriesModel = [];
      var responderModel = [];
      var _this$theme3 = this.theme,
          hover = _this$theme3.hover,
          dotTheme = _this$theme3.dot;
      var hoverDotTheme = hover.dot;
      this.linePointsModel.forEach(function (_ref4, modelIndex) {
        var points = _ref4.points,
            color = _ref4.color,
            seriesIndex = _ref4.seriesIndex,
            name = _ref4.name;
        var isPairLinePointsModel = _this8.isRangeChart && modelIndex >= _this8.linePointsModel.length / 2;
        var active = _this8.activeSeriesMap[name];
        points.forEach(function (point, index) {
          var _hoverDotTheme$color, _hoverDotTheme$border;

          if (isNull(point)) {
            return;
          }

          var model = areaSeries_objectSpread(areaSeries_objectSpread({
            type: 'circle'
          }, point), {}, {
            seriesIndex: seriesIndex,
            name: name,
            index: isPairLinePointsModel ? points.length - index - 1 : index
          });

          if (showDot) {
            var _dotTheme$borderColor;

            dotSeriesModel.push(areaSeries_objectSpread(areaSeries_objectSpread({}, model), {}, {
              radius: dotTheme.radius,
              color: getRGBA(color, active ? 1 : 0.3),
              style: [{
                lineWidth: dotTheme.borderWidth,
                strokeStyle: (_dotTheme$borderColor = dotTheme.borderColor) !== null && _dotTheme$borderColor !== void 0 ? _dotTheme$borderColor : color
              }]
            }));
          }

          var modelColor = (_hoverDotTheme$color = hoverDotTheme.color) !== null && _hoverDotTheme$color !== void 0 ? _hoverDotTheme$color : getRGBA(color, 1);
          responderModel.push(areaSeries_objectSpread(areaSeries_objectSpread({}, model), {}, {
            radius: hoverDotTheme.radius,
            color: modelColor,
            style: [{
              lineWidth: hoverDotTheme.borderWidth,
              strokeStyle: (_hoverDotTheme$border = hoverDotTheme.borderColor) !== null && _hoverDotTheme$border !== void 0 ? _hoverDotTheme$border : getRGBA(modelColor, 0.5)
            }]
          }));
        });
      });
      return {
        dotSeriesModel: dotSeriesModel,
        responderModel: responderModel
      };
    }
  }, {
    key: "getPairCircleModel",
    value: function getPairCircleModel(circleModels) {
      var _this9 = this;

      var pairCircleModels = [];
      circleModels.forEach(function (circle) {
        var seriesIndex = circle.seriesIndex,
            y = circle.y,
            data = circle.data;
        var category = data.category;

        var pairCircleModel = _this9.tooltipCircleMap[category].find(function (model) {
          return model.seriesIndex === seriesIndex && model.y !== y;
        });

        pairCircleModels.push(pairCircleModel);
      });
      return pairCircleModels;
    }
  }, {
    key: "getCircleModelsFromRectResponders",
    value: function getCircleModelsFromRectResponders(responders, mousePositions) {
      var _this$tooltipCircleMa;

      if (!responders.length || !responders[0].label) {
        return [];
      }

      var models = (_this$tooltipCircleMa = this.tooltipCircleMap[responders[0].label]) !== null && _this$tooltipCircleMa !== void 0 ? _this$tooltipCircleMa : [];
      return this.eventDetectType === 'grouped' ? models : getNearestResponder(models, mousePositions, this.rect);
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var circleModels = this.getCircleModelsFromRectResponders(responders);
      this.eventBus.emit('renderHoveredSeries', {
        models: circleModels,
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = this.isRangeChart ? circleModels.slice(0, circleModels.length / 2) // for rendering unique tooltip data
      : circleModels;
    }
  }, {
    key: "onMousemoveNearestType",
    value: function onMousemoveNearestType(responders, mousePositions) {
      var circleModels = this.getCircleModelsFromRectResponders(responders, mousePositions);
      this.onMousemoveNearType(circleModels);
    }
  }, {
    key: "onMousemoveNearType",
    value: function onMousemoveNearType(responders) {
      var pairCircleModels = [];

      if (this.isRangeChart) {
        pairCircleModels = this.getPairCircleModel(responders);
      }

      var hoveredSeries = [].concat(areaSeries_toConsumableArray(responders), areaSeries_toConsumableArray(pairCircleModels));
      this.eventBus.emit('renderHoveredSeries', {
        models: hoveredSeries,
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = responders;
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref5) {
      var responders = _ref5.responders,
          mousePosition = _ref5.mousePosition;

      if (this.eventDetectType === 'nearest') {
        this.onMousemoveNearestType(responders, mousePosition);
      } else if (this.eventDetectType === 'near') {
        this.onMousemoveNearType(responders);
      } else {
        this.onMousemoveGroupedType(responders);
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "getDataLabels",
    value: function getDataLabels(seriesModels) {
      var dataLabelTheme = this.theme.dataLabels;
      return seriesModels.flatMap(function (_ref6) {
        var points = _ref6.points,
            name = _ref6.name,
            fillColor = _ref6.fillColor;
        return points.map(function (point) {
          return isNull(point) ? {} : areaSeries_objectSpread(areaSeries_objectSpread({
            type: 'point'
          }, point), {}, {
            name: name,
            theme: areaSeries_objectSpread(areaSeries_objectSpread({}, dataLabelTheme), {}, {
              color: dataLabelTheme.useSeriesColor ? getRGBA(fillColor, 1) : dataLabelTheme.color
            })
          });
        });
      });
    }
  }, {
    key: "getSelectedSeriesWithTheme",
    value: function getSelectedSeriesWithTheme(models) {
      var _ref7 = this.theme.select.dot,
          radius = _ref7.radius,
          color = _ref7.color,
          borderWidth = _ref7.borderWidth,
          borderColor = _ref7.borderColor;
      return models.map(function (model) {
        var modelColor = color !== null && color !== void 0 ? color : model.color;
        return areaSeries_objectSpread(areaSeries_objectSpread({}, model), {}, {
          radius: radius,
          color: modelColor,
          style: [{
            lineWidth: borderWidth,
            strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5)
          }]
        });
      });
    }
  }, {
    key: "onClick",
    value: function onClick(_ref8) {
      var responders = _ref8.responders,
          mousePosition = _ref8.mousePosition;

      if (this.selectable) {
        var models;

        if (this.eventDetectType === 'near') {
          models = responders;
        } else {
          models = this.getCircleModelsFromRectResponders(responders, mousePosition);
        }

        this.eventBus.emit('renderSelectedSeries', {
          models: this.getSelectedSeriesWithTheme(models),
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "getResponderCategoryByIndex",
    value: function getResponderCategoryByIndex(index) {
      var _responder$data;

      var responder = Object.values(this.tooltipCircleMap).flatMap(function (val) {
        return val;
      }).find(function (model) {
        return model.index === index;
      });
      return responder === null || responder === void 0 ? void 0 : (_responder$data = responder.data) === null || _responder$data === void 0 ? void 0 : _responder$data.category;
    }
  }]);

  return AreaSeries;
}(component_Component);


// CONCATENATED MODULE: ./src/charts/areaChart.ts



















function areaChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { areaChart_typeof = function _typeof(obj) { return typeof obj; }; } else { areaChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return areaChart_typeof(obj); }

function areaChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function areaChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { areaChart_ownKeys(Object(source), true).forEach(function (key) { areaChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { areaChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function areaChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function areaChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function areaChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) areaChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) areaChart_defineProperties(Constructor, staticProps); return Constructor; }

function areaChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { areaChart_get = Reflect.get; } else { areaChart_get = function _get(target, property, receiver) { var base = areaChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return areaChart_get(target, property, receiver || target); }

function areaChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = areaChart_getPrototypeOf(object); if (object === null) break; } return object; }

function areaChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) areaChart_setPrototypeOf(subClass, superClass); }

function areaChart_setPrototypeOf(o, p) { areaChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return areaChart_setPrototypeOf(o, p); }

function areaChart_createSuper(Derived) { var hasNativeReflectConstruct = areaChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = areaChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = areaChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return areaChart_possibleConstructorReturn(this, result); }; }

function areaChart_possibleConstructorReturn(self, call) { if (call && (areaChart_typeof(call) === "object" || typeof call === "function")) { return call; } return areaChart_assertThisInitialized(self); }

function areaChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function areaChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function areaChart_getPrototypeOf(o) { areaChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return areaChart_getPrototypeOf(o); }

function areaChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






























/**
 * @class
 * @classdesc Area Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Area Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<number|Array<number>>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Area Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.showDot=false] - Whether to show dot or not.
 *       @param {boolean} [props.options.series.spline=false] - Whether to make spline chart or not.
 *       @param {boolean} [props.options.series.zoomable=false] - Whether to use zoom feature or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'near', 'nearest', 'grouped', 'point' is available.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {boolean|Object} [props.options.series.stack] - Option to decide whether to use stack chart and type of stack chart. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Area Chart guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *       @param {Array<Object>} [props.options.plot.lines] - Plot lines information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Area Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var areaChart_AreaChart = /*#__PURE__*/function (_Chart) {
  areaChart_inherits(AreaChart, _Chart);

  var _super = areaChart_createSuper(AreaChart);

  function AreaChart(props) {
    var _this;

    areaChart_classCallCheck(this, AreaChart);

    _this = _super.call(this, {
      el: props.el,
      options: props.options,
      series: {
        area: props.data.series
      },
      categories: props.data.categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
    });

    areaChart_defineProperty(areaChart_assertThisInitialized(_this), "addData", function (data, category) {
      _this.resetSeries();

      _this.animationControlFlag.updating = true;

      _this.store.dispatch('addData', {
        data: data,
        category: category
      });
    });

    areaChart_defineProperty(areaChart_assertThisInitialized(_this), "hideSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    });

    areaChart_defineProperty(areaChart_assertThisInitialized(_this), "showSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    });

    areaChart_defineProperty(areaChart_assertThisInitialized(_this), "setOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('initOptions', options);
    });

    areaChart_defineProperty(areaChart_assertThisInitialized(_this), "updateOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', options);
    });

    areaChart_defineProperty(areaChart_assertThisInitialized(_this), "showTooltip", function (seriesInfo) {
      _this.eventBus.emit('showTooltip', areaChart_objectSpread({}, seriesInfo));
    });

    areaChart_defineProperty(areaChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  areaChart_createClass(AreaChart, [{
    key: "initialize",
    value: function initialize() {
      areaChart_get(areaChart_getPrototypeOf(AreaChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(title_Title);
      this.componentManager.add(plot_Plot);
      this.componentManager.add(legend_Legend);
      this.componentManager.add(areaSeries_AreaSeries);
      this.componentManager.add(axis_Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(dataLabels_DataLabels);
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(exportMenu_ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(hoveredSeries_HoveredSeries);
      this.componentManager.add(selectedSeries_SelectedSeries);
      this.componentManager.add(tooltip_Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(zoom_Zoom);
      this.componentManager.add(resetButton_ResetButton);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_resetButton_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addSeries",

    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          area: series
        },
        categories: categories
      });
    }
    /**
     * Add plot line.
     * @param {Object} data - Plot info.
     *   @param {string|number} data.value - The value where the plot line will be drawn.
     *   @param {string} data.color - Plot line color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
     * @api
     * @example
     * chart.addPlotLine({
     *   value: 2,
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotLine",
    value: function addPlotLine(data) {
      this.store.dispatch('addPlotLine', {
        data: data
      });
    }
    /**
     * Remove plot line with id.
     * @param {string} id - Id of the plot line to be removed.
     * @api
     * @example
     * chart.removePlotLine('plot-1');
     */

  }, {
    key: "removePlotLine",
    value: function removePlotLine(id) {
      this.store.dispatch('removePlotLine', {
        id: id
      });
    }
    /**
     * Add plot band.
     * @param {Object} data - Plot info.
     * @param {Array<string|number>} data.range - The range to be drawn.
     * @param {string} data.color - Plot band color.
     * @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
     * @api
     * @example
     * chart.addPlotBand({
     *   value: [2, 4],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotBand",
    value: function addPlotBand(data) {
      this.store.dispatch('addPlotBand', {
        data: data
      });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - id of the plot band to be removed.
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */

  }, {
    key: "removePlotBand",
    value: function removePlotBand(id) {
      this.store.dispatch('removePlotBand', {
        id: id
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }]);

  return AreaChart;
}(chart_Chart);


// CONCATENATED MODULE: ./src/component/scatterSeries.ts



























function scatterSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { scatterSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { scatterSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return scatterSeries_typeof(obj); }

function scatterSeries_toConsumableArray(arr) { return scatterSeries_arrayWithoutHoles(arr) || scatterSeries_iterableToArray(arr) || scatterSeries_unsupportedIterableToArray(arr) || scatterSeries_nonIterableSpread(); }

function scatterSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function scatterSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return scatterSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return scatterSeries_arrayLikeToArray(o, minLen); }

function scatterSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function scatterSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return scatterSeries_arrayLikeToArray(arr); }

function scatterSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function component_scatterSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function component_scatterSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { component_scatterSeries_ownKeys(Object(source), true).forEach(function (key) { component_scatterSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { component_scatterSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function scatterSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function scatterSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function scatterSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) scatterSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) scatterSeries_defineProperties(Constructor, staticProps); return Constructor; }

function scatterSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) scatterSeries_setPrototypeOf(subClass, superClass); }

function scatterSeries_setPrototypeOf(o, p) { scatterSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return scatterSeries_setPrototypeOf(o, p); }

function scatterSeries_createSuper(Derived) { var hasNativeReflectConstruct = scatterSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = scatterSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = scatterSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return scatterSeries_possibleConstructorReturn(this, result); }; }

function scatterSeries_possibleConstructorReturn(self, call) { if (call && (scatterSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return scatterSeries_assertThisInitialized(self); }

function scatterSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function scatterSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function scatterSeries_getPrototypeOf(o) { scatterSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return scatterSeries_getPrototypeOf(o); }

function component_scatterSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












var scatterSeries_ScatterSeries = /*#__PURE__*/function (_Component) {
  scatterSeries_inherits(ScatterSeries, _Component);

  var _super = scatterSeries_createSuper(ScatterSeries);

  function ScatterSeries() {
    var _this;

    scatterSeries_classCallCheck(this, ScatterSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "theme", void 0);

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "models", {
      series: []
    });

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "drawModels", void 0);

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "responders", void 0);

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "activatedResponders", []);

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "rect", void 0);

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "getModelsForSelectInfo", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex,
          state = info.state;

      if (!isAvailableSelectSeries(info, 'scatter')) {
        return [];
      }

      var name = state.series.scatter.data[seriesIndex].name;
      return [_this.responders.filter(function (_ref) {
        var dataName = _ref.name;
        return dataName === name;
      })[index]];
    });

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "selectSeries", function (info) {
      var models = _this.getModelsForSelectInfo(info);

      if (!models.length) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: models,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var models = _this.getModelsForSelectInfo(info);

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: models,
        name: _this.name
      });

      _this.activatedResponders = models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  scatterSeries_createClass(ScatterSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'scatter';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      var _this2 = this;

      this.drawModels.series.forEach(function (model, index) {
        model.size = _this2.models.series[index].size * delta;
      });
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var _this3 = this;

      var layout = chartState.layout,
          series = chartState.series,
          scale = chartState.scale,
          legend = chartState.legend,
          options = chartState.options,
          theme = chartState.theme;

      if (!series.scatter) {
        throw new Error(message.noDataError(this.name));
      }

      var scatterData = series.scatter.data;
      this.theme = theme.series.scatter;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var seriesModel = this.renderScatterPointsModel(scatterData, scale.xAxis.limit, scale[getValueAxisName(options, this.name, 'yAxis')].limit);
      var tooltipModel = this.makeTooltipModel(scatterData);
      this.models.series = seriesModel;

      if (!this.drawModels) {
        this.drawModels = deepCopy(this.models);
      }

      this.responders = seriesModel.map(function (m, index) {
        return component_scatterSeries_objectSpread(component_scatterSeries_objectSpread({}, m), {}, {
          type: 'circle',
          detectionSize: 0,
          radius: _this3.theme.size / 2,
          color: m.fillColor,
          style: [{
            strokeStyle: m.borderColor,
            lineWidth: m.borderWidth
          }],
          data: tooltipModel[index]
        });
      });
    }
  }, {
    key: "renderScatterPointsModel",
    value: function renderScatterPointsModel(seriesRawData, xAxisLimit, yAxisLimit) {
      var _this4 = this;

      return seriesRawData.flatMap(function (_ref2, seriesIndex) {
        var data = _ref2.data,
            name = _ref2.name,
            seriesColor = _ref2.color,
            iconType = _ref2.iconType;
        var models = [];
        var active = _this4.activeSeriesMap[name];
        var color = getRGBA(seriesColor, active ? 1 : 0.3);
        data.forEach(function (datum, index) {
          var rawXValue = getCoordinateXValue(datum);
          var xValue = isString(rawXValue) ? Number(new Date(rawXValue)) : Number(rawXValue);
          var yValue = getCoordinateYValue(datum);
          var xValueRatio = getValueRatio(xValue, xAxisLimit);
          var yValueRatio = getValueRatio(yValue, yAxisLimit);
          var x = xValueRatio * _this4.rect.width;
          var y = (1 - yValueRatio) * _this4.rect.height;
          models.push(component_scatterSeries_objectSpread({
            x: x,
            y: y,
            type: 'scatterSeries',
            iconType: iconType,
            seriesIndex: seriesIndex,
            name: name,
            borderColor: color,
            index: index
          }, pick(_this4.theme, 'borderWidth', 'size', 'fillColor')));
        });
        return models;
      });
    }
  }, {
    key: "makeTooltipModel",
    value: function makeTooltipModel(circleData) {
      return scatterSeries_toConsumableArray(circleData).flatMap(function (_ref3) {
        var data = _ref3.data,
            name = _ref3.name,
            color = _ref3.color;
        var tooltipData = [];
        data.forEach(function (datum) {
          var value = {
            x: getCoordinateXValue(datum),
            y: getCoordinateYValue(datum)
          };
          tooltipData.push({
            label: name,
            color: color,
            value: value
          });
        });
        return tooltipData;
      });
    }
  }, {
    key: "getClosestModel",
    value: function getClosestModel(closestResponder) {
      if (!closestResponder.length) {
        return [];
      }

      var model = this.models.series.find(function (_ref4) {
        var index = _ref4.index,
            seriesIndex = _ref4.seriesIndex;
        return isNumber(index) && isNumber(seriesIndex) && index === closestResponder[0].index && seriesIndex === closestResponder[0].seriesIndex;
      });
      return model ? [model] : [];
    }
  }, {
    key: "getResponderAppliedTheme",
    value: function getResponderAppliedTheme(closestModel, type) {
      var _this5 = this;

      var _this$theme$type = this.theme[type],
          fillColor = _this$theme$type.fillColor,
          size = _this$theme$type.size;
      return closestModel.map(function (m) {
        return deepMergedCopy(m, component_scatterSeries_objectSpread(component_scatterSeries_objectSpread({}, _this5.theme[type]), {}, {
          color: fillColor,
          radius: size / 2
        }));
      });
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref5) {
      var responders = _ref5.responders,
          mousePosition = _ref5.mousePosition;
      var closestResponder = getNearestResponder(responders, mousePosition, this.rect);
      var closestModel = this.getClosestModel(closestResponder);
      closestModel = this.getResponderAppliedTheme(closestModel, 'hover');
      this.eventBus.emit('renderHoveredSeries', {
        models: closestModel,
        name: this.name
      });
      this.activatedResponders = closestResponder;
      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref6) {
      var responders = _ref6.responders,
          mousePosition = _ref6.mousePosition;

      if (this.selectable) {
        var closestResponder = getNearestResponder(responders, mousePosition, this.rect);
        var closestModel = this.getClosestModel(closestResponder);
        closestModel = this.getResponderAppliedTheme(closestModel, 'select');
        this.eventBus.emit('renderSelectedSeries', {
          models: closestModel,
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }]);

  return ScatterSeries;
}(component_Component);


// CONCATENATED MODULE: ./src/charts/lineScatterChart.ts



















function lineScatterChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { lineScatterChart_typeof = function _typeof(obj) { return typeof obj; }; } else { lineScatterChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return lineScatterChart_typeof(obj); }

function lineScatterChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function lineScatterChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { lineScatterChart_ownKeys(Object(source), true).forEach(function (key) { lineScatterChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { lineScatterChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function lineScatterChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lineScatterChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function lineScatterChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) lineScatterChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) lineScatterChart_defineProperties(Constructor, staticProps); return Constructor; }

function lineScatterChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { lineScatterChart_get = Reflect.get; } else { lineScatterChart_get = function _get(target, property, receiver) { var base = lineScatterChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return lineScatterChart_get(target, property, receiver || target); }

function lineScatterChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = lineScatterChart_getPrototypeOf(object); if (object === null) break; } return object; }

function lineScatterChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) lineScatterChart_setPrototypeOf(subClass, superClass); }

function lineScatterChart_setPrototypeOf(o, p) { lineScatterChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return lineScatterChart_setPrototypeOf(o, p); }

function lineScatterChart_createSuper(Derived) { var hasNativeReflectConstruct = lineScatterChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = lineScatterChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = lineScatterChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return lineScatterChart_possibleConstructorReturn(this, result); }; }

function lineScatterChart_possibleConstructorReturn(self, call) { if (call && (lineScatterChart_typeof(call) === "object" || typeof call === "function")) { return call; } return lineScatterChart_assertThisInitialized(self); }

function lineScatterChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function lineScatterChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function lineScatterChart_getPrototypeOf(o) { lineScatterChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return lineScatterChart_getPrototypeOf(o); }

function lineScatterChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






























/**
 * @class
 * @classdesc LineScatter Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making LineArea Chart.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {Array<Object>} props.data.series.line - Line series data. Only coordinate type data is possible.
 *       @param {Array<Object>} props.data.series.scatter - Scatter series data.
 *   @param {Object} [props.options] - Options for making LineScatter Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series] - Write common options in the upper depth and separate options to be applied to each chart.
 *       @param {Object} [props.options.series.line] - Options to be applied to the line chart. 'spline', 'showDot' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Line Chart guide} on github.
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|LineScatter Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme. Each theme to be applied to the two charts should be written separately.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var lineScatterChart_LineScatterChart = /*#__PURE__*/function (_Chart) {
  lineScatterChart_inherits(LineScatterChart, _Chart);

  var _super = lineScatterChart_createSuper(LineScatterChart);

  function LineScatterChart(props) {
    var _this;

    lineScatterChart_classCallCheck(this, LineScatterChart);

    _this = _super.call(this, {
      el: props.el,
      options: props.options,
      series: props.data.series,
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });

    lineScatterChart_defineProperty(lineScatterChart_assertThisInitialized(_this), "addData", function (data, chartType) {
      _this.animationControlFlag.updating = true;

      _this.resetSeries();

      _this.store.dispatch('addData', {
        data: data,
        chartType: chartType
      });
    });

    lineScatterChart_defineProperty(lineScatterChart_assertThisInitialized(_this), "addSeries", function (data, dataInfo) {
      _this.resetSeries();

      _this.store.dispatch('addSeries', lineScatterChart_objectSpread({
        data: data
      }, dataInfo));
    });

    lineScatterChart_defineProperty(lineScatterChart_assertThisInitialized(_this), "setOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('initOptions', options);
    });

    lineScatterChart_defineProperty(lineScatterChart_assertThisInitialized(_this), "updateOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', options);
    });

    lineScatterChart_defineProperty(lineScatterChart_assertThisInitialized(_this), "showTooltip", function (seriesInfo) {
      _this.eventBus.emit('showTooltip', lineScatterChart_objectSpread(lineScatterChart_objectSpread({}, seriesInfo), {}, {
        state: _this.store.state
      }));
    });

    lineScatterChart_defineProperty(lineScatterChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  lineScatterChart_createClass(LineScatterChart, [{
    key: "initialize",
    value: function initialize() {
      lineScatterChart_get(lineScatterChart_getPrototypeOf(LineScatterChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(title_Title);
      this.componentManager.add(plot_Plot);
      this.componentManager.add(legend_Legend);
      this.componentManager.add(lineSeries_LineSeries);
      this.componentManager.add(scatterSeries_ScatterSeries);
      this.componentManager.add(axis_Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(dataLabels_DataLabels);
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(exportMenu_ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(hoveredSeries_HoveredSeries);
      this.componentManager.add(selectedSeries_SelectedSeries);
      this.componentManager.add(tooltip_Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(zoom_Zoom);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_resetButton_namespaceObject, scatterSeries_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} chartType - Which type of chart to add.
     * @api
     * @example
     * chart.addData([{x: 10, y: 20}, {x: 30, y: 40}], 'line');
     */

  }, {
    key: "setData",

    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   series: {
     *     line: [
     *       {
     *         name: 'A',
     *         data: [{x: 10, y: 20}, {x: 30, y: 40}],
     *       }
     *     ],
     *     scatter: [
     *       {
     *         name: 'B',
     *         data: [{x: 30, y: 20}, {x: 40, y: 40}],
     *       }
     *     ]
     *   }
     * });
     */
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', data);
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     line: {
     *       showDot: true,
     *     },
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }]);

  return LineScatterChart;
}(chart_Chart);


// CONCATENATED MODULE: ./src/charts/lineAreaChart.ts



















function lineAreaChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { lineAreaChart_typeof = function _typeof(obj) { return typeof obj; }; } else { lineAreaChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return lineAreaChart_typeof(obj); }

function lineAreaChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function lineAreaChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { lineAreaChart_ownKeys(Object(source), true).forEach(function (key) { lineAreaChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { lineAreaChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function lineAreaChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lineAreaChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function lineAreaChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) lineAreaChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) lineAreaChart_defineProperties(Constructor, staticProps); return Constructor; }

function lineAreaChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { lineAreaChart_get = Reflect.get; } else { lineAreaChart_get = function _get(target, property, receiver) { var base = lineAreaChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return lineAreaChart_get(target, property, receiver || target); }

function lineAreaChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = lineAreaChart_getPrototypeOf(object); if (object === null) break; } return object; }

function lineAreaChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) lineAreaChart_setPrototypeOf(subClass, superClass); }

function lineAreaChart_setPrototypeOf(o, p) { lineAreaChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return lineAreaChart_setPrototypeOf(o, p); }

function lineAreaChart_createSuper(Derived) { var hasNativeReflectConstruct = lineAreaChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = lineAreaChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = lineAreaChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return lineAreaChart_possibleConstructorReturn(this, result); }; }

function lineAreaChart_possibleConstructorReturn(self, call) { if (call && (lineAreaChart_typeof(call) === "object" || typeof call === "function")) { return call; } return lineAreaChart_assertThisInitialized(self); }

function lineAreaChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function lineAreaChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function lineAreaChart_getPrototypeOf(o) { lineAreaChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return lineAreaChart_getPrototypeOf(o); }

function lineAreaChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }































/**
 * @class
 * @classdesc LineArea Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making LineArea Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {Array<Object>} props.data.series.line - Line series data. Coordinate types data is not possible.
 *       @param {Array<Object>} props.data.series.area - Area series data.
 *   @param {Object} [props.options] - Options for making LineArea Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series] - Write common options in the upper depth and separate options to be applied to each chart.
 *       @param {Object} [props.options.series.line] - Options to be applied to the line chart. 'spline', 'showDot', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Line Chart guide} on github.
 *       @param {Object} [props.options.series.area] - Options to be applied to the area chart. 'stack', 'spline', 'showDot', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Area Chart guide} on github.
 *       @param {boolean} [props.options.series.zoomable=false] - Whether to use zoom feature or not.
 *       @param {boolean} [props.options.series.showDot=false] - Whether to show dot or not.
 *       @param {boolean} [props.options.series.spline=false] - Whether to make spline chart or not.
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *       @param {Array<Object>} [props.options.plot.lines] - Plot lines information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|LineArea Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme. Each theme to be applied to the two charts should be written separately.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var lineAreaChart_LineAreaChart = /*#__PURE__*/function (_Chart) {
  lineAreaChart_inherits(LineAreaChart, _Chart);

  var _super = lineAreaChart_createSuper(LineAreaChart);

  function LineAreaChart(props) {
    var _this;

    lineAreaChart_classCallCheck(this, LineAreaChart);

    _this = _super.call(this, {
      el: props.el,
      options: props.options,
      series: props.data.series,
      categories: props.data.categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
    });

    lineAreaChart_defineProperty(lineAreaChart_assertThisInitialized(_this), "addData", function (data, category, chartType) {
      _this.animationControlFlag.updating = true;

      _this.resetSeries();

      _this.store.dispatch('addData', {
        data: data,
        category: category,
        chartType: chartType
      });
    });

    lineAreaChart_defineProperty(lineAreaChart_assertThisInitialized(_this), "addSeries", function (data, dataInfo) {
      _this.resetSeries();

      _this.store.dispatch('addSeries', lineAreaChart_objectSpread({
        data: data
      }, dataInfo));
    });

    lineAreaChart_defineProperty(lineAreaChart_assertThisInitialized(_this), "hideSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    });

    lineAreaChart_defineProperty(lineAreaChart_assertThisInitialized(_this), "showSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    });

    lineAreaChart_defineProperty(lineAreaChart_assertThisInitialized(_this), "setOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('initOptions', options);
    });

    lineAreaChart_defineProperty(lineAreaChart_assertThisInitialized(_this), "updateOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', options);
    });

    lineAreaChart_defineProperty(lineAreaChart_assertThisInitialized(_this), "showTooltip", function (seriesInfo) {
      _this.eventBus.emit('showTooltip', lineAreaChart_objectSpread({}, seriesInfo));
    });

    lineAreaChart_defineProperty(lineAreaChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  lineAreaChart_createClass(LineAreaChart, [{
    key: "initialize",
    value: function initialize() {
      lineAreaChart_get(lineAreaChart_getPrototypeOf(LineAreaChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(title_Title);
      this.componentManager.add(plot_Plot);
      this.componentManager.add(legend_Legend);
      this.componentManager.add(areaSeries_AreaSeries);
      this.componentManager.add(lineSeries_LineSeries);
      this.componentManager.add(axis_Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(dataLabels_DataLabels);
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(exportMenu_ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(hoveredSeries_HoveredSeries);
      this.componentManager.add(selectedSeries_SelectedSeries);
      this.componentManager.add(tooltip_Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(zoom_Zoom);
      this.componentManager.add(resetButton_ResetButton);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_resetButton_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<number>} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @param {string} chartType - Which type of chart to add.
     * @api
     * @example
     * chart.addData([10, 20], '6', 'line');
     */

  }, {
    key: "setData",

    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: {
     *     line: [
     *       {
     *         name: 'A',
     *         data: [1, 2, 3],
     *       }
     *     ],
     *     area: [
     *       {
     *         name: 'B',
     *         data: [4, 5, 6],
     *       }
     *     ]
     *   }
     * });
     */
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', data);
    }
    /**
     * Add plot line.
     * @param {Object} data - plot info
     *   @param {string|number} data.value - The value where the plot line will be drawn.
     *   @param {string} data.color - Plot line color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
     * @api
     * @example
     * chart.addPlotLine({
     *   value: 2,
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotLine",
    value: function addPlotLine(data) {
      this.store.dispatch('addPlotLine', {
        data: data
      });
    }
    /**
     * Remove plot line with id.
     * @param {string} id - Id of the plot line to be removed.
     * @api
     * @example
     * chart.removePlotLine('plot-1');
     */

  }, {
    key: "removePlotLine",
    value: function removePlotLine(id) {
      this.store.dispatch('removePlotLine', {
        id: id
      });
    }
    /**
     * Add plot band.
     * @param {Object} data - Plot info.
     * @param {Array<string|number>} data.range - The range to be drawn.
     * @param {string} data.color - Plot band color.
     * @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
     * @api
     * @example
     * chart.addPlotBand({
     *   value: [2, 4],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotBand",
    value: function addPlotBand(data) {
      this.store.dispatch('addPlotBand', {
        data: data
      });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - Id of the plot band to be removed.
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */

  }, {
    key: "removePlotBand",
    value: function removePlotBand(id) {
      this.store.dispatch('removePlotBand', {
        id: id
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }]);

  return LineAreaChart;
}(chart_Chart);


// CONCATENATED MODULE: ./src/helpers/boxSeries.ts


function limitNegative(value, min, max) {
  var result = value;

  if (result >= max) {
    return 0;
  }

  if (max < 0) {
    result = Math.min(value - max, 0);
  }

  if (value < min) {
    result -= value - min;
  }

  return result;
}

function limitPositive(value, min, max) {
  var result = value;

  if (min > 0) {
    result = Math.max(value - min, 0);
  }

  if (value > max) {
    result -= value - max;
  }

  return result;
}

function calibrateDrawingValue(value, min, max) {
  return value < 0 ? limitNegative(value, min, max) : limitPositive(value, min, max);
}
function sumValuesBeforeIndex(values, targetIndex) {
  var includeTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var target = values[targetIndex];
  return values.reduce(function (total, value, idx) {
    var isBefore = includeTarget ? idx <= targetIndex : idx < targetIndex;
    var isSameSign = value * target >= 0;
    return isBefore && isSameSign ? total + value : total;
  }, 0);
}
function outsideRange(values, currentIndex, min, max) {
  var value = values[currentIndex];
  var totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
  var positive = value >= 0;
  var negative = value < 0;
  return positive && totalOfIndexBefore >= max || negative && totalOfIndexBefore <= min || currentIndex === 0 && positive && value < min || currentIndex === 0 && negative && value > max;
}
function calibrateBoxStackDrawingValue(values, currentIndex, min, max) {
  var totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
  var totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);

  if (outsideRange(values, currentIndex, min, max)) {
    return null;
  }

  if (currentIndex === 0) {
    return calibrateDrawingValue(values[currentIndex], min, max);
  }

  if (totalOfIndexBefore < min && totalOfValues > max) {
    return max - min;
  }

  var result = values[currentIndex];

  if (totalOfValues > max) {
    result = max - totalOfIndexBefore;
  } else if (totalOfValues < min) {
    result = min - totalOfIndexBefore;
  } else if (totalOfIndexBefore < min) {
    result = totalOfValues - min;
  } else if (totalOfIndexBefore > max) {
    result = totalOfValues - max;
  }

  return result;
}
// CONCATENATED MODULE: ./src/component/boxSeries.ts



























function boxSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { boxSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { boxSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return boxSeries_typeof(obj); }

function boxSeries_toConsumableArray(arr) { return boxSeries_arrayWithoutHoles(arr) || boxSeries_iterableToArray(arr) || boxSeries_unsupportedIterableToArray(arr) || boxSeries_nonIterableSpread(); }

function boxSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function boxSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return boxSeries_arrayLikeToArray(arr); }

function boxSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function boxSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { boxSeries_ownKeys(Object(source), true).forEach(function (key) { boxSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { boxSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function boxSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function boxSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function boxSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) boxSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) boxSeries_defineProperties(Constructor, staticProps); return Constructor; }

function boxSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) boxSeries_setPrototypeOf(subClass, superClass); }

function boxSeries_setPrototypeOf(o, p) { boxSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return boxSeries_setPrototypeOf(o, p); }

function boxSeries_createSuper(Derived) { var hasNativeReflectConstruct = boxSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = boxSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = boxSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return boxSeries_possibleConstructorReturn(this, result); }; }

function boxSeries_possibleConstructorReturn(self, call) { if (call && (boxSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return boxSeries_assertThisInitialized(self); }

function boxSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function boxSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function boxSeries_getPrototypeOf(o) { boxSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return boxSeries_getPrototypeOf(o); }

function boxSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function boxSeries_slicedToArray(arr, i) { return boxSeries_arrayWithHoles(arr) || boxSeries_iterableToArrayLimit(arr, i) || boxSeries_unsupportedIterableToArray(arr, i) || boxSeries_nonIterableRest(); }

function boxSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return boxSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return boxSeries_arrayLikeToArray(o, minLen); }

function boxSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function boxSeries_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function boxSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }














var SeriesDirection;

(function (SeriesDirection) {
  SeriesDirection[SeriesDirection["POSITIVE"] = 0] = "POSITIVE";
  SeriesDirection[SeriesDirection["NEGATIVE"] = 1] = "NEGATIVE";
  SeriesDirection[SeriesDirection["BOTH"] = 2] = "BOTH";
})(SeriesDirection || (SeriesDirection = {}));

var BOX = {
  BAR: 'bar',
  COLUMN: 'column'
};
function isLeftBottomSide(seriesIndex) {
  return !!(seriesIndex % 2);
}

function calculateBarLength(value, min, max) {
  if (isRangeValue(value)) {
    var _value = boxSeries_slicedToArray(value, 2),
        start = _value[0],
        end = _value[1];

    if (start < min) {
      start = min;
    }

    if (end > max) {
      end = max;
    }

    return end - start;
  }

  return calibrateDrawingValue(value, min, max);
}

function isBoxSeries(seriesName) {
  return includes(Object.values(BOX), seriesName);
}

var boxSeries_BoxSeries = /*#__PURE__*/function (_Component) {
  boxSeries_inherits(BoxSeries, _Component);

  var _super = boxSeries_createSuper(BoxSeries);

  function BoxSeries() {
    var _this;

    boxSeries_classCallCheck(this, BoxSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "models", {
      series: []
    });

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "drawModels", void 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "responders", void 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "activatedResponders", []);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "isBar", true);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "valueAxis", 'xAxis');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "labelAxis", 'yAxis');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "anchorSizeKey", 'height');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "offsetSizeKey", 'width');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "basePosition", 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "leftBasePosition", 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "rightBasePosition", 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "isRangeData", false);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "offsetKey", 'x');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "eventDetectType", 'point');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "tooltipRectMap", void 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "theme", void 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "selectSeries", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableSelectSeries(info, 'column')) {
        return;
      }

      var model = _this.tooltipRectMap[seriesIndex][index];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getRespondersWithTheme([model], 'select'),
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableShowTooltipInfo(info, _this.eventDetectType, 'column')) {
        return;
      }

      var models = _this.eventDetectType === 'grouped' ? _this.getGroupedRect([_this.responders[index]], 'hover') : _this.getRespondersWithTheme([_this.tooltipRectMap[index][seriesIndex]], 'hover');

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: models,
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.activatedResponders = _this.eventDetectType === 'grouped' ? _this.tooltipRectMap[index] : models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  boxSeries_createClass(BoxSeries, [{
    key: "initialize",
    value: function initialize(_ref) {
      var name = _ref.name,
          stackChart = _ref.stackChart;
      this.initializeFields(name);

      if (!stackChart) {
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
      }
    }
  }, {
    key: "initializeFields",
    value: function initializeFields(name) {
      this.type = 'series';
      this.name = name;
      this.isBar = name === BOX.BAR;
      this.offsetKey = this.isBar ? 'x' : 'y';
      this.valueAxis = this.isBar ? 'xAxis' : 'yAxis';
      this.labelAxis = this.isBar ? 'yAxis' : 'xAxis';
      this.anchorSizeKey = this.isBar ? 'height' : 'width';
      this.offsetSizeKey = this.isBar ? 'width' : 'height';
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      if (!this.drawModels) {
        return;
      }

      if (this.isRangeData) {
        this.initUpdateRangeData(delta);
        return;
      }

      this.initUpdateClipRect(delta);
      this.initUpdateConnector(delta);
    }
  }, {
    key: "initUpdateRangeData",
    value: function initUpdateRangeData(delta) {
      var _this2 = this;

      var series = this.drawModels.series;
      this.drawModels.clipRect = this.models.clipRect;
      var target = this.models.series;
      series.forEach(function (current, index) {
        var targetModel = target[index];

        if (delta === 0) {
          current[_this2.offsetSizeKey] = 0;
        }

        var offsetSize = current[_this2.offsetSizeKey] + (targetModel[_this2.offsetSizeKey] - current[_this2.offsetSizeKey]) * delta;
        current[_this2.offsetSizeKey] = offsetSize;

        if (!_this2.isBar) {
          current[_this2.offsetKey] = targetModel[_this2.offsetKey] + targetModel[_this2.offsetSizeKey] - offsetSize;
        }
      });
    }
  }, {
    key: "initUpdateClipRect",
    value: function initUpdateClipRect(delta) {
      var clipRect = this.drawModels.clipRect;

      if (!clipRect) {
        return;
      }

      var current = clipRect[0];
      var key = this.offsetSizeKey;
      var target = this.models.clipRect[0];
      var offsetSize = current[key] + (target[key] - current[key]) * delta;
      current[key] = offsetSize;
      current[this.offsetKey] = Math.max(this.basePosition - offsetSize * this.basePosition / target[key], 0);
    }
  }, {
    key: "initUpdateConnector",
    value: function initUpdateConnector(delta) {
      var connector = this.drawModels.connector;

      if (!connector) {
        return;
      }

      var target = this.models.connector;
      connector.forEach(function (current, index) {
        var alpha = getAlpha(target[index].strokeStyle) * delta;
        current.strokeStyle = getRGBA(current.strokeStyle, alpha);
      });
    }
  }, {
    key: "setEventDetectType",
    value: function setEventDetectType(series, options) {
      var _options$series;

      if (series.line) {
        this.eventDetectType = 'grouped';
      }

      if (options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }
    }
  }, {
    key: "getOptions",
    value: function getOptions(chartOptions) {
      var options = boxSeries_objectSpread({}, chartOptions);

      if ((options === null || options === void 0 ? void 0 : options.series) && options.series.column) {
        options.series = boxSeries_objectSpread(boxSeries_objectSpread({}, options.series), options.series.column);
      }

      return options;
    }
  }, {
    key: "render",
    value: function render(chartState, computed) {
      var _ref2,
          _ref3,
          _this3 = this;

      var layout = chartState.layout,
          series = chartState.series,
          axes = chartState.axes,
          stackSeries = chartState.stackSeries,
          legend = chartState.legend,
          theme = chartState.theme,
          scale = chartState.scale;
      this.isShow = !(stackSeries && stackSeries[this.name]);

      if (!this.isShow) {
        return;
      }

      var categories = (_ref2 = chartState.categories) !== null && _ref2 !== void 0 ? _ref2 : [];
      var options = this.getOptions(chartState.options);
      this.setEventDetectType(series, options);
      this.theme = theme.series[this.name];
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      this.valueAxis = getValueAxisName(options, this.name, this.isBar ? 'xAxis' : 'yAxis');
      var seriesData = series[this.name].data.map(function (seriesDatum) {
        return boxSeries_objectSpread(boxSeries_objectSpread({}, seriesDatum), {}, {
          data: getDataInRange(seriesDatum.data, computed.viewRange)
        });
      });

      if (axes.centerYAxis) {
        this.valueAxis = 'centerYAxis';
      }

      var tickDistance = axes[this.labelAxis].tickDistance;
      var diverging = !!((_ref3 = options.series) === null || _ref3 === void 0 ? void 0 : _ref3.diverging);

      var _this$getScaleData = this.getScaleData(scale),
          limit = _this$getScaleData.limit,
          stepSize = _this$getScaleData.stepSize;

      var labels = makeLabelsFromLimit(limit, stepSize);

      var _getLimitOnAxis = getLimitOnAxis(labels),
          min = _getLimitOnAxis.min,
          max = _getLimitOnAxis.max;

      this.basePosition = this.getBasePosition(axes[this.valueAxis]);
      var offsetSize = this.getOffsetSize();
      var centerYAxis = axes.centerYAxis;

      if (diverging) {
        var _this$getDivergingBas = this.getDivergingBasePosition(centerYAxis),
            _this$getDivergingBas2 = boxSeries_slicedToArray(_this$getDivergingBas, 2),
            left = _this$getDivergingBas2[0],
            right = _this$getDivergingBas2[1];

        this.basePosition = this.getOffsetSize() / 2;
        this.leftBasePosition = left;
        this.rightBasePosition = right;
        offsetSize = this.getOffsetSizeWithDiverging(centerYAxis);
      }

      var renderOptions = {
        min: min,
        max: max,
        tickDistance: tickDistance,
        diverging: diverging,
        ratio: this.getValueRatio(min, max, offsetSize),
        hasNegativeValue: hasNegative(labels),
        seriesDirection: this.getSeriesDirection(labels),
        defaultPadding: getBoxTypeSeriesPadding(tickDistance)
      };
      var seriesModels = this.renderSeriesModel(seriesData, renderOptions);
      var tooltipData = this.makeTooltipData(seriesData, renderOptions, categories);
      var clipRect = this.renderClipRectAreaModel();
      this.models = {
        clipRect: [clipRect],
        series: seriesModels
      };

      if (!this.drawModels) {
        this.drawModels = {
          clipRect: [this.initClipRect(clipRect)],
          series: deepCopyArray(seriesModels)
        };
      }

      if (getDataLabelsOptions(options, this.name).visible) {
        var dataLabelData = seriesModels.reduce(function (acc, data) {
          return isRangeValue(data.value) ? [].concat(boxSeries_toConsumableArray(acc), boxSeries_toConsumableArray(_this3.makeDataLabelRangeData(data))) : [].concat(boxSeries_toConsumableArray(acc), [_this3.makeDataLabel(data, centerYAxis)]);
        }, []);
        this.renderDataLabels(dataLabelData);
      }

      this.tooltipRectMap = this.makeTooltipRectMap(seriesModels, tooltipData);
      this.responders = this.getBoxSeriesResponders(seriesModels, tooltipData, axes, categories);
    }
  }, {
    key: "getScaleData",
    value: function getScaleData(scale) {
      return scale[this.valueAxis === 'centerYAxis' ? 'xAxis' : this.valueAxis];
    }
  }, {
    key: "getBoxSeriesResponders",
    value: function getBoxSeriesResponders(seriesModels, tooltipData, axes, categories) {
      var hoveredSeries = this.renderHoveredSeriesModel(seriesModels);
      return this.eventDetectType === 'grouped' ? responders_makeRectResponderModel(this.rect, this.isBar ? axes.yAxis : axes.xAxis, categories, !this.isBar) : hoveredSeries.map(function (m, index) {
        return boxSeries_objectSpread(boxSeries_objectSpread({}, m), {}, {
          data: tooltipData[index]
        });
      });
    }
  }, {
    key: "makeTooltipRectMap",
    value: function makeTooltipRectMap(seriesModels, tooltipDataArr) {
      return seriesModels.reduce(function (acc, cur, dataIndex) {
        var index = cur.index;

        var tooltipModel = boxSeries_objectSpread(boxSeries_objectSpread({}, cur), {}, {
          data: tooltipDataArr[dataIndex]
        });

        if (!acc[index]) {
          acc[index] = [];
        }

        acc[index].push(tooltipModel);
        return acc;
      }, []);
    }
  }, {
    key: "renderClipRectAreaModel",
    value: function renderClipRectAreaModel() {
      return {
        type: 'clipRectArea',
        x: 0,
        y: 0,
        width: this.rect.width,
        height: this.rect.height
      };
    }
  }, {
    key: "initClipRect",
    value: function initClipRect(clipRect) {
      return {
        type: 'clipRectArea',
        width: this.isBar ? 0 : clipRect.width,
        height: this.isBar ? clipRect.height : 0,
        x: this.isBar ? 0 : clipRect.x,
        y: this.isBar ? clipRect.y : 0
      };
    }
  }, {
    key: "renderSeriesModel",
    value: function renderSeriesModel(seriesData, renderOptions) {
      var _this4 = this;

      var tickDistance = renderOptions.tickDistance,
          diverging = renderOptions.diverging;
      var seriesLength = seriesData.length;
      var validDiverging = diverging && seriesData.length === 2;
      var columnWidth = this.getColumnWidth(renderOptions, seriesLength, validDiverging);
      var seriesModels = [];
      var padding = (tickDistance - columnWidth * (validDiverging ? 1 : seriesLength)) / 2;
      seriesData.forEach(function (_ref4, seriesIndex) {
        var data = _ref4.data,
            seriesColor = _ref4.color,
            name = _ref4.name;
        var seriesPos = (diverging ? 0 : seriesIndex) * columnWidth + padding;
        var isLBSideWithDiverging = diverging && isLeftBottomSide(seriesIndex);
        _this4.isRangeData = isRangeData(data);
        data.forEach(function (value, index) {
          var dataStart = seriesPos + index * tickDistance;

          var barLength = _this4.makeBarLength(value, renderOptions);

          var color = _this4.getSeriesColor(name, seriesColor);

          if (isNumber(barLength)) {
            var startPosition = _this4.getStartPosition(barLength, value, renderOptions, isLBSideWithDiverging);

            seriesModels.push(boxSeries_objectSpread(boxSeries_objectSpread({
              type: 'rect',
              color: color,
              value: value
            }, _this4.getAdjustedRect(dataStart, startPosition, barLength, columnWidth)), {}, {
              name: name,
              index: index
            }));
          }
        });
      });
      return seriesModels;
    }
  }, {
    key: "renderHoveredSeriesModel",
    value: function renderHoveredSeriesModel(seriesModel) {
      var _this5 = this;

      return seriesModel.map(function (data) {
        return _this5.makeHoveredSeriesModel(data);
      });
    }
  }, {
    key: "makeHoveredSeriesModel",
    value: function makeHoveredSeriesModel(data) {
      var _ref5 = data,
          x = _ref5.x,
          y = _ref5.y,
          width = _ref5.width,
          height = _ref5.height,
          color = _ref5.color,
          index = _ref5.index;
      return {
        type: 'rect',
        color: getRGBA(color, 1),
        x: x,
        y: y,
        width: width,
        height: height,
        index: index
      };
    }
  }, {
    key: "getRectModelsFromRectResponders",
    value: function getRectModelsFromRectResponders(responders) {
      var _this$tooltipRectMap;

      if (!responders.length) {
        return [];
      }

      return (_this$tooltipRectMap = this.tooltipRectMap[responders[0].index]) !== null && _this$tooltipRectMap !== void 0 ? _this$tooltipRectMap : [];
    }
  }, {
    key: "getGroupedRect",
    value: function getGroupedRect(responders, type) {
      var rectModels = this.getRectModelsFromRectResponders(responders);
      var _ref6 = this.theme[type].groupedRect,
          color = _ref6.color,
          opacity = _ref6.opacity;
      return rectModels.length ? responders.map(function (m) {
        return boxSeries_objectSpread(boxSeries_objectSpread({}, m), {}, {
          color: getRGBA(color, opacity)
        });
      }) : [];
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var rectModels = this.getRectModelsFromRectResponders(responders);
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getGroupedRect(responders, 'hover'),
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = rectModels;
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref7) {
      var responders = _ref7.responders;

      if (this.eventDetectType === 'grouped') {
        this.onMousemoveGroupedType(responders);
      } else {
        this.eventBus.emit('renderHoveredSeries', {
          models: this.getRespondersWithTheme(responders, 'hover'),
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.activatedResponders = responders;
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData(seriesData, renderOptions, categories) {
      var _this6 = this;

      var tooltipData = [];
      seriesData.forEach(function (_ref8) {
        var data = _ref8.data,
            name = _ref8.name,
            color = _ref8.color;
        data.forEach(function (value, dataIndex) {
          var barLength = _this6.makeBarLength(value, renderOptions);

          if (isNumber(barLength)) {
            tooltipData.push({
              label: name,
              color: color,
              value: _this6.getTooltipValue(value),
              category: categories.length ? categories[dataIndex] : ''
            });
          }
        });
      });
      return tooltipData;
    }
  }, {
    key: "getTooltipValue",
    value: function getTooltipValue(value) {
      return isRangeValue(value) ? "".concat(value[0], " ~ ").concat(value[1]) : value;
    }
  }, {
    key: "getBasePosition",
    value: function getBasePosition(_ref9) {
      var labels = _ref9.labels,
          tickCount = _ref9.tickCount,
          zeroPosition = _ref9.zeroPosition;
      var valueLabels = this.isBar ? labels : boxSeries_toConsumableArray(labels).reverse();
      var tickPositions = makeTickPixelPositions(this.getOffsetSize(), tickCount);
      var seriesDirection = this.getSeriesDirection(valueLabels);
      return zeroPosition ? zeroPosition : this.getTickPositionIfNotZero(tickPositions, seriesDirection);
    }
  }, {
    key: "getDivergingBasePosition",
    value: function getDivergingBasePosition(centerYAxis) {
      var leftZeroPosition, rightZeroPosition;

      if (centerYAxis) {
        leftZeroPosition = centerYAxis.xAxisHalfSize;
        rightZeroPosition = centerYAxis.secondStartX;
      } else {
        var divergingZeroPosition = this.getOffsetSize() / 2;
        leftZeroPosition = rightZeroPosition = divergingZeroPosition;
      }

      return [leftZeroPosition, rightZeroPosition];
    }
  }, {
    key: "getOffsetSize",
    value: function getOffsetSize() {
      return this.rect[this.offsetSizeKey];
    }
  }, {
    key: "getValueRatio",
    value: function getValueRatio(min, max, size) {
      return size / (max - min);
    }
  }, {
    key: "makeBarLength",
    value: function makeBarLength(value, renderOptions) {
      if (isNull(value)) {
        return null;
      }

      var min = renderOptions.min,
          max = renderOptions.max,
          ratio = renderOptions.ratio;
      var calculatedValue = calculateBarLength(value, min, max);
      return Math.max(this.getBarLength(calculatedValue, ratio), 2);
    }
  }, {
    key: "getBarLength",
    value: function getBarLength(value, ratio) {
      return value < 0 ? Math.abs(value) * ratio : value * ratio;
    }
  }, {
    key: "getStartPositionWithRangeValue",
    value: function getStartPositionWithRangeValue(value, barLength, renderOptions) {
      var min = renderOptions.min,
          ratio = renderOptions.ratio;

      var _value2 = boxSeries_slicedToArray(value, 1),
          start = _value2[0];

      if (start < min) {
        start = min;
      }

      var startPosition = (start - min) * ratio;
      return this.isBar ? startPosition : this.getOffsetSize() - startPosition - barLength;
    }
  }, {
    key: "getStartPosition",
    value: function getStartPosition(barLength, value, renderOptions, isLBSideWithDiverging) {
      var diverging = renderOptions.diverging,
          seriesDirection = renderOptions.seriesDirection;
      var startPos;

      if (isRangeValue(value)) {
        startPos = this.getStartPositionWithRangeValue(value, barLength, renderOptions);
      } else if (diverging) {
        startPos = isLBSideWithDiverging ? this.getStartPosOnLeftBottomSide(barLength, diverging) : this.getStartPosOnRightTopSide(barLength, diverging);
      } else if (seriesDirection === SeriesDirection.POSITIVE) {
        startPos = this.getStartPosOnRightTopSide(barLength);
      } else if (seriesDirection === SeriesDirection.NEGATIVE) {
        startPos = this.getStartPosOnLeftBottomSide(barLength);
      } else {
        startPos = value < 0 ? this.getStartPosOnLeftBottomSide(barLength) : this.getStartPosOnRightTopSide(barLength);
      }

      return startPos;
    }
  }, {
    key: "getStartPosOnRightTopSide",
    value: function getStartPosOnRightTopSide(barLength) {
      var diverging = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var pos;

      if (diverging) {
        pos = this.isBar ? this.rightBasePosition : this.rightBasePosition - barLength;
      } else {
        pos = this.isBar ? this.basePosition : this.basePosition - barLength;
      }

      return pos;
    }
  }, {
    key: "getStartPosOnLeftBottomSide",
    value: function getStartPosOnLeftBottomSide(barLength) {
      var diverging = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var pos;

      if (diverging) {
        pos = this.isBar ? this.leftBasePosition - barLength : this.leftBasePosition;
      } else {
        pos = this.isBar ? this.basePosition - barLength : this.basePosition;
      }

      return pos;
    }
  }, {
    key: "getAdjustedRect",
    value: function getAdjustedRect(seriesPosition, dataPosition, barLength, columnWidth) {
      return {
        x: this.isBar ? dataPosition : seriesPosition,
        y: this.isBar ? seriesPosition : dataPosition,
        width: this.isBar ? barLength : columnWidth,
        height: this.isBar ? columnWidth : barLength
      };
    }
  }, {
    key: "getColumnWidth",
    value: function getColumnWidth(renderOptions, seriesLength) {
      var validDiverging = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tickDistance = renderOptions.tickDistance,
          defaultPadding = renderOptions.defaultPadding;
      seriesLength = validDiverging ? 1 : seriesLength;
      var themeBarWidth = this.theme.barWidth;
      return themeBarWidth ? calculateSizeWithPercentString(tickDistance, themeBarWidth) : (tickDistance - defaultPadding * 2) / seriesLength;
    }
  }, {
    key: "getSeriesDirection",
    value: function getSeriesDirection(labels) {
      var result = SeriesDirection.BOTH;

      if (hasPositiveOnly(labels)) {
        result = SeriesDirection.POSITIVE;
      } else if (hasNegativeOnly(labels)) {
        result = SeriesDirection.NEGATIVE;
      }

      return result;
    }
  }, {
    key: "getTickPositionIfNotZero",
    value: function getTickPositionIfNotZero(tickPositions, direction) {
      var firstTickPosition = Number(first(tickPositions));
      var lastTickPosition = Number(last(tickPositions));
      var tickPos = 0;

      if (direction === SeriesDirection.POSITIVE) {
        tickPos = this.isBar ? firstTickPosition : lastTickPosition;
      } else if (direction === SeriesDirection.NEGATIVE) {
        tickPos = this.isBar ? lastTickPosition : firstTickPosition;
      }

      return tickPos;
    }
  }, {
    key: "makeDataLabel",
    value: function makeDataLabel(rect, centerYAxis) {
      return boxSeries_objectSpread(boxSeries_objectSpread({}, rect), {}, {
        direction: this.getDataLabelDirection(rect, centerYAxis),
        plot: {
          x: 0,
          y: 0,
          size: this.getOffsetSize()
        },
        theme: omit(this.theme.dataLabels, 'stackTotal')
      });
    }
  }, {
    key: "makeDataLabelRangeData",
    value: function makeDataLabelRangeData(rect) {
      var _this7 = this;

      return rect.value.reduce(function (acc, value, index) {
        return [].concat(boxSeries_toConsumableArray(acc), [boxSeries_objectSpread(boxSeries_objectSpread({}, rect), {}, {
          value: value,
          direction: _this7.getDataLabelRangeDataDirection(index % 2 === 0),
          plot: {
            x: 0,
            y: 0,
            size: _this7.getOffsetSize()
          },
          theme: omit(_this7.theme.dataLabels, 'stackTotal')
        })]);
      }, []);
    }
  }, {
    key: "getDataLabelRangeDataDirection",
    value: function getDataLabelRangeDataDirection(isEven) {
      var direction;

      if (this.isBar) {
        direction = isEven ? 'left' : 'right';
      } else {
        direction = isEven ? 'bottom' : 'top';
      }

      return direction;
    }
  }, {
    key: "getDataLabelDirection",
    value: function getDataLabelDirection(rect, centerYAxis) {
      var direction;

      if (this.isBar) {
        var basePos = centerYAxis ? this.leftBasePosition : this.basePosition;
        direction = rect.x < basePos ? 'left' : 'right';
      } else {
        direction = rect.y >= this.basePosition ? 'bottom' : 'top';
      }

      return direction;
    }
  }, {
    key: "getOffsetSizeWithDiverging",
    value: function getOffsetSizeWithDiverging(centerYAxis) {
      return centerYAxis ? centerYAxis.xAxisHalfSize : this.getOffsetSize() / 2;
    }
  }, {
    key: "onClick",
    value: function onClick(_ref10) {
      var responders = _ref10.responders;

      if (this.selectable) {
        var models;

        if (this.eventDetectType === 'grouped') {
          models = [].concat(boxSeries_toConsumableArray(this.getGroupedRect(responders, 'select')), boxSeries_toConsumableArray(this.getRectModelsFromRectResponders(responders)));
        } else {
          models = this.getRespondersWithTheme(responders, 'select');
        }

        this.eventBus.emit('renderSelectedSeries', {
          models: models,
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _this$theme$type = this.theme[type],
          color = _this$theme$type.color,
          borderColor = _this$theme$type.borderColor,
          borderWidth = _this$theme$type.borderWidth,
          shadowBlur = _this$theme$type.shadowBlur,
          shadowColor = _this$theme$type.shadowColor,
          shadowOffsetX = _this$theme$type.shadowOffsetX,
          shadowOffsetY = _this$theme$type.shadowOffsetY;
      return responders.map(function (model) {
        return boxSeries_objectSpread(boxSeries_objectSpread({}, model), {}, {
          color: color !== null && color !== void 0 ? color : model.color,
          thickness: borderWidth,
          borderColor: borderColor,
          style: [{
            shadowBlur: shadowBlur,
            shadowColor: shadowColor,
            shadowOffsetX: shadowOffsetX,
            shadowOffsetY: shadowOffsetY
          }]
        });
      });
    }
  }, {
    key: "getSeriesColor",
    value: function getSeriesColor(name, color) {
      var _this$theme = this.theme,
          select = _this$theme.select,
          areaOpacity = _this$theme.areaOpacity;
      var active = this.activeSeriesMap[name];
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);
    }
  }]);

  return BoxSeries;
}(component_Component);


// CONCATENATED MODULE: ./src/component/boxStackSeries.ts



























function boxStackSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { boxStackSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { boxStackSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return boxStackSeries_typeof(obj); }

function boxStackSeries_toConsumableArray(arr) { return boxStackSeries_arrayWithoutHoles(arr) || boxStackSeries_iterableToArray(arr) || boxStackSeries_unsupportedIterableToArray(arr) || boxStackSeries_nonIterableSpread(); }

function boxStackSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxStackSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function boxStackSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return boxStackSeries_arrayLikeToArray(arr); }

function boxStackSeries_slicedToArray(arr, i) { return boxStackSeries_arrayWithHoles(arr) || boxStackSeries_iterableToArrayLimit(arr, i) || boxStackSeries_unsupportedIterableToArray(arr, i) || boxStackSeries_nonIterableRest(); }

function boxStackSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxStackSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return boxStackSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return boxStackSeries_arrayLikeToArray(o, minLen); }

function boxStackSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function boxStackSeries_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function boxStackSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function boxStackSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function boxStackSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function boxStackSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) boxStackSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) boxStackSeries_defineProperties(Constructor, staticProps); return Constructor; }

function boxStackSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) boxStackSeries_setPrototypeOf(subClass, superClass); }

function boxStackSeries_setPrototypeOf(o, p) { boxStackSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return boxStackSeries_setPrototypeOf(o, p); }

function boxStackSeries_createSuper(Derived) { var hasNativeReflectConstruct = boxStackSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = boxStackSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = boxStackSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return boxStackSeries_possibleConstructorReturn(this, result); }; }

function boxStackSeries_possibleConstructorReturn(self, call) { if (call && (boxStackSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return boxStackSeries_assertThisInitialized(self); }

function boxStackSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function boxStackSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function boxStackSeries_getPrototypeOf(o) { boxStackSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return boxStackSeries_getPrototypeOf(o); }

function boxStackSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function boxStackSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { boxStackSeries_ownKeys(Object(source), true).forEach(function (key) { boxStackSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { boxStackSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function boxStackSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }














function boxStackSeries_calibrateDrawingValue(values, seriesIndex, renderOptions) {
  var stack = renderOptions.stack,
      min = renderOptions.min,
      max = renderOptions.max;
  return isPercentStack(stack) ? values[seriesIndex] : calibrateBoxStackDrawingValue(values, seriesIndex, min, max);
}

function getDivisorForPercent(total, scaleType) {
  var positive = total.positive,
      negative = total.negative;
  var divisor = positive + Math.abs(negative);

  if (includes(['dualPercentStack', 'divergingPercentStack'], scaleType)) {
    divisor *= 2;
  }

  return divisor;
}

function getDirectionKeys(seriesDirection) {
  var result = ['positive', 'negative'];

  if (seriesDirection === SeriesDirection.POSITIVE) {
    result = ['positive'];
  } else if (seriesDirection === SeriesDirection.NEGATIVE) {
    result = ['negative'];
  }

  return result;
}

function getStackSeriesDataInViewRange(stackSeriesData, viewRange) {
  if (!viewRange) {
    return stackSeriesData;
  }

  var stackData = Array.isArray(stackSeriesData.stackData) ? getDataInRange(stackSeriesData.stackData, viewRange) : boxStackSeries_objectSpread({}, Object.keys(stackSeriesData.stackData).reduce(function (acc, name) {
    return boxStackSeries_objectSpread(boxStackSeries_objectSpread({}, acc), {}, boxStackSeries_defineProperty({}, name, getDataInRange(stackSeriesData.stackData[name], viewRange)));
  }, {}));
  var data = stackSeriesData.data.map(function (seriesDatum) {
    return boxStackSeries_objectSpread(boxStackSeries_objectSpread({}, seriesDatum), {}, {
      data: getDataInRange(seriesDatum.data, viewRange)
    });
  });
  return boxStackSeries_objectSpread(boxStackSeries_objectSpread({}, stackSeriesData), {}, {
    data: data,
    stackData: stackData
  });
}

var boxStackSeries_BoxStackSeries = /*#__PURE__*/function (_BoxSeries) {
  boxStackSeries_inherits(BoxStackSeries, _BoxSeries);

  var _super = boxStackSeries_createSuper(BoxStackSeries);

  function BoxStackSeries() {
    var _this;

    boxStackSeries_classCallCheck(this, BoxStackSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    boxStackSeries_defineProperty(boxStackSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var index = _ref.index,
          seriesIndex = _ref.seriesIndex,
          state = _ref.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var stackSeries = state.stackSeries;
      var stackSeriesData = stackSeries[_this.name];
      var name = stackSeriesData.data[seriesIndex].name;

      var model = _this.tooltipRectMap[index].find(function (_ref2) {
        var seriesName = _ref2.name;
        return seriesName === name;
      });

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getRespondersWithTheme([model], 'select'),
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  boxStackSeries_createClass(BoxStackSeries, [{
    key: "initialize",
    value: function initialize(_ref3) {
      var name = _ref3.name,
          stackChart = _ref3.stackChart;
      this.initializeFields(name);

      if (stackChart) {
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
      }
    }
  }, {
    key: "render",
    value: function render(chartState, computed) {
      var _ref4, _options$series;

      var layout = chartState.layout,
          seriesData = chartState.series,
          axes = chartState.axes,
          stackSeries = chartState.stackSeries,
          legend = chartState.legend,
          theme = chartState.theme,
          scale = chartState.scale;
      var viewRange = computed.viewRange;
      this.isShow = !!stackSeries[this.name];

      if (!this.isShow) {
        return;
      }

      var categories = (_ref4 = chartState.categories) !== null && _ref4 !== void 0 ? _ref4 : [];
      var options = this.getOptions(chartState.options);
      this.setEventDetectType(seriesData, options);
      this.theme = theme.series[this.name];
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var stackSeriesData = getStackSeriesDataInViewRange(stackSeries[this.name], viewRange);
      var tickDistance = axes[this.labelAxis].tickDistance;
      var diverging = !!((_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.diverging);

      var _this$getScaleData = this.getScaleData(scale),
          limit = _this$getScaleData.limit,
          stepSize = _this$getScaleData.stepSize;

      var labels = makeLabelsFromLimit(limit, stepSize);

      var _getLimitOnAxis = getLimitOnAxis(labels),
          min = _getLimitOnAxis.min,
          max = _getLimitOnAxis.max;

      var stack = stackSeriesData.stack,
          scaleType = stackSeriesData.scaleType;
      this.basePosition = this.getBasePosition(axes[this.valueAxis]);
      var offsetSize = this.getOffsetSize();
      var centerYAxis = axes.centerYAxis;

      if (diverging) {
        var _this$getDivergingBas = this.getDivergingBasePosition(centerYAxis),
            _this$getDivergingBas2 = boxStackSeries_slicedToArray(_this$getDivergingBas, 2),
            left = _this$getDivergingBas2[0],
            right = _this$getDivergingBas2[1];

        this.basePosition = this.getOffsetSize() / 2;
        this.leftBasePosition = left;
        this.rightBasePosition = right;
        offsetSize = this.getOffsetSizeWithDiverging(centerYAxis);
      }

      var renderOptions = {
        stack: stack,
        scaleType: scaleType,
        tickDistance: tickDistance,
        min: min,
        max: max,
        diverging: diverging,
        hasNegativeValue: hasNegative(labels),
        seriesDirection: this.getSeriesDirection(labels),
        defaultPadding: getBoxTypeSeriesPadding(tickDistance),
        offsetSize: offsetSize,
        centerYAxis: centerYAxis
      };

      var _this$renderStackSeri = this.renderStackSeriesModel(stackSeriesData, renderOptions),
          series = _this$renderStackSeri.series,
          connector = _this$renderStackSeri.connector;

      var clipRect = this.renderClipRectAreaModel();
      var tooltipData = this.getTooltipData(stackSeriesData, categories);
      this.models = {
        clipRect: [clipRect],
        series: series,
        connector: connector
      };

      if (!this.drawModels) {
        this.drawModels = {
          clipRect: [this.initClipRect(clipRect)],
          series: deepCopyArray(series),
          connector: deepCopyArray(connector)
        };
      }

      if (getDataLabelsOptions(options, this.name).visible) {
        var dataLabelData = this.getDataLabels(series, renderOptions);
        var stackTotalData = this.getTotalDataLabels(stackSeriesData, renderOptions);
        this.renderDataLabels([].concat(boxStackSeries_toConsumableArray(dataLabelData), boxStackSeries_toConsumableArray(stackTotalData)));
      }

      this.tooltipRectMap = this.makeTooltipRectMap(series, tooltipData);
      this.responders = this.getBoxSeriesResponders(series, tooltipData, axes, categories);
    }
  }, {
    key: "renderStackSeriesModel",
    value: function renderStackSeriesModel(seriesData, renderOptions) {
      var stackData = seriesData.stackData;
      return isGroupStack(stackData) ? this.makeStackGroupSeriesModel(seriesData, renderOptions) : this.makeStackSeriesModel(stackData, renderOptions, seriesData.data);
    }
  }, {
    key: "makeStackSeriesModel",
    value: function makeStackSeriesModel(stackData, renderOptions, seriesRawData) {
      var _this2 = this;

      var stackGroupCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var stackGroupIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var seriesModels = [];
      var columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);
      var diverging = renderOptions.diverging;
      var isLBSideWithDiverging = diverging && isLeftBottomSide(stackGroupIndex);
      stackData.forEach(function (_ref5, dataIndex) {
        var values = _ref5.values,
            total = _ref5.total;

        var seriesPos = _this2.getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount);

        var ratio = _this2.getStackValueRatio(total, renderOptions);

        values.forEach(function (value, seriesIndex) {
          var _this2$getStackRectIn = _this2.getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging),
              barLength = _this2$getStackRectIn.barLength,
              dataPosition = _this2$getStackRectIn.dataPosition;

          var name = seriesRawData[seriesIndex].name;
          var active = _this2.activeSeriesMap[name];
          var color = getRGBA(seriesRawData[seriesIndex].color, active ? 1 : 0.2);
          seriesModels.push(boxStackSeries_objectSpread(boxStackSeries_objectSpread({
            type: 'rect',
            color: color,
            name: name,
            value: value
          }, _this2.getAdjustedRect(seriesPos, dataPosition, barLength !== null && barLength !== void 0 ? barLength : 0, columnWidth)), {}, {
            index: dataIndex
          }));
        });
      });
      return {
        series: seriesModels,
        connector: this.makeConnectorSeriesModel(stackData, renderOptions, stackGroupCount, stackGroupIndex)
      };
    }
  }, {
    key: "makeStackGroupSeriesModel",
    value: function makeStackGroupSeriesModel(stackSeries, renderOptions) {
      var _this3 = this;

      var stack = renderOptions.stack;
      var stackGroupData = stackSeries.stackData;
      var seriesRawData = stackSeries.data;
      var stackGroupIds = Object.keys(stackGroupData);
      var seriesModels = [];
      var connectorModels = [];
      stackGroupIds.forEach(function (groupId, groupIndex) {
        var filtered = seriesRawData.filter(function (_ref6) {
          var stackGroup = _ref6.stackGroup;
          return stackGroup === groupId;
        });

        var _this3$makeStackSerie = _this3.makeStackSeriesModel(stackGroupData[groupId], renderOptions, filtered, stackGroupIds.length, groupIndex),
            series = _this3$makeStackSerie.series,
            connector = _this3$makeStackSerie.connector;

        seriesModels = [].concat(boxStackSeries_toConsumableArray(seriesModels), boxStackSeries_toConsumableArray(series));

        if (stack.connector) {
          connectorModels = [].concat(boxStackSeries_toConsumableArray(connectorModels), boxStackSeries_toConsumableArray(connector));
        }
      });
      return {
        series: seriesModels,
        connector: connectorModels
      };
    }
  }, {
    key: "makeConnectorSeriesModel",
    value: function makeConnectorSeriesModel(stackData, renderOptions) {
      var _this4 = this;

      var stackGroupCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var stackGroupIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var diverging = renderOptions.diverging,
          connector = renderOptions.stack.connector;

      if (!connector) {
        return [];
      }

      var columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);
      var isLBSideWithDiverging = diverging && isLeftBottomSide(stackGroupIndex);
      var connectorPoints = [];
      stackData.forEach(function (_ref7, index) {
        var values = _ref7.values,
            total = _ref7.total;

        var seriesPos = _this4.getSeriesPosition(renderOptions, columnWidth, index, stackGroupIndex, stackGroupCount);

        var points = [];

        var ratio = _this4.getStackValueRatio(total, renderOptions);

        values.forEach(function (value, seriesIndex) {
          var _this4$getStackRectIn = _this4.getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging),
              barLength = _this4$getStackRectIn.barLength,
              dataPosition = _this4$getStackRectIn.dataPosition;

          var _this4$getAdjustedRec = _this4.getAdjustedRect(seriesPos, dataPosition, barLength, columnWidth),
              x = _this4$getAdjustedRec.x,
              y = _this4$getAdjustedRec.y;

          var xPos = !isLBSideWithDiverging && _this4.isBar ? x + barLength : x;
          var yPos = isLBSideWithDiverging && !_this4.isBar ? y + barLength : y;
          points.push({
            x: xPos,
            y: yPos
          });
        });
        connectorPoints.push(points);
      });
      return this.makeConnectorModel(connectorPoints, connector, columnWidth);
    }
  }, {
    key: "getTooltipData",
    value: function getTooltipData(seriesData, categories) {
      var seriesRawData = seriesData.data;
      var stackData = seriesData.stackData;
      var colors = seriesRawData.map(function (_ref8) {
        var color = _ref8.color;
        return color;
      });
      return isGroupStack(stackData) ? this.makeGroupStackTooltipData(seriesRawData, stackData, categories) : this.makeStackTooltipData(seriesRawData, stackData, colors, categories);
    }
  }, {
    key: "makeGroupStackTooltipData",
    value: function makeGroupStackTooltipData(seriesRawData, stackData, categories) {
      var _this5 = this;

      return Object.keys(stackData).flatMap(function (groupId) {
        var rawDataWithSameGroupId = seriesRawData.filter(function (_ref9) {
          var stackGroup = _ref9.stackGroup;
          return stackGroup === groupId;
        });
        var colors = rawDataWithSameGroupId.map(function (_ref10) {
          var color = _ref10.color;
          return color;
        });
        return _this5.makeStackTooltipData(rawDataWithSameGroupId, stackData[groupId], colors, categories);
      });
    }
  }, {
    key: "makeStackTooltipData",
    value: function makeStackTooltipData(seriesRawData, stackData, colors, categories) {
      var tooltipData = [];
      stackData.forEach(function (_ref11, dataIndex) {
        var values = _ref11.values;
        values.forEach(function (value, seriesIndex) {
          tooltipData.push({
            label: seriesRawData[seriesIndex].name,
            color: colors[seriesIndex],
            value: value,
            category: categories.length ? categories[dataIndex] : ''
          });
        });
      });
      return tooltipData;
    }
  }, {
    key: "makeConnectorModel",
    value: function makeConnectorModel(pointsForConnector, connector, columnWidth) {
      var _this6 = this;

      if (!connector || !pointsForConnector.length) {
        return [];
      }

      var _this$theme$connector = this.theme.connector,
          color = _this$theme$connector.color,
          lineWidth = _this$theme$connector.lineWidth,
          dashSegments = _this$theme$connector.dashSegments;
      var connectorModels = [];
      var seriesDataCount = pointsForConnector.length;
      var seriesCount = pointsForConnector[0].length;

      var _loop = function _loop(seriesIndex) {
        var points = [];

        for (var dataIndex = 0; dataIndex < seriesDataCount; dataIndex += 1) {
          points.push(pointsForConnector[dataIndex][seriesIndex]);
        }

        points.forEach(function (point, index) {
          var x = point.x,
              y = point.y;

          if (index < points.length - 1) {
            var _points = points[index + 1],
                nextX = _points.x,
                nextY = _points.y;
            connectorModels.push({
              type: 'line',
              x: _this6.isBar ? x : x + columnWidth,
              y: _this6.isBar ? y + columnWidth : y,
              x2: nextX,
              y2: nextY,
              dashSegments: dashSegments,
              strokeStyle: color,
              lineWidth: lineWidth
            });
          }
        });
      };

      for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex += 1) {
        _loop(seriesIndex);
      }

      return connectorModels;
    }
  }, {
    key: "getStackValueRatio",
    value: function getStackValueRatio(total, renderOptions) {
      var stackType = renderOptions.stack.type,
          scaleType = renderOptions.scaleType,
          min = renderOptions.min,
          max = renderOptions.max,
          offsetSize = renderOptions.offsetSize;

      if (stackType === 'percent') {
        return offsetSize / getDivisorForPercent(total, scaleType);
      }

      return this.getValueRatio(min, max, offsetSize);
    }
  }, {
    key: "getStackBarLength",
    value: function getStackBarLength(values, seriesIndex, ratio, renderOptions) {
      var value = boxStackSeries_calibrateDrawingValue(values, seriesIndex, renderOptions);
      return isNumber(value) ? this.getBarLength(value, ratio) : null;
    }
  }, {
    key: "getStackColumnWidth",
    value: function getStackColumnWidth(renderOptions, stackGroupCount) {
      var tickDistance = renderOptions.tickDistance,
          diverging = renderOptions.diverging,
          defaultPadding = renderOptions.defaultPadding;
      var divisor = diverging ? 1 : stackGroupCount;
      var themeBarWidth = this.theme.barWidth;
      return themeBarWidth ? calculateSizeWithPercentString(tickDistance, themeBarWidth) : (tickDistance - defaultPadding * 2) / divisor;
    }
  }, {
    key: "getSeriesPosition",
    value: function getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount) {
      var tickDistance = renderOptions.tickDistance,
          diverging = renderOptions.diverging;
      var groupIndex = diverging ? 0 : stackGroupIndex;
      var groupCount = diverging ? 1 : stackGroupCount;
      var padding = (tickDistance - columnWidth * groupCount) / 2;
      return dataIndex * tickDistance + padding + columnWidth * groupIndex;
    }
  }, {
    key: "getStackStartPosition",
    value: function getStackStartPosition(values, currentIndex, ratio, renderOptions, isLBSideWithDiverging) {
      var stack = renderOptions.stack,
          diverging = renderOptions.diverging,
          seriesDirection = renderOptions.seriesDirection;
      var startPos;

      if (diverging) {
        startPos = isLBSideWithDiverging ? this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) : this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);
      } else if (isPercentStack(stack)) {
        startPos = this.calcStartPositionWithPercent(values, currentIndex, ratio);
      } else if (seriesDirection === SeriesDirection.POSITIVE) {
        startPos = this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);
      } else if (seriesDirection === SeriesDirection.NEGATIVE) {
        startPos = this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio);
      } else {
        startPos = this.calcStartPositionWithStack(values, currentIndex, renderOptions, ratio);
      }

      return startPos;
    }
  }, {
    key: "calcStartPosOnLeftBottomSide",
    value: function calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) {
      var min = renderOptions.min,
          max = renderOptions.max,
          diverging = renderOptions.diverging;
      var basePosition = diverging ? this.leftBasePosition : this.basePosition;
      var totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
      var totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);
      var collideEdge = totalOfValues < min;
      var usingValue = this.isBar ? totalOfValues : totalOfIndexBefore;
      var result = max < 0 ? Math.min(usingValue - max, 0) : usingValue;
      var pos;

      if (this.isBar) {
        pos = collideEdge ? 0 : basePosition - Math.abs(result) * ratio;
      } else {
        pos = basePosition + Math.abs(result) * ratio;
      }

      return pos;
    }
  }, {
    key: "calcStartPosOnRightTopSide",
    value: function calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio) {
      var min = renderOptions.min,
          max = renderOptions.max,
          diverging = renderOptions.diverging;
      var basePosition = diverging ? this.rightBasePosition : this.basePosition;
      var totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
      var totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);
      var collideEdge = totalOfValues > max;
      var usingValue = this.isBar ? totalOfIndexBefore : totalOfValues;
      var result = min > 0 ? Math.max(usingValue - min, 0) : usingValue;
      var barLength = result * ratio;
      var pos;

      if (this.isBar) {
        pos = basePosition + barLength;
      } else {
        pos = collideEdge ? 0 : basePosition - barLength;
      }

      return pos;
    }
  }, {
    key: "calcStartPositionWithStack",
    value: function calcStartPositionWithStack(values, currentIndex, renderOptions, ratio) {
      return values[currentIndex] < 0 ? this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) : this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);
    }
  }, {
    key: "calcStartPositionWithPercent",
    value: function calcStartPositionWithPercent(values, currentIndex, ratio) {
      var basePosition = this.basePosition;
      var totalPrevValues = sumValuesBeforeIndex(values, currentIndex, this.isBar ? values[currentIndex] < 0 : values[currentIndex] > 0);
      return this.isBar ? totalPrevValues * ratio + basePosition : basePosition - totalPrevValues * ratio;
    }
  }, {
    key: "getStackRectInfo",
    value: function getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging) {
      var barLength = this.getStackBarLength(values, seriesIndex, ratio, renderOptions);
      var dataPosition = this.getStackStartPosition(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging);
      return {
        barLength: barLength,
        dataPosition: dataPosition
      };
    }
  }, {
    key: "getDataLabels",
    value: function getDataLabels(seriesModels, renderOptions) {
      var _this7 = this;

      return seriesModels.map(function (data) {
        return _this7.makeDataLabel(data, renderOptions.centerYAxis);
      });
    }
  }, {
    key: "getTotalDataLabels",
    value: function getTotalDataLabels(seriesData, renderOptions) {
      var stackData = seriesData.stackData,
          stack = seriesData.stack;

      if (isPercentStack(stack)) {
        return [];
      }

      return isGroupStack(stackData) ? this.makeGroupTotalDataLabels(seriesData, renderOptions) : this.makeTotalDataLabels(stackData, renderOptions);
    }
  }, {
    key: "makeGroupTotalDataLabels",
    value: function makeGroupTotalDataLabels(stackSeries, renderOptions) {
      var _this8 = this;

      var dataLabels = [];
      var stackGroupData = stackSeries.stackData;
      var stackGroupIds = Object.keys(stackGroupData);
      stackGroupIds.forEach(function (groupId, groupIndex) {
        var totalDataLabels = _this8.makeTotalDataLabels(stackGroupData[groupId], renderOptions, stackGroupIds.length, groupIndex);

        dataLabels = [].concat(boxStackSeries_toConsumableArray(dataLabels), boxStackSeries_toConsumableArray(totalDataLabels));
      });
      return dataLabels;
    }
  }, {
    key: "makeTotalDataLabels",
    value: function makeTotalDataLabels(stackData, renderOptions) {
      var _this9 = this;

      var stackGroupCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var stackGroupIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var dataLabels = [];
      var min = renderOptions.min,
          max = renderOptions.max,
          seriesDirection = renderOptions.seriesDirection,
          diverging = renderOptions.diverging,
          centerYAxis = renderOptions.centerYAxis;
      var columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);
      stackData.forEach(function (data, dataIndex) {
        var total = data.total;

        var seriesPos = _this9.getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount);

        var ratio = _this9.getStackValueRatio(total, renderOptions);

        var directionKeys = getDirectionKeys(seriesDirection);
        directionKeys.forEach(function (key) {
          var value = total[key];

          if (!value) {
            return;
          }

          var barLength = _this9.makeBarLength(value, {
            min: min,
            max: max,
            ratio: ratio
          });

          var dataPosition = _this9.getStartPosition(barLength, value, renderOptions, diverging && isLeftBottomSide(stackGroupIndex));

          var stackTotal = boxStackSeries_objectSpread({
            type: 'stackTotal',
            value: value,
            name: "totalLabel-".concat(key),
            theme: _this9.theme.dataLabels.stackTotal
          }, _this9.getAdjustedRect(seriesPos, dataPosition, barLength, columnWidth));

          dataLabels.push(_this9.makeTotalDataLabel(stackTotal, centerYAxis));
        });
      });
      return dataLabels;
    }
  }, {
    key: "makeTotalDataLabel",
    value: function makeTotalDataLabel(totalLabel, centerYAxis) {
      return boxStackSeries_objectSpread(boxStackSeries_objectSpread({}, totalLabel), {}, {
        direction: this.getDataLabelDirection(totalLabel, centerYAxis),
        plot: {
          x: 0,
          y: 0,
          size: this.getOffsetSize()
        }
      });
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var rectModels = this.getRectModelsFromRectResponders(responders);
      this.eventBus.emit('renderHoveredSeries', {
        models: [].concat(boxStackSeries_toConsumableArray(rectModels), boxStackSeries_toConsumableArray(this.getGroupedRect(responders, 'hover'))),
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = rectModels;
    }
  }]);

  return BoxStackSeries;
}(boxSeries_BoxSeries);


// CONCATENATED MODULE: ./src/component/zeroAxis.ts














function zeroAxis_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { zeroAxis_typeof = function _typeof(obj) { return typeof obj; }; } else { zeroAxis_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return zeroAxis_typeof(obj); }

function zeroAxis_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function zeroAxis_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function zeroAxis_createClass(Constructor, protoProps, staticProps) { if (protoProps) zeroAxis_defineProperties(Constructor.prototype, protoProps); if (staticProps) zeroAxis_defineProperties(Constructor, staticProps); return Constructor; }

function zeroAxis_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) zeroAxis_setPrototypeOf(subClass, superClass); }

function zeroAxis_setPrototypeOf(o, p) { zeroAxis_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return zeroAxis_setPrototypeOf(o, p); }

function zeroAxis_createSuper(Derived) { var hasNativeReflectConstruct = zeroAxis_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = zeroAxis_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = zeroAxis_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return zeroAxis_possibleConstructorReturn(this, result); }; }

function zeroAxis_possibleConstructorReturn(self, call) { if (call && (zeroAxis_typeof(call) === "object" || typeof call === "function")) { return call; } return zeroAxis_assertThisInitialized(self); }

function zeroAxis_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function zeroAxis_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function zeroAxis_getPrototypeOf(o) { zeroAxis_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return zeroAxis_getPrototypeOf(o); }

function zeroAxis_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var zeroAxis_ZeroAxis = /*#__PURE__*/function (_Component) {
  zeroAxis_inherits(ZeroAxis, _Component);

  var _super = zeroAxis_createSuper(ZeroAxis);

  function ZeroAxis() {
    var _this;

    zeroAxis_classCallCheck(this, ZeroAxis);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    zeroAxis_defineProperty(zeroAxis_assertThisInitialized(_this), "models", []);

    return _this;
  }

  zeroAxis_createClass(ZeroAxis, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'zeroAxis';
      this.name = 'zeroAxis';
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout,
          axes = _ref.axes,
          series = _ref.series,
          options = _ref.options;
      this.rect = layout.plot;
      var labelAxisOnYAxis = isLabelAxisOnYAxis(series, options);
      var valueAxisName = labelAxisOnYAxis ? 'xAxis' : 'yAxis';
      var _ref2 = axes[valueAxisName],
          zeroPosition = _ref2.zeroPosition;

      if (isNumber(zeroPosition)) {
        this.models = this.renderZeroModel(zeroPosition, labelAxisOnYAxis);
      }
    }
  }, {
    key: "renderZeroModel",
    value: function renderZeroModel(zeroPosition, vertical) {
      var zeroPixel = crispPixel(0);
      var position = crispPixel(zeroPosition);
      var model;

      if (vertical) {
        model = {
          type: 'line',
          x: position,
          y: zeroPixel,
          x2: position,
          y2: crispPixel(this.rect.height),
          strokeStyle: 'rgba(0, 0, 0, 0.5)'
        };
      } else {
        model = {
          type: 'line',
          x: zeroPixel,
          y: position,
          x2: crispPixel(this.rect.width),
          y2: position,
          strokeStyle: 'rgba(0, 0, 0, 0.5)'
        };
      }

      return [model];
    }
  }]);

  return ZeroAxis;
}(component_Component);


// CONCATENATED MODULE: ./src/component/axisUsingCenterY.ts
























function axisUsingCenterY_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { axisUsingCenterY_typeof = function _typeof(obj) { return typeof obj; }; } else { axisUsingCenterY_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return axisUsingCenterY_typeof(obj); }

function axisUsingCenterY_toConsumableArray(arr) { return axisUsingCenterY_arrayWithoutHoles(arr) || axisUsingCenterY_iterableToArray(arr) || axisUsingCenterY_unsupportedIterableToArray(arr) || axisUsingCenterY_nonIterableSpread(); }

function axisUsingCenterY_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function axisUsingCenterY_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return axisUsingCenterY_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return axisUsingCenterY_arrayLikeToArray(o, minLen); }

function axisUsingCenterY_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function axisUsingCenterY_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return axisUsingCenterY_arrayLikeToArray(arr); }

function axisUsingCenterY_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function axisUsingCenterY_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function axisUsingCenterY_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { axisUsingCenterY_ownKeys(Object(source), true).forEach(function (key) { axisUsingCenterY_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { axisUsingCenterY_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function axisUsingCenterY_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function axisUsingCenterY_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function axisUsingCenterY_createClass(Constructor, protoProps, staticProps) { if (protoProps) axisUsingCenterY_defineProperties(Constructor.prototype, protoProps); if (staticProps) axisUsingCenterY_defineProperties(Constructor, staticProps); return Constructor; }

function axisUsingCenterY_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) axisUsingCenterY_setPrototypeOf(subClass, superClass); }

function axisUsingCenterY_setPrototypeOf(o, p) { axisUsingCenterY_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return axisUsingCenterY_setPrototypeOf(o, p); }

function axisUsingCenterY_createSuper(Derived) { var hasNativeReflectConstruct = axisUsingCenterY_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = axisUsingCenterY_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = axisUsingCenterY_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return axisUsingCenterY_possibleConstructorReturn(this, result); }; }

function axisUsingCenterY_possibleConstructorReturn(self, call) { if (call && (axisUsingCenterY_typeof(call) === "object" || typeof call === "function")) { return call; } return axisUsingCenterY_assertThisInitialized(self); }

function axisUsingCenterY_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function axisUsingCenterY_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function axisUsingCenterY_getPrototypeOf(o) { axisUsingCenterY_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return axisUsingCenterY_getPrototypeOf(o); }

function axisUsingCenterY_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var axisUsingCenterY_AxisUsingCenterY = /*#__PURE__*/function (_Component) {
  axisUsingCenterY_inherits(AxisUsingCenterY, _Component);

  var _super = axisUsingCenterY_createSuper(AxisUsingCenterY);

  function AxisUsingCenterY() {
    var _this;

    axisUsingCenterY_classCallCheck(this, AxisUsingCenterY);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "name", void 0);

    axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "models", {
      label: [],
      tick: [],
      axisLine: []
    });

    axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "drawModels", void 0);

    axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "yAxisComponent", void 0);

    axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "theme", void 0);

    return _this;
  }

  axisUsingCenterY_createClass(AxisUsingCenterY, [{
    key: "initialize",
    value: function initialize(_ref) {
      var name = _ref.name;
      this.type = 'axis';
      this.name = name;
      this.yAxisComponent = name === AxisType.Y;
    }
  }, {
    key: "render",
    value: function render(_ref2) {
      var _this2 = this;

      var layout = _ref2.layout,
          axes = _ref2.axes,
          theme = _ref2.theme;
      var centerYAxis = axes.centerYAxis;

      if (!centerYAxis) {
        return;
      }

      this.theme = getAxisTheme(theme, this.name);
      this.rect = layout[this.name];

      if (this.name === 'yAxis') {
        this.rect = axisUsingCenterY_objectSpread(axisUsingCenterY_objectSpread({}, this.rect), {}, {
          x: centerYAxis.x
        });
      }

      var _ref3 = axes[this.name],
          viewLabels = _ref3.viewLabels,
          tickCount = _ref3.tickCount,
          tickInterval = _ref3.tickInterval,
          needRotateLabel = _ref3.needRotateLabel,
          radian = _ref3.radian,
          offsetY = _ref3.offsetY;
      var renderOptions = {
        tickInterval: tickInterval,
        centerYAxis: centerYAxis,
        needRotateLabel: needRotateLabel,
        radian: radian,
        offsetY: offsetY,
        relativePositions: makeTickPixelPositions(this.axisSize(centerYAxis), tickCount)
      };
      var offsetKey = this.yAxisComponent ? 'y' : 'x';
      var anchorKey = this.yAxisComponent ? 'x' : 'y';
      this.models.label = this.renderLabelModels(viewLabels, offsetKey, anchorKey, renderOptions);
      this.models.tick = this.renderTickModels(offsetKey, anchorKey, renderOptions);
      this.models.axisLine = this.renderAxisLineModel(centerYAxis);

      if (!this.drawModels) {
        this.drawModels = {
          tick: [],
          label: [],
          axisLine: this.models.axisLine
        };
        ['tick', 'label'].forEach(function (type) {
          _this2.drawModels[type] = _this2.models[type].map(function (m) {
            var drawModel = axisUsingCenterY_objectSpread({}, m);

            if (_this2.yAxisComponent) {
              drawModel.y = 0;
            } else {
              drawModel.x = 0;
            }

            return drawModel;
          });
        });
      }
    }
  }, {
    key: "renderAxisLineModel",
    value: function renderAxisLineModel(_ref4) {
      var xAxisHalfSize = _ref4.xAxisHalfSize,
          secondStartX = _ref4.secondStartX;
      var zeroPixel = crispPixel(0);
      var widthPixel = crispPixel(this.rect.width);
      var axisLine;

      if (this.yAxisComponent) {
        var heightPixel = crispPixel(this.rect.height);
        axisLine = [{
          type: 'line',
          x: widthPixel,
          y: zeroPixel,
          x2: widthPixel,
          y2: heightPixel
        }, {
          type: 'line',
          x: zeroPixel,
          y: zeroPixel,
          x2: zeroPixel,
          y2: heightPixel
        }];
      } else {
        axisLine = [{
          type: 'line',
          x: zeroPixel,
          y: zeroPixel,
          x2: crispPixel(xAxisHalfSize),
          y2: zeroPixel
        }, {
          type: 'line',
          x: crispPixel(secondStartX),
          y: zeroPixel,
          x2: widthPixel,
          y2: zeroPixel
        }];
      }

      return axisLine;
    }
  }, {
    key: "renderTickModels",
    value: function renderTickModels(offsetKey, anchorKey, renderOptions) {
      var _this3 = this;

      var tickAnchorPoint = this.yAxisComponent ? crispPixel(this.rect.width) : crispPixel(0);
      var tickInterval = renderOptions.tickInterval,
          secondStartX = renderOptions.centerYAxis.secondStartX,
          relativePositions = renderOptions.relativePositions;
      return relativePositions.reduce(function (positions, position, index) {
        var _model;

        if (index % tickInterval) {
          return positions;
        }

        var model = (_model = {
          type: 'tick',
          isYAxis: _this3.yAxisComponent,
          tickSize: _this3.yAxisComponent ? -5 : 5
        }, axisUsingCenterY_defineProperty(_model, offsetKey, crispPixel(position)), axisUsingCenterY_defineProperty(_model, anchorKey, tickAnchorPoint), _model);

        var addedTickModel = axisUsingCenterY_objectSpread({}, model);

        if (_this3.yAxisComponent) {
          addedTickModel[anchorKey] = crispPixel(0);
          addedTickModel.tickSize = 5;
        } else {
          addedTickModel[offsetKey] = crispPixel(position + secondStartX);
        }

        return [].concat(axisUsingCenterY_toConsumableArray(positions), [model, addedTickModel]);
      }, []);
    }
  }, {
    key: "renderLabelModels",
    value: function renderLabelModels(labels, offsetKey, anchorKey, renderOptions) {
      var _this4 = this;

      var _renderOptions$center = renderOptions.centerYAxis,
          secondStartX = _renderOptions$center.secondStartX,
          yAxisLabelAnchorPoint = _renderOptions$center.yAxisLabelAnchorPoint,
          offsetY = renderOptions.offsetY,
          needRotateLabel = renderOptions.needRotateLabel,
          radian = renderOptions.radian;
      var labelTheme = this.theme.label;
      var font = getTitleFontString(labelTheme);
      var labelAnchorPoint, textAlign, textLabels;

      if (this.yAxisComponent) {
        labelAnchorPoint = crispPixel(yAxisLabelAnchorPoint);
        textAlign = 'center';
        textLabels = labels;
      } else {
        labelAnchorPoint = offsetY;
        textLabels = axisUsingCenterY_toConsumableArray(labels).reverse();
        textAlign = needRotateLabel ? 'left' : 'center';
      }

      var style = ['default', {
        textAlign: textAlign,
        font: font,
        fillStyle: labelTheme.color
      }];
      return textLabels.reduce(function (positions, _ref5, index) {
        var _model2;

        var text = _ref5.text,
            offsetPos = _ref5.offsetPos;
        var model = (_model2 = {
          type: 'label',
          text: text,
          style: style
        }, axisUsingCenterY_defineProperty(_model2, offsetKey, crispPixel(offsetPos) + (_this4.yAxisComponent ? 0 : secondStartX)), axisUsingCenterY_defineProperty(_model2, anchorKey, labelAnchorPoint), axisUsingCenterY_defineProperty(_model2, "radian", radian), _model2);
        var models = [model];

        if (!_this4.yAxisComponent) {
          var addedLabelModel = axisUsingCenterY_objectSpread(axisUsingCenterY_objectSpread({}, model), {}, axisUsingCenterY_defineProperty({
            text: labels[index].text
          }, offsetKey, crispPixel(model[offsetKey] - secondStartX)));

          models.push(addedLabelModel);
        }

        return [].concat(axisUsingCenterY_toConsumableArray(positions), models);
      }, []);
    }
  }, {
    key: "axisSize",
    value: function axisSize(centerYAxis) {
      var size;

      if (this.yAxisComponent) {
        size = this.rect.height;
      } else {
        size = centerYAxis.xAxisHalfSize;
      }

      return size;
    }
  }, {
    key: "beforeDraw",
    value: function beforeDraw(painter) {
      painter.ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
      painter.ctx.lineWidth = 1;
    }
  }]);

  return AxisUsingCenterY;
}(component_Component);


// CONCATENATED MODULE: ./src/charts/barChart.ts



















function barChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { barChart_typeof = function _typeof(obj) { return typeof obj; }; } else { barChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return barChart_typeof(obj); }

function barChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function barChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { barChart_ownKeys(Object(source), true).forEach(function (key) { barChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { barChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function barChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function barChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function barChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) barChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) barChart_defineProperties(Constructor, staticProps); return Constructor; }

function barChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { barChart_get = Reflect.get; } else { barChart_get = function _get(target, property, receiver) { var base = barChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return barChart_get(target, property, receiver || target); }

function barChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = barChart_getPrototypeOf(object); if (object === null) break; } return object; }

function barChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) barChart_setPrototypeOf(subClass, superClass); }

function barChart_setPrototypeOf(o, p) { barChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return barChart_setPrototypeOf(o, p); }

function barChart_createSuper(Derived) { var hasNativeReflectConstruct = barChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = barChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = barChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return barChart_possibleConstructorReturn(this, result); }; }

function barChart_possibleConstructorReturn(self, call) { if (call && (barChart_typeof(call) === "object" || typeof call === "function")) { return call; } return barChart_assertThisInitialized(self); }

function barChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function barChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function barChart_getPrototypeOf(o) { barChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return barChart_getPrototypeOf(o); }

function barChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





























/**
 * @class
 * @classdesc Bar Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Bar Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<number|Array<number>>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Bar Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {number} [props.options.series.barWidth] - Bar width.
 *       @param {boolean} [props.options.series.diverging] - Whether to use diverging chart or not.
 *       @param {boolean} [props.options.series.colorByPoint] - Whether to use color feature or not.
 *       @param {Object} [props.options.series.stack] - Option to use the stack chart or, if so, what type of stack to use.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'grouped', 'point' is available.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Bar Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var barChart_BarChart = /*#__PURE__*/function (_Chart) {
  barChart_inherits(BarChart, _Chart);

  var _super = barChart_createSuper(BarChart);

  function BarChart(_ref) {
    var _this;

    var el = _ref.el,
        _options = _ref.options,
        _data = _ref.data;

    barChart_classCallCheck(this, BarChart);

    _this = _super.call(this, {
      el: el,
      options: _options,
      series: {
        bar: _data.series
      },
      categories: _data.categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
    });

    barChart_defineProperty(barChart_assertThisInitialized(_this), "addData", function (data, category) {
      _this.animationControlFlag.updating = true;

      _this.resetSeries();

      _this.store.dispatch('addData', {
        data: data,
        category: category
      });
    });

    barChart_defineProperty(barChart_assertThisInitialized(_this), "hideSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    });

    barChart_defineProperty(barChart_assertThisInitialized(_this), "showSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    });

    barChart_defineProperty(barChart_assertThisInitialized(_this), "setOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('initOptions', options);
    });

    barChart_defineProperty(barChart_assertThisInitialized(_this), "updateOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', options);
    });

    barChart_defineProperty(barChart_assertThisInitialized(_this), "showTooltip", function (seriesInfo) {
      _this.eventBus.emit('showTooltip', barChart_objectSpread({}, seriesInfo));
    });

    barChart_defineProperty(barChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  barChart_createClass(BarChart, [{
    key: "initialize",
    value: function initialize() {
      var _this$store$initStore;

      barChart_get(barChart_getPrototypeOf(BarChart.prototype), "initialize", this).call(this);

      var stackChart = !!((_this$store$initStore = this.store.initStoreState.options.series) === null || _this$store$initStore === void 0 ? void 0 : _this$store$initStore.stack);
      this.componentManager.add(Background);
      this.componentManager.add(title_Title);
      this.componentManager.add(plot_Plot);
      this.componentManager.add(legend_Legend);
      this.componentManager.add(boxSeries_BoxSeries, {
        name: 'bar',
        stackChart: stackChart
      });
      this.componentManager.add(boxStackSeries_BoxStackSeries, {
        name: 'bar',
        stackChart: stackChart
      });
      this.componentManager.add(zeroAxis_ZeroAxis);
      this.componentManager.add(axis_Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(axisUsingCenterY_AxisUsingCenterY, {
        name: 'yAxis'
      });
      this.componentManager.add(axisUsingCenterY_AxisUsingCenterY, {
        name: 'xAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(exportMenu_ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(hoveredSeries_HoveredSeries);
      this.componentManager.add(selectedSeries_SelectedSeries);
      this.componentManager.add(dataLabels_DataLabels);
      this.componentManager.add(tooltip_Tooltip, {
        chartEl: this.el
      });
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addSeries",

    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          bar: series
        },
        categories: categories
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }]);

  return BarChart;
}(chart_Chart);


// CONCATENATED MODULE: ./src/charts/columnChart.ts



















function columnChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { columnChart_typeof = function _typeof(obj) { return typeof obj; }; } else { columnChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return columnChart_typeof(obj); }

function columnChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function columnChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { columnChart_ownKeys(Object(source), true).forEach(function (key) { columnChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { columnChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function columnChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function columnChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function columnChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) columnChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) columnChart_defineProperties(Constructor, staticProps); return Constructor; }

function columnChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { columnChart_get = Reflect.get; } else { columnChart_get = function _get(target, property, receiver) { var base = columnChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return columnChart_get(target, property, receiver || target); }

function columnChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = columnChart_getPrototypeOf(object); if (object === null) break; } return object; }

function columnChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) columnChart_setPrototypeOf(subClass, superClass); }

function columnChart_setPrototypeOf(o, p) { columnChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return columnChart_setPrototypeOf(o, p); }

function columnChart_createSuper(Derived) { var hasNativeReflectConstruct = columnChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = columnChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = columnChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return columnChart_possibleConstructorReturn(this, result); }; }

function columnChart_possibleConstructorReturn(self, call) { if (call && (columnChart_typeof(call) === "object" || typeof call === "function")) { return call; } return columnChart_assertThisInitialized(self); }

function columnChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function columnChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function columnChart_getPrototypeOf(o) { columnChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return columnChart_getPrototypeOf(o); }

function columnChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




























/**
 * @class
 * @classdesc Column Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Column Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<number|Array<number>>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Column Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {number} [props.options.series.barWidth] - Bar width.
 *       @param {boolean} [props.options.series.diverging] - Whether to use diverging chart or not.
 *       @param {boolean} [props.options.series.colorByPoint] - Whether to use color feature or not.
 *       @param {Object} [props.options.series.stack] - Option to use the stack chart or, if so, what type of stack to use.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'grouped', 'point' is available.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *     @param {Object} [props.options.xAxis]
 *       @param {Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Bar Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var columnChart_ColumnChart = /*#__PURE__*/function (_Chart) {
  columnChart_inherits(ColumnChart, _Chart);

  var _super = columnChart_createSuper(ColumnChart);

  function ColumnChart(_ref) {
    var _this;

    var el = _ref.el,
        _options = _ref.options,
        _data = _ref.data;

    columnChart_classCallCheck(this, ColumnChart);

    _this = _super.call(this, {
      el: el,
      options: _options,
      series: {
        column: _data.series
      },
      categories: _data.categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
    });

    columnChart_defineProperty(columnChart_assertThisInitialized(_this), "addData", function (data, category) {
      _this.animationControlFlag.updating = true;

      _this.resetSeries();

      _this.store.dispatch('addData', {
        data: data,
        category: category
      });
    });

    columnChart_defineProperty(columnChart_assertThisInitialized(_this), "hideSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    });

    columnChart_defineProperty(columnChart_assertThisInitialized(_this), "showSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    });

    columnChart_defineProperty(columnChart_assertThisInitialized(_this), "setOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('initOptions', options);
    });

    columnChart_defineProperty(columnChart_assertThisInitialized(_this), "updateOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', options);
    });

    columnChart_defineProperty(columnChart_assertThisInitialized(_this), "showTooltip", function (seriesInfo) {
      _this.eventBus.emit('showTooltip', columnChart_objectSpread({}, seriesInfo));
    });

    columnChart_defineProperty(columnChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  columnChart_createClass(ColumnChart, [{
    key: "initialize",
    value: function initialize() {
      var _this$store$initStore;

      columnChart_get(columnChart_getPrototypeOf(ColumnChart.prototype), "initialize", this).call(this);

      var stackChart = !!((_this$store$initStore = this.store.initStoreState.options.series) === null || _this$store$initStore === void 0 ? void 0 : _this$store$initStore.stack);
      this.componentManager.add(Background);
      this.componentManager.add(title_Title);
      this.componentManager.add(plot_Plot);
      this.componentManager.add(legend_Legend);
      this.componentManager.add(boxStackSeries_BoxStackSeries, {
        name: 'column',
        stackChart: stackChart
      });
      this.componentManager.add(boxSeries_BoxSeries, {
        name: 'column',
        stackChart: stackChart
      });
      this.componentManager.add(zeroAxis_ZeroAxis);
      this.componentManager.add(axis_Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(exportMenu_ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(hoveredSeries_HoveredSeries);
      this.componentManager.add(selectedSeries_SelectedSeries);
      this.componentManager.add(dataLabels_DataLabels);
      this.componentManager.add(tooltip_Tooltip, {
        chartEl: this.el
      });
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<number|Array<number>>} data - Array of data to be added
     * @param {string} category - Category to be added
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addSeries",

    /**
     * Add series.
     * @param {Object} data - Data to be added
     *   @param {string} data.name - Series name
     *   @param {Array<number|Array<number>>} data.data - Array of data to be added
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          column: series
        },
        categories: categories
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }]);

  return ColumnChart;
}(chart_Chart);


// CONCATENATED MODULE: ./src/charts/columnLineChart.ts





















function columnLineChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { columnLineChart_typeof = function _typeof(obj) { return typeof obj; }; } else { columnLineChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return columnLineChart_typeof(obj); }

function columnLineChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function columnLineChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { columnLineChart_ownKeys(Object(source), true).forEach(function (key) { columnLineChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { columnLineChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function columnLineChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function columnLineChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function columnLineChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) columnLineChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) columnLineChart_defineProperties(Constructor, staticProps); return Constructor; }

function columnLineChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { columnLineChart_get = Reflect.get; } else { columnLineChart_get = function _get(target, property, receiver) { var base = columnLineChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return columnLineChart_get(target, property, receiver || target); }

function columnLineChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = columnLineChart_getPrototypeOf(object); if (object === null) break; } return object; }

function columnLineChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) columnLineChart_setPrototypeOf(subClass, superClass); }

function columnLineChart_setPrototypeOf(o, p) { columnLineChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return columnLineChart_setPrototypeOf(o, p); }

function columnLineChart_createSuper(Derived) { var hasNativeReflectConstruct = columnLineChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = columnLineChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = columnLineChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return columnLineChart_possibleConstructorReturn(this, result); }; }

function columnLineChart_possibleConstructorReturn(self, call) { if (call && (columnLineChart_typeof(call) === "object" || typeof call === "function")) { return call; } return columnLineChart_assertThisInitialized(self); }

function columnLineChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function columnLineChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function columnLineChart_getPrototypeOf(o) { columnLineChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return columnLineChart_getPrototypeOf(o); }

function columnLineChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }































function hasPointEventType(respondersModel, name) {
  return respondersModel.find(function (_ref) {
    var component = _ref.component;
    return component.name === name && component.eventDetectType === 'point';
  });
}

function hasColumnLineUsingPointEventType(respondersModel) {
  return isExist(hasPointEventType(respondersModel, 'column')) && isExist(hasPointEventType(respondersModel, 'line'));
}
/**
 * @class
 * @classdesc ColumnLine Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making ColumnLine Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {Array<Object>} props.data.series.line - Line series data. Coordinate types data is not possible.
 *       @param {Array<Object>} props.data.series.column - Column series data.
 *   @param {Object} [props.options] - Options for making ColumnLine Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series] - Write common options in the upper depth and separate options to be applied to each chart.
 *       @param {Object} [props.options.series.line] - Options to be applied to the line chart. 'spline', 'showDot', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Line Chart guide} on github.
 *       @param {Object} [props.options.series.column] - Options to be applied to the column chart. 'barWidth', 'stack', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Column Chart guide} on github.
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'near', 'nearest', 'grouped', 'point' is available.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *       @param {Array<Object>} [props.options.plot.lines] - Plot lines information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|ColumnLine Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme. Each theme to be applied to the two charts should be written separately.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */


var columnLineChart_ColumnLineChart = /*#__PURE__*/function (_Chart) {
  columnLineChart_inherits(ColumnLineChart, _Chart);

  var _super = columnLineChart_createSuper(ColumnLineChart);

  function ColumnLineChart(_ref2) {
    var _this;

    var el = _ref2.el,
        _options = _ref2.options,
        _ref2$data = _ref2.data,
        series = _ref2$data.series,
        categories = _ref2$data.categories;

    columnLineChart_classCallCheck(this, ColumnLineChart);

    _this = _super.call(this, {
      el: el,
      options: _options,
      series: series,
      categories: categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
    });

    columnLineChart_defineProperty(columnLineChart_assertThisInitialized(_this), "addData", function (data, category, chartType) {
      _this.animationControlFlag.updating = true;

      _this.resetSeries();

      _this.store.dispatch('addData', {
        data: data,
        category: category,
        chartType: chartType
      });
    });

    columnLineChart_defineProperty(columnLineChart_assertThisInitialized(_this), "hideSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    });

    columnLineChart_defineProperty(columnLineChart_assertThisInitialized(_this), "showSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    });

    columnLineChart_defineProperty(columnLineChart_assertThisInitialized(_this), "setOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('initOptions', options);
    });

    columnLineChart_defineProperty(columnLineChart_assertThisInitialized(_this), "updateOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', options);
    });

    columnLineChart_defineProperty(columnLineChart_assertThisInitialized(_this), "showTooltip", function (seriesInfo) {
      _this.eventBus.emit('showTooltip', columnLineChart_objectSpread({}, seriesInfo));
    });

    columnLineChart_defineProperty(columnLineChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  columnLineChart_createClass(ColumnLineChart, [{
    key: "initialize",
    value: function initialize() {
      columnLineChart_get(columnLineChart_getPrototypeOf(ColumnLineChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(title_Title);
      this.componentManager.add(plot_Plot);
      this.componentManager.add(legend_Legend);
      this.componentManager.add(boxStackSeries_BoxStackSeries, {
        name: 'column'
      });
      this.componentManager.add(boxSeries_BoxSeries, {
        name: 'column'
      });
      this.componentManager.add(lineSeries_LineSeries);
      this.componentManager.add(zeroAxis_ZeroAxis);
      this.componentManager.add(axis_Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(exportMenu_ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(hoveredSeries_HoveredSeries);
      this.componentManager.add(selectedSeries_SelectedSeries);
      this.componentManager.add(dataLabels_DataLabels);
      this.componentManager.add(tooltip_Tooltip, {
        chartEl: this.el
      });
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_lineSeries_namespaceObject]);
    }
  }, {
    key: "handleEventForAllResponders",
    value: function handleEventForAllResponders(event, responderModels, delegationMethod, mousePosition) {
      if (hasColumnLineUsingPointEventType(responderModels)) {
        var columnSeries = responderModels.find(function (_ref3) {
          var component = _ref3.component;
          return component.name === 'column';
        });
        columnSeries.component[delegationMethod]({
          mousePosition: mousePosition,
          responders: []
        }, event);
      }
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @param {string} chartType - Which type of chart to add.
     * @api
     * @example
     * chart.addData([10, 20], '6', 'line');
     */

  }, {
    key: "addSeries",

    /**
     * Add series.
     * @param {Object} data - Data to be added.
     * @param {string} data.name - Series name.
     * @param {Array<number>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Which type of chart to add.
     * @param {Object} dataInfo.chartType - Chart type.
     * @api
     * @example
     * chart.addSeries(
     *   {
     *     name: 'newSeries',
     *     data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     *   },
     *   {
     *     chartType: 'line'
     *   });
     */
    value: function addSeries(data, dataInfo) {
      this.resetSeries();
      this.store.dispatch('addSeries', columnLineChart_objectSpread({
        data: data
      }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: {
     *     column: [
     *       {
     *         name: 'A',
     *         data: [1, 2, 3],
     *       }
     *     ],
     *     line: [
     *       {
     *         name: 'B',
     *         data: [4, 5, 6],
     *       }
     *     ]
     *   }
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', data);
    }
    /**
     * Add plot line.
     * @param {Object} data - Plot info.
     *   @param {string|number} data.value - The value where the plot line will be drawn.
     *   @param {string} data.color - Plot line color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
     * @api
     * @example
     * chart.addPlotLine({
     *   value: 2,
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotLine",
    value: function addPlotLine(data) {
      this.store.dispatch('addPlotLine', {
        data: data
      });
    }
    /**
     * Remove plot line with id.
     * @param {string} id - Id of the plot line to be removed
     * @api
     * @example
     * chart.removePlotLine('plot-1');
     */

  }, {
    key: "removePlotLine",
    value: function removePlotLine(id) {
      this.store.dispatch('removePlotLine', {
        id: id
      });
    }
    /**
     * Add plot band.
     * @param {Object} data - plot info
     *   @param {Array<string|number>} data.range - The range to be drawn
     *   @param {string} data.color - Plot band color
     *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based
     * @api
     * @example
     * chart.addPlotBand({
     *   value: [2, 4],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotBand",
    value: function addPlotBand(data) {
      this.store.dispatch('addPlotBand', {
        data: data
      });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - id of the plot band to be removed
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */

  }, {
    key: "removePlotBand",
    value: function removePlotBand(id) {
      this.store.dispatch('removePlotBand', {
        id: id
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }]);

  return ColumnLineChart;
}(chart_Chart);


// CONCATENATED MODULE: ./src/component/bubbleSeries.ts



























function bubbleSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { bubbleSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { bubbleSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return bubbleSeries_typeof(obj); }

function bubbleSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function bubbleSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { bubbleSeries_ownKeys(Object(source), true).forEach(function (key) { bubbleSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { bubbleSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function bubbleSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function bubbleSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function bubbleSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) bubbleSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) bubbleSeries_defineProperties(Constructor, staticProps); return Constructor; }

function bubbleSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bubbleSeries_setPrototypeOf(subClass, superClass); }

function bubbleSeries_setPrototypeOf(o, p) { bubbleSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bubbleSeries_setPrototypeOf(o, p); }

function bubbleSeries_createSuper(Derived) { var hasNativeReflectConstruct = bubbleSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bubbleSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bubbleSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bubbleSeries_possibleConstructorReturn(this, result); }; }

function bubbleSeries_possibleConstructorReturn(self, call) { if (call && (bubbleSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return bubbleSeries_assertThisInitialized(self); }

function bubbleSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function bubbleSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function bubbleSeries_getPrototypeOf(o) { bubbleSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bubbleSeries_getPrototypeOf(o); }

function bubbleSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function bubbleSeries_toConsumableArray(arr) { return bubbleSeries_arrayWithoutHoles(arr) || bubbleSeries_iterableToArray(arr) || bubbleSeries_unsupportedIterableToArray(arr) || bubbleSeries_nonIterableSpread(); }

function bubbleSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function bubbleSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return bubbleSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bubbleSeries_arrayLikeToArray(o, minLen); }

function bubbleSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function bubbleSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return bubbleSeries_arrayLikeToArray(arr); }

function bubbleSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }









var bubbleSeries_MINIMUM_RADIUS = 0.5;
var MINIMUM_DETECTING_AREA_RADIUS = 1;
function getMaxRadius(bubbleData) {
  return bubbleData.reduce(function (acc, cur) {
    var NonNullData = cur.data.filter(function (datum) {
      return !isNull(datum);
    });
    return Math.max.apply(Math, [acc].concat(bubbleSeries_toConsumableArray(NonNullData.map(function (_ref) {
      var r = _ref.r;
      return r;
    }))));
  }, 0);
}

var bubbleSeries_BubbleSeries = /*#__PURE__*/function (_Component) {
  bubbleSeries_inherits(BubbleSeries, _Component);

  var _super = bubbleSeries_createSuper(BubbleSeries);

  function BubbleSeries() {
    var _this;

    bubbleSeries_classCallCheck(this, BubbleSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "models", {
      series: []
    });

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "drawModels", void 0);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "responders", void 0);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "activatedResponders", []);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "theme", void 0);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "rect", void 0);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "maxRadius", -1);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "maxValue", -1);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "selectSeries", function (_ref2) {
      var index = _ref2.index,
          seriesIndex = _ref2.seriesIndex,
          state = _ref2.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.bubble.data[index].name;

      var model = _this.responders.filter(function (_ref3) {
        var dataName = _ref3.name;
        return dataName === name;
      })[seriesIndex];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: [model],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex,
          state = info.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.bubble.data[seriesIndex].name;
      var models = [_this.responders.filter(function (_ref4) {
        var dataName = _ref4.name;
        return dataName === name;
      })[index]];

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: models,
        name: _this.name
      });

      _this.activatedResponders = models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  bubbleSeries_createClass(BubbleSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'bubble';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      var _this2 = this;

      this.drawModels.series.forEach(function (model, index) {
        model.radius = _this2.models.series[index].radius * delta;
      });
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var layout = chartState.layout,
          series = chartState.series,
          scale = chartState.scale,
          axes = chartState.axes,
          circleLegend = chartState.circleLegend,
          legend = chartState.legend,
          options = chartState.options,
          theme = chartState.theme;
      var plot = layout.plot;

      if (!series.bubble) {
        throw new Error(message.noDataError(this.name));
      }

      var xAxis = axes.xAxis,
          yAxis = axes.yAxis;
      var bubbleData = series.bubble.data;
      this.theme = theme.series.bubble;
      this.rect = plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var xAxisTickSize = this.rect.width / xAxis.tickCount;
      var yAxisTickSize = this.rect.height / yAxis.tickCount;
      this.maxRadius = circleLegend.radius ? circleLegend.radius : Math.min(xAxisTickSize, yAxisTickSize);
      this.maxValue = getMaxRadius(bubbleData);
      var seriesModel = this.renderBubblePointsModel(bubbleData, scale);
      var tooltipModel = this.makeTooltipModel(bubbleData);
      this.models.series = seriesModel;

      if (!this.drawModels) {
        this.drawModels = deepCopy(this.models);
      }

      this.responders = seriesModel.map(function (m, index) {
        return bubbleSeries_objectSpread(bubbleSeries_objectSpread({}, m), {}, {
          type: 'circle',
          detectionSize: 0,
          radius: m.radius + MINIMUM_DETECTING_AREA_RADIUS,
          color: getRGBA(m.color, 0.85),
          data: tooltipModel[index],
          index: index
        });
      });
    }
  }, {
    key: "renderBubblePointsModel",
    value: function renderBubblePointsModel(seriesRawData, scale) {
      var _this3 = this;

      var xAxisLimit = scale.xAxis.limit,
          yAxisLimit = scale.yAxis.limit;
      var _this$theme = this.theme,
          borderWidth = _this$theme.borderWidth,
          borderColor = _this$theme.borderColor;
      return seriesRawData.flatMap(function (_ref5, seriesIndex) {
        var data = _ref5.data,
            name = _ref5.name,
            seriesColor = _ref5.color;
        var circleModels = [];
        var active = _this3.activeSeriesMap[name];
        var color = getRGBA(seriesColor, active ? 0.8 : 0.1);
        var nonNullData = data.filter(function (datum) {
          return !isNull(datum);
        });
        nonNullData.forEach(function (datum) {
          var rawXValue = getCoordinateXValue(datum);
          var xValue = isString(rawXValue) ? Number(new Date(rawXValue)) : Number(rawXValue);
          var yValue = getCoordinateYValue(datum);
          var xValueRatio = getValueRatio(xValue, xAxisLimit);
          var yValueRatio = getValueRatio(yValue, yAxisLimit);
          var x = xValueRatio * _this3.rect.width;
          var y = (1 - yValueRatio) * _this3.rect.height;
          var radius = Math.max(bubbleSeries_MINIMUM_RADIUS, datum.r / _this3.maxValue * _this3.maxRadius);
          circleModels.push({
            x: x,
            y: y,
            type: 'circle',
            radius: radius,
            color: color,
            style: ['default'],
            seriesIndex: seriesIndex,
            name: name,
            borderWidth: borderWidth,
            borderColor: borderColor
          });
        });
        return circleModels;
      });
    }
  }, {
    key: "makeTooltipModel",
    value: function makeTooltipModel(circleData) {
      return bubbleSeries_toConsumableArray(circleData).flatMap(function (_ref6) {
        var data = _ref6.data,
            name = _ref6.name,
            color = _ref6.color;
        var tooltipData = [];
        var nonNullData = data.filter(function (datum) {
          return !isNull(datum);
        });
        nonNullData.forEach(function (datum) {
          var r = datum.r,
              label = datum.label;
          tooltipData.push({
            label: "".concat(name, "/").concat(label),
            color: color,
            value: {
              x: getCoordinateXValue(datum),
              y: getCoordinateYValue(datum),
              r: r
            }
          });
        });
        return tooltipData;
      });
    }
  }, {
    key: "getResponderAppliedTheme",
    value: function getResponderAppliedTheme(responders, type) {
      var _this4 = this;

      return responders.map(function (responder) {
        return deepMergedCopy(responder, _this4.theme[type]);
      });
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref7) {
      var responders = _ref7.responders,
          mousePosition = _ref7.mousePosition;
      var closestResponder = getNearestResponder(responders, mousePosition, this.rect);
      var responderWithTheme = this.getResponderAppliedTheme(closestResponder, 'hover');
      this.eventBus.emit('renderHoveredSeries', {
        models: responderWithTheme,
        name: this.name
      });
      this.activatedResponders = closestResponder;
      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref8) {
      var responders = _ref8.responders,
          mousePosition = _ref8.mousePosition;

      if (this.selectable) {
        var closestResponder = getNearestResponder(responders, mousePosition, this.rect);
        var responderWithTheme = this.getResponderAppliedTheme(closestResponder, 'select');
        this.eventBus.emit('renderSelectedSeries', {
          models: responderWithTheme,
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }]);

  return BubbleSeries;
}(component_Component);


// CONCATENATED MODULE: ./src/component/circleLegend.ts













function circleLegend_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { circleLegend_typeof = function _typeof(obj) { return typeof obj; }; } else { circleLegend_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return circleLegend_typeof(obj); }

function circleLegend_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function circleLegend_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function circleLegend_createClass(Constructor, protoProps, staticProps) { if (protoProps) circleLegend_defineProperties(Constructor.prototype, protoProps); if (staticProps) circleLegend_defineProperties(Constructor, staticProps); return Constructor; }

function circleLegend_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) circleLegend_setPrototypeOf(subClass, superClass); }

function circleLegend_setPrototypeOf(o, p) { circleLegend_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return circleLegend_setPrototypeOf(o, p); }

function circleLegend_createSuper(Derived) { var hasNativeReflectConstruct = circleLegend_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = circleLegend_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = circleLegend_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return circleLegend_possibleConstructorReturn(this, result); }; }

function circleLegend_possibleConstructorReturn(self, call) { if (call && (circleLegend_typeof(call) === "object" || typeof call === "function")) { return call; } return circleLegend_assertThisInitialized(self); }

function circleLegend_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function circleLegend_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function circleLegend_getPrototypeOf(o) { circleLegend_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return circleLegend_getPrototypeOf(o); }

function circleLegend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var circleLegend_CircleLegend = /*#__PURE__*/function (_Component) {
  circleLegend_inherits(CircleLegend, _Component);

  var _super = circleLegend_createSuper(CircleLegend);

  function CircleLegend() {
    var _this;

    circleLegend_classCallCheck(this, CircleLegend);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    circleLegend_defineProperty(circleLegend_assertThisInitialized(_this), "models", {
      circleLegend: []
    });

    return _this;
  }

  circleLegend_createClass(CircleLegend, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'circleLegend';
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout,
          series = _ref.series,
          circleLegend = _ref.circleLegend;

      if (!series.bubble) {
        throw new Error(message.CIRCLE_LEGEND_RENDER_ERROR);
      }

      this.isShow = circleLegend.visible;

      if (!this.isShow) {
        return;
      }

      var bubbleData = series.bubble.data;
      this.rect = layout.circleLegend;
      this.renderCircleLegend(bubbleData, circleLegend);
    }
  }, {
    key: "renderCircleLegend",
    value: function renderCircleLegend(bubbleData, circleLegend) {
      var value = getMaxRadius(bubbleData);
      var radius = circleLegend.radius;
      this.models.circleLegend = [{
        type: 'circleLegend',
        radius: radius,
        value: value,
        x: radius,
        y: this.rect.height - radius
      }];
    }
  }]);

  return CircleLegend;
}(component_Component);


// CONCATENATED MODULE: ./src/brushes/circleLegend.ts



function circleLegend_circleLegend(ctx, circleLegendModel) {
  var x = circleLegendModel.x,
      y = circleLegendModel.y,
      radius = circleLegendModel.radius,
      value = circleLegendModel.value;
  var ratioArray = [1, 0.5, 0.25];
  ratioArray.forEach(function (ratio, idx) {
    var circleRadius = ratio * radius;
    var circleY = y + (idx ? (1 - ratio) * radius : 0);
    basic_circle(ctx, {
      type: 'circle',
      x: x,
      y: circleY,
      radius: circleRadius,
      color: '#fff',
      seriesIndex: 0,
      style: ['default', {
        strokeStyle: '#888',
        lineWidth: 1
      }]
    });
    label_label(ctx, {
      type: 'label',
      x: x,
      y: circleY - circleRadius,
      text: String(value * ratio),
      style: ['default', {
        textAlign: 'center',
        textBaseline: 'bottom'
      }]
    });
  });
}
// CONCATENATED MODULE: ./src/charts/bubbleChart.ts



















function bubbleChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { bubbleChart_typeof = function _typeof(obj) { return typeof obj; }; } else { bubbleChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return bubbleChart_typeof(obj); }

function bubbleChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function bubbleChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { bubbleChart_ownKeys(Object(source), true).forEach(function (key) { bubbleChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { bubbleChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function bubbleChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function bubbleChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function bubbleChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) bubbleChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) bubbleChart_defineProperties(Constructor, staticProps); return Constructor; }

function bubbleChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { bubbleChart_get = Reflect.get; } else { bubbleChart_get = function _get(target, property, receiver) { var base = bubbleChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return bubbleChart_get(target, property, receiver || target); }

function bubbleChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = bubbleChart_getPrototypeOf(object); if (object === null) break; } return object; }

function bubbleChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bubbleChart_setPrototypeOf(subClass, superClass); }

function bubbleChart_setPrototypeOf(o, p) { bubbleChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bubbleChart_setPrototypeOf(o, p); }

function bubbleChart_createSuper(Derived) { var hasNativeReflectConstruct = bubbleChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bubbleChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bubbleChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bubbleChart_possibleConstructorReturn(this, result); }; }

function bubbleChart_possibleConstructorReturn(self, call) { if (call && (bubbleChart_typeof(call) === "object" || typeof call === "function")) { return call; } return bubbleChart_assertThisInitialized(self); }

function bubbleChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function bubbleChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function bubbleChart_getPrototypeOf(o) { bubbleChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bubbleChart_getPrototypeOf(o); }

function bubbleChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

























/**
 * @class
 * @classdesc Bubble Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Bubble Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<Object>} props.data.series.data - Series data. Coordinates x, y values, radius r, and label values are required.
 *   @param {Object} [props.options] - Options for making Bubble Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *     @param {Object} [props.options.xAxis]
 *       @param {Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object} [props.options.yAxis]
 *       @param {Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.circleLegend]
 *       @param {boolean} [props.options.circleLegend.visible] - Whether to show circle legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Bubble Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var bubbleChart_BubbleChart = /*#__PURE__*/function (_Chart) {
  bubbleChart_inherits(BubbleChart, _Chart);

  var _super = bubbleChart_createSuper(BubbleChart);

  function BubbleChart(props) {
    var _this;

    bubbleChart_classCallCheck(this, BubbleChart);

    _this = _super.call(this, {
      el: props.el,
      options: props.options,
      series: {
        bubble: props.data.series
      },
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });

    bubbleChart_defineProperty(bubbleChart_assertThisInitialized(_this), "addData", function (data) {
      _this.animationControlFlag.updating = true;

      _this.resetSeries();

      _this.store.dispatch('addData', {
        data: data
      });
    });

    bubbleChart_defineProperty(bubbleChart_assertThisInitialized(_this), "setOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('initOptions', options);
    });

    bubbleChart_defineProperty(bubbleChart_assertThisInitialized(_this), "updateOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', options);
    });

    bubbleChart_defineProperty(bubbleChart_assertThisInitialized(_this), "showTooltip", function (seriesInfo) {
      _this.eventBus.emit('showTooltip', bubbleChart_objectSpread(bubbleChart_objectSpread({}, seriesInfo), {}, {
        state: _this.store.state
      }));
    });

    bubbleChart_defineProperty(bubbleChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  bubbleChart_createClass(BubbleChart, [{
    key: "initialize",
    value: function initialize() {
      bubbleChart_get(bubbleChart_getPrototypeOf(BubbleChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(title_Title);
      this.componentManager.add(plot_Plot);
      this.componentManager.add(legend_Legend);
      this.componentManager.add(bubbleSeries_BubbleSeries);
      this.componentManager.add(axis_Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(exportMenu_ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(hoveredSeries_HoveredSeries);
      this.componentManager.add(selectedSeries_SelectedSeries);
      this.componentManager.add(tooltip_Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(circleLegend_CircleLegend);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_circleLegend_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<Object>} data - Array of data to be added.
     * @api
     * @example
     * chart.addData([
     *   {x: 10, y: 20, r: 10, label: 'label1'},
     *   {x: 30, y: 40, r: 10, label: 'label2'},
     * ]);
     */

  }, {
    key: "addSeries",

    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [
     *     {x: 10, y: 20, r: 10, label: 'label1'},
     *     {x: 30, y: 40, r: 10, label: 'label2'},
     *   ],
     * });
     */
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   series: [
     *     {
     *       name: 'name'
     *       data: [
     *         {x: 10, y: 20, r: 10, label: 'label1'},
     *         {x: 30, y: 40, r: 10, label: 'label2'},
     *       ]
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          bubble: data.series
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }]);

  return BubbleChart;
}(chart_Chart);


// CONCATENATED MODULE: ./src/charts/scatterChart.ts

























function scatterChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { scatterChart_typeof = function _typeof(obj) { return typeof obj; }; } else { scatterChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return scatterChart_typeof(obj); }

function scatterChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function scatterChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function scatterChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) scatterChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) scatterChart_defineProperties(Constructor, staticProps); return Constructor; }

function scatterChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { scatterChart_get = Reflect.get; } else { scatterChart_get = function _get(target, property, receiver) { var base = scatterChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return scatterChart_get(target, property, receiver || target); }

function scatterChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = scatterChart_getPrototypeOf(object); if (object === null) break; } return object; }

function scatterChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) scatterChart_setPrototypeOf(subClass, superClass); }

function scatterChart_setPrototypeOf(o, p) { scatterChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return scatterChart_setPrototypeOf(o, p); }

function scatterChart_createSuper(Derived) { var hasNativeReflectConstruct = scatterChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = scatterChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = scatterChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return scatterChart_possibleConstructorReturn(this, result); }; }

function scatterChart_possibleConstructorReturn(self, call) { if (call && (scatterChart_typeof(call) === "object" || typeof call === "function")) { return call; } return scatterChart_assertThisInitialized(self); }

function scatterChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function scatterChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function scatterChart_getPrototypeOf(o) { scatterChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return scatterChart_getPrototypeOf(o); }

function scatterChart_toConsumableArray(arr) { return scatterChart_arrayWithoutHoles(arr) || scatterChart_iterableToArray(arr) || scatterChart_unsupportedIterableToArray(arr) || scatterChart_nonIterableSpread(); }

function scatterChart_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function scatterChart_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return scatterChart_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return scatterChart_arrayLikeToArray(o, minLen); }

function scatterChart_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function scatterChart_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return scatterChart_arrayLikeToArray(arr); }

function scatterChart_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function scatterChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function scatterChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { scatterChart_ownKeys(Object(source), true).forEach(function (key) { scatterChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { scatterChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function scatterChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


























function clearUnnecessaryData(scatterSeries) {
  return scatterSeries.map(function (series) {
    var exist = {};
    return scatterChart_objectSpread(scatterChart_objectSpread({}, series), {}, {
      data: series.data.filter(function (datum) {
        return !isNull(datum);
      }).reduce(function (acc, cur) {
        var x = getCoordinateXValue(cur);
        var y = getCoordinateYValue(cur);
        var key = "".concat(x, "-").concat(y);

        if (!exist[key]) {
          exist[key] = true;
          return [].concat(scatterChart_toConsumableArray(acc), [cur]);
        }

        return acc;
      }, [])
    });
  });
}
/**
 * @class
 * @classdesc Scatter Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Scatter Chart.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<Object|Array<number>>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Scatter Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *     @param {Object} [props.options.xAxis]
 *       @param {Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object} [props.options.yAxis]
 *       @param {Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Scattter Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */


var scatterChart_ScatterChart = /*#__PURE__*/function (_Chart) {
  scatterChart_inherits(ScatterChart, _Chart);

  var _super = scatterChart_createSuper(ScatterChart);

  function ScatterChart(props) {
    var _props$data;

    var _this;

    scatterChart_classCallCheck(this, ScatterChart);

    _this = _super.call(this, {
      el: props.el,
      options: props.options,
      series: {
        scatter: clearUnnecessaryData(props.data.series)
      },
      categories: (_props$data = props.data) === null || _props$data === void 0 ? void 0 : _props$data.categories,
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });

    scatterChart_defineProperty(scatterChart_assertThisInitialized(_this), "addData", function (data) {
      _this.animationControlFlag.updating = true;

      _this.resetSeries();

      _this.store.dispatch('addData', {
        data: data
      });
    });

    scatterChart_defineProperty(scatterChart_assertThisInitialized(_this), "setOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('initOptions', options);
    });

    scatterChart_defineProperty(scatterChart_assertThisInitialized(_this), "updateOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', options);
    });

    scatterChart_defineProperty(scatterChart_assertThisInitialized(_this), "showTooltip", function (seriesInfo) {
      _this.eventBus.emit('showTooltip', scatterChart_objectSpread(scatterChart_objectSpread({}, seriesInfo), {}, {
        state: _this.store.state
      }));
    });

    scatterChart_defineProperty(scatterChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  scatterChart_createClass(ScatterChart, [{
    key: "initialize",
    value: function initialize() {
      scatterChart_get(scatterChart_getPrototypeOf(ScatterChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(title_Title);
      this.componentManager.add(plot_Plot);
      this.componentManager.add(legend_Legend);
      this.componentManager.add(scatterSeries_ScatterSeries);
      this.componentManager.add(axis_Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(exportMenu_ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(hoveredSeries_HoveredSeries);
      this.componentManager.add(selectedSeries_SelectedSeries);
      this.componentManager.add(tooltip_Tooltip, {
        chartEl: this.el
      });
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, scatterSeries_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<Object>} data - Array of data to be added.
     * @api
     * @example
     * chart.addData([
     *   {x: 10, y: 20},
     *   {x: 30, y: 40},
     * ]);
     */

  }, {
    key: "addSeries",

    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [
     *     {x: 10, y: 20},
     *     {x: 30, y: 40},
     *   ],
     * });
     */
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   series: [
     *     {
     *       name: 'name'
     *       data: [
     *         {x: 10, y: 20},
     *         {x: 30, y: 40},
     *       ]
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          scatter: series
        },
        categories: categories
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }]);

  return ScatterChart;
}(chart_Chart);


// CONCATENATED MODULE: ./src/component/bulletSeries.ts


























function bulletSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { bulletSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { bulletSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return bulletSeries_typeof(obj); }

function bulletSeries_slicedToArray(arr, i) { return bulletSeries_arrayWithHoles(arr) || bulletSeries_iterableToArrayLimit(arr, i) || bulletSeries_unsupportedIterableToArray(arr, i) || bulletSeries_nonIterableRest(); }

function bulletSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function bulletSeries_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function bulletSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function bulletSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function bulletSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function bulletSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) bulletSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) bulletSeries_defineProperties(Constructor, staticProps); return Constructor; }

function bulletSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bulletSeries_setPrototypeOf(subClass, superClass); }

function bulletSeries_setPrototypeOf(o, p) { bulletSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bulletSeries_setPrototypeOf(o, p); }

function bulletSeries_createSuper(Derived) { var hasNativeReflectConstruct = bulletSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bulletSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bulletSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bulletSeries_possibleConstructorReturn(this, result); }; }

function bulletSeries_possibleConstructorReturn(self, call) { if (call && (bulletSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return bulletSeries_assertThisInitialized(self); }

function bulletSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function bulletSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function bulletSeries_getPrototypeOf(o) { bulletSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bulletSeries_getPrototypeOf(o); }

function bulletSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function bulletSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { bulletSeries_ownKeys(Object(source), true).forEach(function (key) { bulletSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { bulletSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function bulletSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function bulletSeries_toConsumableArray(arr) { return bulletSeries_arrayWithoutHoles(arr) || bulletSeries_iterableToArray(arr) || bulletSeries_unsupportedIterableToArray(arr) || bulletSeries_nonIterableSpread(); }

function bulletSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function bulletSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return bulletSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bulletSeries_arrayLikeToArray(o, minLen); }

function bulletSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function bulletSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return bulletSeries_arrayLikeToArray(arr); }

function bulletSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }










var DEFAULT_WIDTH_RATIO = 0.6;
var MARKER_LINE_DETECTION_SIZE = 5;

function getRectSize(vertical, barWidth, barLength) {
  return {
    width: vertical ? barWidth : barLength,
    height: vertical ? barLength : barWidth
  };
}

function getStartX(seriesIndex, tickDistance, barWidth) {
  return seriesIndex * tickDistance + (tickDistance - barWidth) / 2;
}

function makeBulletResponderModel(models, tooltipData) {
  var range = models.range,
      marker = models.marker,
      bullet = models.bullet;
  var tooltipRange = tooltipData.range,
      toolipMarker = tooltipData.marker,
      tooltipBullet = tooltipData.bullet;
  return [].concat(bulletSeries_toConsumableArray(range.map(function (m, index) {
    return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
      data: tooltipRange[index]
    });
  })), bulletSeries_toConsumableArray(bullet.map(function (m, index) {
    return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
      data: tooltipBullet[index]
    });
  })), bulletSeries_toConsumableArray(marker.map(function (m, index) {
    return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
      detectionSize: MARKER_LINE_DETECTION_SIZE,
      data: toolipMarker[index]
    });
  })));
}

var bulletSeries_BulletSeries = /*#__PURE__*/function (_Component) {
  bulletSeries_inherits(BulletSeries, _Component);

  var _super = bulletSeries_createSuper(BulletSeries);

  function BulletSeries() {
    var _this;

    bulletSeries_classCallCheck(this, BulletSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "models", {
      range: [],
      bullet: [],
      marker: []
    });

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "drawModels", void 0);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "responders", void 0);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "activatedResponders", []);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "theme", void 0);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "eventDetectType", 'point');

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "tooltipRectMap", void 0);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "vertical", false);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var _state$series$bullet;

      var seriesIndex = _ref.seriesIndex,
          state = _ref.state;

      if (!isNumber(seriesIndex)) {
        return;
      }

      var _state$series$bullet$ = (_state$series$bullet = state.series.bullet) === null || _state$series$bullet === void 0 ? void 0 : _state$series$bullet[seriesIndex],
          name = _state$series$bullet$.name;

      var model = _this.filterBulletResponder(_this.responders).filter(function (_ref2) {
        var dataName = _ref2.name;
        return dataName === name;
      });

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getRespondersWithTheme(model, 'select'),
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "showTooltip", function (_ref3) {
      var _state$series$bullet2;

      var seriesIndex = _ref3.seriesIndex,
          state = _ref3.state;

      if (!isNumber(seriesIndex)) {
        return;
      }

      var _state$series$bullet$2 = (_state$series$bullet2 = state.series.bullet) === null || _state$series$bullet2 === void 0 ? void 0 : _state$series$bullet2[seriesIndex],
          name = _state$series$bullet$2.name;

      var models = _this.filterBulletResponder(_this.responders).filter(function (_ref4) {
        var dataName = _ref4.name;
        return dataName === name;
      });

      if (!models.length) {
        return;
      }

      _this.onMousemove({
        responders: models
      });
    });

    return _this;
  }

  bulletSeries_createClass(BulletSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'bullet';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "render",
    value: function render(state) {
      var _options$series,
          _this2 = this;

      var layout = state.layout,
          axes = state.axes,
          series = state.series,
          scale = state.scale,
          legend = state.legend,
          options = state.options,
          theme = state.theme,
          categories = state.categories;

      if (!series.bullet) {
        throw new Error(message.noDataError(this.name));
      }

      this.setEventDetectType(series, options);
      this.theme = theme.series.bullet;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      this.vertical = !!(options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.vertical);
      var labelAxisOnYAxis = isLabelAxisOnYAxis(series, options);

      var _getAxisName = getAxisName(labelAxisOnYAxis),
          labelAxisName = _getAxisName.labelAxisName,
          valueAxisName = _getAxisName.valueAxisName;

      var _getSizeKey = getSizeKey(labelAxisOnYAxis),
          valueSizeKey = _getSizeKey.valueSizeKey;

      var tickDistance = axes[labelAxisName].tickDistance;
      var zeroPosition = axes[valueAxisName].zeroPosition;
      var _scale$valueAxisName$ = scale[valueAxisName].limit,
          min = _scale$valueAxisName$.min,
          max = _scale$valueAxisName$.max;
      var bulletData = series.bullet.data;

      var renderOptions = bulletSeries_objectSpread({
        ratio: this.rect[valueSizeKey] / (max - min),
        tickDistance: tickDistance,
        zeroPosition: zeroPosition
      }, this.getBulletBarWidths(tickDistance));

      var rangeModels = this.renderRanges(bulletData, renderOptions);
      var bulletModels = this.renderBullet(bulletData, renderOptions);
      var markerModels = this.renderMarkers(bulletData, renderOptions);
      this.models.range = rangeModels;
      this.models.bullet = bulletModels;
      this.models.marker = markerModels;

      if (!this.drawModels) {
        this.drawModels = {
          range: rangeModels.map(function (m) {
            return bulletSeries_objectSpread({}, m);
          }),
          bullet: bulletModels.map(function (m) {
            return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
              height: _this2.vertical ? 0 : m.height,
              width: _this2.vertical ? m.width : 0,
              y: _this2.vertical ? m.y + m.height : m.y
            });
          }),
          marker: markerModels.map(function (m) {
            return bulletSeries_objectSpread({}, m);
          })
        };
      }

      var models = {
        range: rangeModels,
        bullet: bulletModels,
        marker: markerModels
      };
      var tooltipData = this.makeTooltipModel(models);
      this.tooltipRectMap = this.makeTooltipRectMap(models, tooltipData);
      this.responders = this.getBulletSeriesResponders(models, tooltipData, axes, categories);

      if (getDataLabelsOptions(options, this.name).visible) {
        this.renderDataLabels(this.getDataLabels([].concat(bulletSeries_toConsumableArray(rangeModels), bulletSeries_toConsumableArray(bulletModels), bulletSeries_toConsumableArray(markerModels)), this.vertical, this.rect[valueSizeKey]));
      }
    }
  }, {
    key: "getDataLabels",
    value: function getDataLabels(seriesModels, vertical, size) {
      var dataLabelTheme = this.theme.dataLabels;
      var bulletLabelTheme = omit(dataLabelTheme, 'marker');
      var useSeriesColor = bulletLabelTheme.useSeriesColor,
          color = bulletLabelTheme.color;
      var marker = dataLabelTheme.marker;
      return seriesModels.filter(function (m) {
        return m.type === 'line' || m.modelType !== 'range';
      }).map(function (m) {
        if (m.type === 'line') {
          return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
            x: vertical ? (m.x + m.x2) / 2 : m.x,
            theme: bulletSeries_objectSpread(bulletSeries_objectSpread({}, marker), {}, {
              color: marker.useSeriesColor ? m.strokeStyle : marker.color
            })
          });
        }

        return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
          direction: vertical ? 'top' : 'right',
          plot: {
            x: 0,
            y: 0,
            size: size
          },
          theme: bulletSeries_objectSpread(bulletSeries_objectSpread({}, bulletLabelTheme), {}, {
            color: useSeriesColor ? m.color : color
          })
        });
      });
    }
  }, {
    key: "setEventDetectType",
    value: function setEventDetectType(series, options) {
      var _options$series2;

      if (options === null || options === void 0 ? void 0 : (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : _options$series2.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }
    }
  }, {
    key: "getBulletSeriesResponders",
    value: function getBulletSeriesResponders(models, tooltipData, axes, categories) {
      return this.eventDetectType === 'grouped' ? responders_makeRectResponderModel(this.rect, this.vertical ? axes.xAxis : axes.yAxis, categories, this.vertical) : makeBulletResponderModel(models, tooltipData);
    }
  }, {
    key: "makeTooltipRectMap",
    value: function makeTooltipRectMap(models, tooltipData) {
      var result = {};
      Object.keys(models).forEach(function (seriesType) {
        models[seriesType].forEach(function (m, index) {
          var label = m.name;

          if (!result[label]) {
            result[label] = [];
          }

          var tooltipModel = bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
            data: tooltipData[seriesType][index]
          });

          result[label].push(tooltipModel);
        });
      });
      return result;
    }
  }, {
    key: "getBulletSeriesModelsFromRectResponders",
    value: function getBulletSeriesModelsFromRectResponders(responders) {
      var _this$tooltipRectMap;

      if (!responders.length) {
        return [];
      }

      return (_this$tooltipRectMap = this.tooltipRectMap[responders[0].label]) !== null && _this$tooltipRectMap !== void 0 ? _this$tooltipRectMap : [];
    }
  }, {
    key: "getGroupedRect",
    value: function getGroupedRect(responders, type) {
      var bulletSeriesModels = this.getBulletSeriesModelsFromRectResponders(responders);
      var _ref5 = this.theme[type].groupedRect,
          color = _ref5.color,
          opacity = _ref5.opacity;
      return bulletSeriesModels.length ? responders.map(function (m) {
        return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
          color: getRGBA(color, opacity)
        });
      }) : [];
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var bulletSeriesModels = this.getBulletSeriesModelsFromRectResponders(responders);
      this.eventBus.emit('renderHoveredSeries', {
        models: [].concat(bulletSeries_toConsumableArray(this.getGroupedRect(responders, 'hover')), bulletSeries_toConsumableArray(this.getRespondersWithTheme(bulletSeriesModels, 'hover'))),
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = bulletSeriesModels;
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref6) {
      var responders = _ref6.responders;

      if (this.eventDetectType === 'grouped') {
        this.onMousemoveGroupedType(responders);
      } else {
        this.eventBus.emit('renderHoveredSeries', {
          models: this.getRespondersWithTheme(responders, 'hover'),
          name: this.name
        });
        this.activatedResponders = responders.length ? [responders[responders.length - 1]] : [];
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref7) {
      var responders = _ref7.responders;

      if (this.selectable) {
        var models = this.eventDetectType === 'grouped' ? [].concat(bulletSeries_toConsumableArray(this.getGroupedRect(responders, 'select')), bulletSeries_toConsumableArray(this.getRespondersWithTheme(this.getBulletSeriesModelsFromRectResponders(responders), 'select'))) : this.getRespondersWithTheme(responders, 'select');
        this.eventBus.emit('renderSelectedSeries', {
          models: models,
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "filterBulletResponder",
    value: function filterBulletResponder(responders) {
      return responders.filter(function (model) {
        var _ref8;

        return ((_ref8 = model) === null || _ref8 === void 0 ? void 0 : _ref8.modelType) === 'bullet';
      });
    }
  }, {
    key: "renderRanges",
    value: function renderRanges(bulletData, _ref9) {
      var _this3 = this;

      var tickDistance = _ref9.tickDistance,
          ratio = _ref9.ratio,
          zeroPosition = _ref9.zeroPosition,
          rangeWidth = _ref9.rangeWidth;
      var rangeModels = [];
      bulletData.forEach(function (_ref10, seriesIndex) {
        var ranges = _ref10.ranges,
            color = _ref10.color,
            name = _ref10.name;
        (ranges !== null && ranges !== void 0 ? ranges : []).forEach(function (range, rangeIndex) {
          if (!isNull(range)) {
            var _range = bulletSeries_slicedToArray(range, 2),
                start = _range[0],
                end = _range[1];

            var barLength = (end - start) * ratio;
            var rangeStartX = getStartX(seriesIndex, tickDistance, rangeWidth);
            rangeModels.push(bulletSeries_objectSpread(bulletSeries_objectSpread({
              type: 'rect',
              name: name,
              color: _this3.getRangeColor(getRGBA(color, _this3.getSeriesOpacity(name)), rangeIndex, name),
              x: _this3.vertical ? rangeStartX : start * ratio + zeroPosition,
              y: _this3.vertical ? zeroPosition - end * ratio : rangeStartX
            }, getRectSize(_this3.vertical, rangeWidth, barLength)), {}, {
              modelType: 'range',
              seriesColor: color,
              tooltipColor: _this3.getRangeColor(color, rangeIndex, name, true),
              value: range
            }));
          }
        });
      });
      return rangeModels;
    }
  }, {
    key: "renderBullet",
    value: function renderBullet(bulletData, _ref11) {
      var _this4 = this;

      var tickDistance = _ref11.tickDistance,
          ratio = _ref11.ratio,
          zeroPosition = _ref11.zeroPosition,
          bulletWidth = _ref11.bulletWidth;
      var _this$theme = this.theme,
          borderColor = _this$theme.borderColor,
          thickness = _this$theme.borderWidth;
      return bulletData.reduce(function (acc, _ref12, seriesIndex) {
        var data = _ref12.data,
            color = _ref12.color,
            name = _ref12.name;

        if (isNull(data)) {
          return bulletSeries_toConsumableArray(acc);
        }

        var bulletLength = Math.max(data * ratio, 2);
        var bulletStartX = getStartX(seriesIndex, tickDistance, bulletWidth);

        var bullet = bulletSeries_objectSpread({
          type: 'rect',
          name: name,
          color: getRGBA(color, _this4.getSeriesOpacity(name)),
          x: _this4.vertical ? bulletStartX : zeroPosition,
          y: _this4.vertical ? zeroPosition - bulletLength : bulletStartX,
          thickness: thickness,
          borderColor: borderColor,
          modelType: 'bullet',
          seriesColor: color,
          tooltipColor: color,
          value: data
        }, getRectSize(_this4.vertical, bulletWidth, bulletLength));

        return [].concat(bulletSeries_toConsumableArray(acc), [bullet]);
      }, []);
    }
  }, {
    key: "renderMarkers",
    value: function renderMarkers(bulletData, _ref13) {
      var _this5 = this;

      var tickDistance = _ref13.tickDistance,
          ratio = _ref13.ratio,
          zeroPosition = _ref13.zeroPosition,
          markerWidth = _ref13.markerWidth;
      var markerLineWidth = this.theme.markerLineWidth;
      var markerModels = [];
      bulletData.forEach(function (_ref14, seriesIndex) {
        var markers = _ref14.markers,
            color = _ref14.color,
            name = _ref14.name;
        var markerStartX = getStartX(seriesIndex, tickDistance, markerWidth);
        (markers !== null && markers !== void 0 ? markers : []).forEach(function (marker) {
          if (!isNull(marker)) {
            var dataPosition = marker * ratio;
            var x = _this5.vertical ? markerStartX : dataPosition + zeroPosition;
            var y = _this5.vertical ? zeroPosition - dataPosition : markerStartX;
            markerModels.push({
              type: 'line',
              name: name,
              x: x,
              y: y,
              x2: _this5.vertical ? x + markerWidth : x,
              y2: _this5.vertical ? y : y + markerWidth,
              strokeStyle: getRGBA(color, _this5.getSeriesOpacity(name)),
              lineWidth: markerLineWidth,
              seriesColor: color,
              tooltipColor: color,
              value: marker
            });
          }
        });
      });
      return markerModels;
    }
  }, {
    key: "makeTooltipModel",
    value: function makeTooltipModel(seriesModels) {
      var range = seriesModels.range,
          bullet = seriesModels.bullet,
          marker = seriesModels.marker;
      return {
        range: this.makeTooltipData(range, 'Range'),
        bullet: this.makeTooltipData(bullet, 'Actual'),
        marker: this.makeTooltipData(marker, 'Marker')
      };
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData(data, title) {
      return data.map(function (m) {
        var name = m.name,
            seriesColor = m.seriesColor,
            tooltipColor = m.tooltipColor,
            value = m.value;
        return {
          label: name,
          color: getRGBA(seriesColor, 1),
          value: [{
            title: title,
            value: value,
            color: tooltipColor
          }],
          templateType: 'bullet'
        };
      });
    }
  }, {
    key: "getBulletBarWidths",
    value: function getBulletBarWidths(tickDistance) {
      var _this$theme2 = this.theme,
          barThemeWidth = _this$theme2.barWidth,
          barWidthRatios = _this$theme2.barWidthRatios;
      var rangeRatio = barWidthRatios.rangeRatio,
          bulletRatio = barWidthRatios.bulletRatio,
          markerRatio = barWidthRatios.markerRatio;
      var barWidth = barThemeWidth ? calculateSizeWithPercentString(tickDistance, barThemeWidth) : tickDistance * DEFAULT_WIDTH_RATIO;
      return {
        rangeWidth: barWidth * rangeRatio,
        bulletWidth: barWidth * bulletRatio,
        markerWidth: barWidth * markerRatio
      };
    }
  }, {
    key: "getRangeColor",
    value: function getRangeColor(seriesColor, rangeIndex, seriesName) {
      var ignoreRestSeriesOpacity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var rangeColors = this.theme.rangeColors;
      var hasThemeRangeColor = Array.isArray(rangeColors) && rangeColors[rangeIndex];
      var color = hasThemeRangeColor ? rangeColors[rangeIndex] : seriesColor;
      var opacity = hasThemeRangeColor ? getAlpha(rangeColors[rangeIndex]) : DEFAULT_BULLET_RANGE_OPACITY[rangeIndex];
      return getRGBA(color, opacity * this.getSeriesOpacity(seriesName, ignoreRestSeriesOpacity));
    }
  }, {
    key: "getSeriesOpacity",
    value: function getSeriesOpacity(seriesName) {
      var ignoreRestSeriesOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var _this$theme3 = this.theme,
          select = _this$theme3.select,
          areaOpacity = _this$theme3.areaOpacity;
      var active = this.activeSeriesMap[seriesName];
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      var restOpacity = ignoreRestSeriesOpacity ? areaOpacity : select.restSeries.areaOpacity;
      var selectedOpacity = active ? select.areaOpacity : restOpacity;
      return selected ? selectedOpacity : areaOpacity;
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _this6 = this;

      var _this$theme$type = this.theme[type],
          color = _this$theme$type.color,
          borderColor = _this$theme$type.borderColor,
          thickness = _this$theme$type.borderWidth;
      return this.filterBulletResponder(responders).map(function (model) {
        return bulletSeries_objectSpread(bulletSeries_objectSpread({}, model), {}, {
          color: color !== null && color !== void 0 ? color : model.tooltipColor,
          thickness: thickness,
          borderColor: borderColor,
          style: [bulletSeries_objectSpread({}, pick(_this6.theme[type], 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY'))]
        });
      });
    }
  }]);

  return BulletSeries;
}(component_Component);


// CONCATENATED MODULE: ./src/charts/bulletChart.ts



















function bulletChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { bulletChart_typeof = function _typeof(obj) { return typeof obj; }; } else { bulletChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return bulletChart_typeof(obj); }

function bulletChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function bulletChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { bulletChart_ownKeys(Object(source), true).forEach(function (key) { bulletChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { bulletChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function bulletChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function bulletChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function bulletChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) bulletChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) bulletChart_defineProperties(Constructor, staticProps); return Constructor; }

function bulletChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { bulletChart_get = Reflect.get; } else { bulletChart_get = function _get(target, property, receiver) { var base = bulletChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return bulletChart_get(target, property, receiver || target); }

function bulletChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = bulletChart_getPrototypeOf(object); if (object === null) break; } return object; }

function bulletChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bulletChart_setPrototypeOf(subClass, superClass); }

function bulletChart_setPrototypeOf(o, p) { bulletChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bulletChart_setPrototypeOf(o, p); }

function bulletChart_createSuper(Derived) { var hasNativeReflectConstruct = bulletChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bulletChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bulletChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bulletChart_possibleConstructorReturn(this, result); }; }

function bulletChart_possibleConstructorReturn(self, call) { if (call && (bulletChart_typeof(call) === "object" || typeof call === "function")) { return call; } return bulletChart_assertThisInitialized(self); }

function bulletChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function bulletChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function bulletChart_getPrototypeOf(o) { bulletChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bulletChart_getPrototypeOf(o); }

function bulletChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

























/**
 * @class
 * @classdesc Bullet Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Bullet Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *       @param {Array<number>} props.data.series.markers - Series markers. It specifies the marker for comparing.
 *       @param {Array<Array<number>>} props.data.series.ranges - Series ranges. It specifies the range of values that can be compared.
 *   @param {Object} [props.options] - Options for making Bullet Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {number} [props.options.series.vertical] - Whether to use vertical bullet series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object} [props.options.yAxis]
 *       @param {Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Bullets Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var bulletChart_BulletChart = /*#__PURE__*/function (_Chart) {
  bulletChart_inherits(BulletChart, _Chart);

  var _super = bulletChart_createSuper(BulletChart);

  function BulletChart(_ref) {
    var _this;

    var el = _ref.el,
        _options = _ref.options,
        series = _ref.data.series;

    bulletChart_classCallCheck(this, BulletChart);

    _this = _super.call(this, {
      el: el,
      options: _options,
      series: {
        bullet: series
      },
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });

    bulletChart_defineProperty(bulletChart_assertThisInitialized(_this), "hideSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    });

    bulletChart_defineProperty(bulletChart_assertThisInitialized(_this), "showSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    });

    bulletChart_defineProperty(bulletChart_assertThisInitialized(_this), "setOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('initOptions', options);
    });

    bulletChart_defineProperty(bulletChart_assertThisInitialized(_this), "updateOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', options);
    });

    bulletChart_defineProperty(bulletChart_assertThisInitialized(_this), "showTooltip", function (seriesInfo) {
      _this.eventBus.emit('showTooltip', bulletChart_objectSpread(bulletChart_objectSpread({}, seriesInfo), {}, {
        state: _this.store.state
      }));
    });

    bulletChart_defineProperty(bulletChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  bulletChart_createClass(BulletChart, [{
    key: "initialize",
    value: function initialize() {
      bulletChart_get(bulletChart_getPrototypeOf(BulletChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(title_Title);
      this.componentManager.add(plot_Plot);
      this.componentManager.add(legend_Legend);
      this.componentManager.add(bulletSeries_BulletSeries);
      this.componentManager.add(axis_Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(exportMenu_ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(hoveredSeries_HoveredSeries);
      this.componentManager.add(selectedSeries_SelectedSeries);
      this.componentManager.add(dataLabels_DataLabels);
      this.componentManager.add(tooltip_Tooltip, {
        chartEl: this.el
      });
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added
     *   @param {string} data.name - Series name
     *   @param {Array<<Array<number>>} data.data - Array of data to be added
     *   @param {Array<number>} data.markers - Series markers. It specifies the marker for comparing.
     *   @param {Array<Array<number>>} data.ranges - Series ranges. It specifies the range of values that can be compared.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: 20,
     *   markers: [28, 2, 15],
     *   ranges: [
     *     [-1, 10],
     *     [10, 20],
     *     [20, 30],
     *   ],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   series: [
     *     {
     *       name: 'newSeries',
     *       data: 20,
     *       markers: [28, 2, 15],
     *       ranges: [
     *         [-1, 10],
     *         [10, 20],
     *         [20, 30],
     *       ],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          bullet: data.series
        }
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }]);

  return BulletChart;
}(chart_Chart);


// CONCATENATED MODULE: ./src/store/nestedPieSeriesData.ts













function nestedPieSeriesData_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function nestedPieSeriesData_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { nestedPieSeriesData_ownKeys(Object(source), true).forEach(function (key) { nestedPieSeriesData_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { nestedPieSeriesData_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function nestedPieSeriesData_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function findRootName(rawSeries, seriesIndex, parentName) {
  var _ref;

  var item = (_ref = rawSeries.pie) === null || _ref === void 0 ? void 0 : _ref[seriesIndex].data.find(function (_ref2) {
    var name = _ref2.name;
    return name === parentName;
  });
  return (item === null || item === void 0 ? void 0 : item.parentName) ? findRootName(rawSeries, seriesIndex - 1, item.parentName) : parentName;
}

var nestedPieSeriesData = {
  name: 'seriesData',
  state: function state() {
    return {
      nestedPieSeries: {}
    };
  },
  action: {
    setNestedPieSeriesData: function setNestedPieSeriesData(_ref3) {
      var state = _ref3.state,
          initStoreState = _ref3.initStoreState;
      var theme = state.theme,
          disabledSeries = state.disabledSeries;
      var rawSeries = initStoreState.series;
      var newSeriesData = {};
      var colorMap = {};
      rawSeries.pie.forEach(function (_ref4, seriesIndex) {
        var alias = _ref4.name,
            data = _ref4.data;
        var colors = theme.series.pie[alias].colors;
        var colorList = [];
        var originSeriesData = data.map(function (m, index) {
          var parentName = m.parentName,
              dataName = m.name;
          var color = parentName && seriesIndex ? colorMap[parentName] : colors === null || colors === void 0 ? void 0 : colors[index];
          colorList.push(color);
          colorMap[dataName] = color;
          var rootParentName = parentName && seriesIndex ? findRootName(rawSeries, seriesIndex - 1, parentName) : dataName;
          return nestedPieSeriesData_objectSpread(nestedPieSeriesData_objectSpread({}, m), {}, {
            data: m.data,
            rootParentName: rootParentName,
            color: color
          });
        });
        newSeriesData[alias] = {
          data: originSeriesData.filter(function (_ref5) {
            var rootParentName = _ref5.rootParentName;
            return !disabledSeries.includes(rootParentName);
          }),
          colors: colorList
        };
      });
      state.nestedPieSeries = newSeriesData;
      this.dispatch('updateNestedPieChartLegend');
    }
  },
  observe: {
    updateNestedPieSeriesData: function updateNestedPieSeriesData() {
      this.dispatch('setNestedPieSeriesData');
    }
  }
};
/* harmony default export */ var store_nestedPieSeriesData = (nestedPieSeriesData);
// CONCATENATED MODULE: ./src/charts/nestedPieChart.ts




















function nestedPieChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { nestedPieChart_typeof = function _typeof(obj) { return typeof obj; }; } else { nestedPieChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return nestedPieChart_typeof(obj); }

function nestedPieChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function nestedPieChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { nestedPieChart_ownKeys(Object(source), true).forEach(function (key) { nestedPieChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { nestedPieChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function nestedPieChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function nestedPieChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function nestedPieChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) nestedPieChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) nestedPieChart_defineProperties(Constructor, staticProps); return Constructor; }

function nestedPieChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { nestedPieChart_get = Reflect.get; } else { nestedPieChart_get = function _get(target, property, receiver) { var base = nestedPieChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return nestedPieChart_get(target, property, receiver || target); }

function nestedPieChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = nestedPieChart_getPrototypeOf(object); if (object === null) break; } return object; }

function nestedPieChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) nestedPieChart_setPrototypeOf(subClass, superClass); }

function nestedPieChart_setPrototypeOf(o, p) { nestedPieChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return nestedPieChart_setPrototypeOf(o, p); }

function nestedPieChart_createSuper(Derived) { var hasNativeReflectConstruct = nestedPieChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = nestedPieChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = nestedPieChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return nestedPieChart_possibleConstructorReturn(this, result); }; }

function nestedPieChart_possibleConstructorReturn(self, call) { if (call && (nestedPieChart_typeof(call) === "object" || typeof call === "function")) { return call; } return nestedPieChart_assertThisInitialized(self); }

function nestedPieChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function nestedPieChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function nestedPieChart_getPrototypeOf(o) { nestedPieChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return nestedPieChart_getPrototypeOf(o); }

function nestedPieChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



















/**
 * @class
 * @classdesc NestedPie Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making NestedPie Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *       @param {string} [props.data.series.parentName] - Value specifying parent data when using group nested pie chart.
 *   @param {Object} [props.options] - Options for making NestedPie Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {Object} [props.options.series.aliasName] - Chart options are specified based on the alias name. 'radiusRange', 'angleRange', 'clockwise', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|NestedPie Chart guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|NestedPie Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var nestedPieChart_NestedPieChart = /*#__PURE__*/function (_Chart) {
  nestedPieChart_inherits(NestedPieChart, _Chart);

  var _super = nestedPieChart_createSuper(NestedPieChart);

  function NestedPieChart(_ref) {
    var _this;

    var el = _ref.el,
        _options = _ref.options,
        _ref$data = _ref.data,
        series = _ref$data.series,
        categories = _ref$data.categories;

    nestedPieChart_classCallCheck(this, NestedPieChart);

    _this = _super.call(this, {
      el: el,
      options: _options,
      series: {
        pie: series
      },
      categories: categories,
      modules: [store_nestedPieSeriesData]
    });

    nestedPieChart_defineProperty(nestedPieChart_assertThisInitialized(_this), "hideSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    });

    nestedPieChart_defineProperty(nestedPieChart_assertThisInitialized(_this), "showSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    });

    nestedPieChart_defineProperty(nestedPieChart_assertThisInitialized(_this), "setOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('initOptions', options);
    });

    nestedPieChart_defineProperty(nestedPieChart_assertThisInitialized(_this), "updateOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', options);
    });

    nestedPieChart_defineProperty(nestedPieChart_assertThisInitialized(_this), "showTooltip", function (seriesInfo) {
      _this.eventBus.emit('showTooltip', nestedPieChart_objectSpread({}, seriesInfo));
    });

    nestedPieChart_defineProperty(nestedPieChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  nestedPieChart_createClass(NestedPieChart, [{
    key: "initialize",
    value: function initialize() {
      var _this$store$initStore,
          _this2 = this;

      nestedPieChart_get(nestedPieChart_getPrototypeOf(NestedPieChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(title_Title);
      this.componentManager.add(legend_Legend);
      ((_this$store$initStore = this.store.initStoreState.series.pie) !== null && _this$store$initStore !== void 0 ? _this$store$initStore : []).forEach(function (_ref2) {
        var name = _ref2.name;

        _this2.componentManager.add(pieSeries_PieSeries, {
          alias: name
        });
      });
      this.componentManager.add(exportMenu_ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(hoveredSeries_HoveredSeries);
      this.componentManager.add(selectedSeries_SelectedSeries);
      this.componentManager.add(dataLabels_DataLabels);
      this.componentManager.add(tooltip_Tooltip, {
        chartEl: this.el
      });
      this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, brushes_sector_namespaceObject, dataLabel_namespaceObject]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Which name of chart to add.
     *   @param {string} dataInfo.name - Chart series name.
     * @api
     * @example
     * chart.addSeries(
     *   {
     *     name: 'newSeries',
     *     data: [
     *       { name: 'A', data: 10 },
     *       { name: 'B', data: 20 },
     *     ],
     *   },
     *   {
     *     name: 'series name'
     *   });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data, dataInfo) {
      this.resetSeries();
      this.store.dispatch('addSeries', nestedPieChart_objectSpread({
        data: data
      }, dataInfo));
      this.componentManager.add(pieSeries_PieSeries, {
        alias: data.name
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['A', 'B'],
     *   series: [
     *     {
     *       name: 'browsers',
     *       data: [
     *         {
     *           name: 'Chrome',
     *           data: 50,
     *         },
     *         {
     *           name: 'Safari',
     *           data: 20,
     *         },
     *       ]
     *     },
     *     {
     *       name: 'versions',
     *       data: [
     *         {
     *           name: '1',
     *           data: 50,
     *         },
     *         {
     *           name: '2',
     *           data: 20,
     *         },
     *       ]
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var _this$store$initStore2,
          _this3 = this;

      this.componentManager.remove(pieSeries_PieSeries);
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          pie: data.series
        }
      });
      ((_this$store$initStore2 = this.store.initStoreState.series.pie) !== null && _this$store$initStore2 !== void 0 ? _this$store$initStore2 : []).forEach(function (_ref3) {
        var name = _ref3.name;

        _this3.componentManager.add(pieSeries_PieSeries, {
          alias: name
        });
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }]);

  return NestedPieChart;
}(chart_Chart);


// CONCATENATED MODULE: ./src/component/radarSeries.ts




























function radarSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radarSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { radarSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radarSeries_typeof(obj); }

function radarSeries_toConsumableArray(arr) { return radarSeries_arrayWithoutHoles(arr) || radarSeries_iterableToArray(arr) || radarSeries_unsupportedIterableToArray(arr) || radarSeries_nonIterableSpread(); }

function radarSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function radarSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return radarSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return radarSeries_arrayLikeToArray(o, minLen); }

function radarSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function radarSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return radarSeries_arrayLikeToArray(arr); }

function radarSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function radarSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function radarSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radarSeries_ownKeys(Object(source), true).forEach(function (key) { radarSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radarSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function radarSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function radarSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function radarSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) radarSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) radarSeries_defineProperties(Constructor, staticProps); return Constructor; }

function radarSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radarSeries_setPrototypeOf(subClass, superClass); }

function radarSeries_setPrototypeOf(o, p) { radarSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radarSeries_setPrototypeOf(o, p); }

function radarSeries_createSuper(Derived) { var hasNativeReflectConstruct = radarSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = radarSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = radarSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return radarSeries_possibleConstructorReturn(this, result); }; }

function radarSeries_possibleConstructorReturn(self, call) { if (call && (radarSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return radarSeries_assertThisInitialized(self); }

function radarSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function radarSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function radarSeries_getPrototypeOf(o) { radarSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radarSeries_getPrototypeOf(o); }

function radarSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










var NONE_AREA_OPACITY = 0;
var radarSeries_seriesOpacity = {
  INACTIVE: 0.2,
  ACTIVE: 1
};

var radarSeries_RadarSeries = /*#__PURE__*/function (_Component) {
  radarSeries_inherits(RadarSeries, _Component);

  var _super = radarSeries_createSuper(RadarSeries);

  function RadarSeries() {
    var _this;

    radarSeries_classCallCheck(this, RadarSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "models", {
      area: [],
      line: [],
      dot: []
    });

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "drawModels", void 0);

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "responders", void 0);

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "activatedResponders", []);

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "theme", void 0);

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var index = _ref.index,
          seriesIndex = _ref.seriesIndex,
          state = _ref.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.radar.data[seriesIndex].name;

      var model = _this.responders.filter(function (_ref2) {
        var dataName = _ref2.name;
        return dataName === name;
      })[index];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getRespondersWithTheme([model], 'select'),
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "showTooltip", function (_ref3) {
      var index = _ref3.index,
          seriesIndex = _ref3.seriesIndex,
          state = _ref3.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.radar.data[seriesIndex].name;
      var models = [_this.responders.filter(function (_ref4) {
        var dataName = _ref4.name;
        return dataName === name;
      })[index]];

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: _this.getRespondersWithTheme(models, 'hover'),
        name: _this.name
      });

      _this.activatedResponders = models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  radarSeries_createClass(RadarSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'radar';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "render",
    value: function render(state) {
      var _options$series$showA, _options$series, _series$radar, _options$series2, _options$series3;

      var layout = state.layout,
          axes = state.axes,
          series = state.series,
          legend = state.legend,
          options = state.options,
          theme = state.theme,
          scale = state.scale;

      if (!series.radar) {
        throw new Error(message.noDataError(this.name));
      }

      this.theme = theme.series.radar;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var categories = state.categories;
      var _ref5 = axes.radialAxis,
          axisSize = _ref5.axisSize,
          centerX = _ref5.centerX,
          centerY = _ref5.centerY;
      var _scale$yAxis = scale.yAxis,
          limit = _scale$yAxis.limit,
          stepSize = _scale$yAxis.stepSize;
      var labels = makeLabelsFromLimit(limit, stepSize);

      var _getLimitOnAxis = getLimitOnAxis(labels),
          min = _getLimitOnAxis.min,
          max = _getLimitOnAxis.max;

      var renderOptions = {
        categories: categories,
        degree: 360 / categories.length,
        centerX: centerX,
        centerY: centerY,
        showArea: (_options$series$showA = options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.showArea) !== null && _options$series$showA !== void 0 ? _options$series$showA : false,
        ratio: axisSize / (max - min)
      };
      var radarData = (_series$radar = series.radar) === null || _series$radar === void 0 ? void 0 : _series$radar.data;
      var radarPointsData = this.makeRadarPointsData(radarData, renderOptions);
      var circleModel = this.renderDotModels(radarPointsData);
      this.models.area = (options === null || options === void 0 ? void 0 : (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : _options$series2.showArea) ? this.renderAreaModels(radarPointsData) : [];
      this.models.line = this.renderLineModels(radarPointsData);
      this.models.dot = (options === null || options === void 0 ? void 0 : (_options$series3 = options.series) === null || _options$series3 === void 0 ? void 0 : _options$series3.showDot) ? circleModel : [];

      if (!this.drawModels) {
        this.drawModels = {
          area: this.initDrawModels('area', centerX, centerY),
          line: this.initDrawModels('line', centerX, centerY),
          dot: this.models.dot.map(function (m) {
            return radarSeries_objectSpread(radarSeries_objectSpread({}, m), {}, {
              x: centerX,
              y: centerY
            });
          })
        };
      }

      var tooltipDataArr = this.makeTooltipModel(circleModel, categories);
      this.responders = circleModel.map(function (m, index) {
        return radarSeries_objectSpread(radarSeries_objectSpread({}, m), {}, {
          data: tooltipDataArr[index],
          color: getRGBA(m.color, 1)
        });
      });
    }
  }, {
    key: "initDrawModels",
    value: function initDrawModels(modelName, centerX, centerY) {
      return this.models[modelName].map(function (m) {
        var _m$distances;

        return radarSeries_objectSpread(radarSeries_objectSpread({}, m), {}, {
          distances: (_m$distances = m.distances) === null || _m$distances === void 0 ? void 0 : _m$distances.map(function () {
            return 0;
          }),
          points: m.points.map(function () {
            return {
              x: centerX,
              y: centerY
            };
          })
        });
      });
    }
  }, {
    key: "makeTooltipModel",
    value: function makeTooltipModel(circleModel, categories) {
      return circleModel.map(function (_ref6) {
        var name = _ref6.name,
            color = _ref6.color,
            value = _ref6.value,
            index = _ref6.index;
        return {
          label: name,
          color: color,
          value: value,
          category: categories[index]
        };
      });
    }
  }, {
    key: "makeTooltipModel2",
    value: function makeTooltipModel2(seriesData, categories) {
      return seriesData.flatMap(function (_ref7) {
        var data = _ref7.data,
            name = _ref7.name,
            color = _ref7.color;
        return data.filter(function (value) {
          return !isNull(value);
        }).map(function (value, dataIndex) {
          return {
            label: name,
            color: color,
            value: value,
            category: categories[dataIndex]
          };
        });
      });
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _ref8 = this.theme[type].dot,
          radius = _ref8.radius,
          borderWidth = _ref8.borderWidth,
          borderColor = _ref8.borderColor,
          color = _ref8.color;
      return responders.map(function (responder) {
        var modelColor = color !== null && color !== void 0 ? color : responder.color;
        return radarSeries_objectSpread(radarSeries_objectSpread({}, responder), {}, {
          radius: radius,
          color: modelColor,
          style: [{
            lineWidth: borderWidth,
            strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5)
          }]
        });
      });
    }
  }, {
    key: "onClick",
    value: function onClick(_ref9) {
      var responders = _ref9.responders;

      if (this.selectable) {
        this.eventBus.emit('renderSelectedSeries', {
          models: this.getRespondersWithTheme(responders, 'select'),
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref10) {
      var responders = _ref10.responders;
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getRespondersWithTheme(responders, 'hover'),
        name: this.name
      });
      this.activatedResponders = responders;
      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "makeRadarPointsData",
    value: function makeRadarPointsData(seriesData, renderOptions) {
      var _this2 = this;

      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          degree = renderOptions.degree,
          ratio = renderOptions.ratio,
          showArea = renderOptions.showArea;
      return seriesData.map(function (_ref11) {
        var data = _ref11.data,
            seriesColor = _ref11.color,
            name = _ref11.name;
        var radarPoints = data.reduce(function (acc, value, index) {
          if (isNull(value)) {
            return {
              distances: [].concat(radarSeries_toConsumableArray(acc.distances), [0]),
              linePoints: [].concat(radarSeries_toConsumableArray(acc.linePoints), [null]),
              areaPoints: [].concat(radarSeries_toConsumableArray(acc.areaPoints), [{
                x: centerX,
                y: centerY
              }])
            };
          }

          var distance = value * ratio;
          var point = getRadialPosition(centerX, centerY, distance, calculateDegreeToRadian(degree * index));
          return {
            distances: [].concat(radarSeries_toConsumableArray(acc.distances), [distance]),
            linePoints: [].concat(radarSeries_toConsumableArray(acc.linePoints), [point]),
            areaPoints: [].concat(radarSeries_toConsumableArray(acc.areaPoints), [point])
          };
        }, {
          linePoints: [],
          distances: [],
          areaPoints: []
        });

        if (!isNull(data[0]) && !isNull(data[data.length - 1])) {
          radarPoints.linePoints.push(radarPoints.linePoints[0]);
          radarPoints.areaPoints.push(radarPoints.areaPoints[0]);
        }

        return radarSeries_objectSpread(radarSeries_objectSpread({
          name: name,
          seriesColor: seriesColor,
          data: data
        }, radarPoints), _this2.getSeriesColor(showArea, seriesColor, name));
      });
    }
  }, {
    key: "renderAreaModels",
    value: function renderAreaModels(radarPointsData) {
      return radarPointsData.map(function (_ref12) {
        var distances = _ref12.distances,
            areaPoints = _ref12.areaPoints,
            name = _ref12.name,
            fillColor = _ref12.fillColor,
            seriesColor = _ref12.seriesColor;
        return {
          type: 'areaPoints',
          name: name,
          distances: distances,
          points: areaPoints,
          fillColor: fillColor,
          color: getRGBA(seriesColor, 0),
          lineWidth: 0
        };
      });
    }
  }, {
    key: "renderLineModels",
    value: function renderLineModels(radarPointsData) {
      var _this$theme = this.theme,
          lineWidth = _this$theme.lineWidth,
          dashSegments = _this$theme.dashSegments;
      return radarPointsData.map(function (_ref13) {
        var distances = _ref13.distances,
            linePoints = _ref13.linePoints,
            name = _ref13.name,
            lineColor = _ref13.lineColor;
        return {
          type: 'linePoints',
          lineWidth: lineWidth !== null && lineWidth !== void 0 ? lineWidth : radarDefault.LINE_WIDTH,
          name: name,
          distances: distances,
          points: linePoints,
          color: lineColor,
          dashSegments: dashSegments
        };
      });
    }
  }, {
    key: "renderDotModels",
    value: function renderDotModels(radarPointsData) {
      var _ref14 = this.theme.dot,
          radius = _ref14.radius,
          dotColor = _ref14.color;
      var result = [];
      radarPointsData.forEach(function (_ref15, seriesIndex) {
        var linePoints = _ref15.linePoints,
            lineColor = _ref15.lineColor,
            name = _ref15.name,
            data = _ref15.data;
        return linePoints.slice(0, linePoints.length - 1).forEach(function (point, index) {
          if (!isNull(point)) {
            result.push(radarSeries_objectSpread(radarSeries_objectSpread({
              type: 'circle'
            }, point), {}, {
              radius: radius,
              color: dotColor !== null && dotColor !== void 0 ? dotColor : lineColor,
              style: [{
                strokeStyle: 'rgba(0, 0, 0, 0)'
              }],
              name: name,
              seriesIndex: seriesIndex,
              index: index,
              value: data === null || data === void 0 ? void 0 : data[index]
            }));
          }
        });
      });
      return result;
    }
  }, {
    key: "getSeriesColor",
    value: function getSeriesColor(showArea, seriesColor, name) {
      var active = this.activeSeriesMap[name];
      var _this$theme2 = this.theme,
          select = _this$theme2.select,
          areaOpacity = _this$theme2.areaOpacity;
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      var color = getRGBA(seriesColor, active ? radarSeries_seriesOpacity.ACTIVE : radarSeries_seriesOpacity.INACTIVE);
      var fillOpacity = NONE_AREA_OPACITY;

      if (showArea) {
        var selectedAreaOpacity = active ? select.areaOpacity : select.restSeries.areaOpacity;
        fillOpacity = selected ? selectedAreaOpacity : areaOpacity;
      }

      return {
        lineColor: color,
        fillColor: getRGBA(color, fillOpacity)
      };
    }
  }]);

  return RadarSeries;
}(component_Component);


// CONCATENATED MODULE: ./src/helpers/radarSeries.ts


function getRadialRadiusValues(labels, size) {
  var deleteCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var result = labels.map(function (_, index) {
    return index / (labels.length - 1) * size;
  });

  if (deleteCount) {
    result.splice(result.length - deleteCount);
  }

  return result;
}
// CONCATENATED MODULE: ./src/component/radarPlot.ts






















function radarPlot_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radarPlot_typeof = function _typeof(obj) { return typeof obj; }; } else { radarPlot_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radarPlot_typeof(obj); }

function radarPlot_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function radarPlot_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radarPlot_ownKeys(Object(source), true).forEach(function (key) { radarPlot_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radarPlot_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function radarPlot_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function radarPlot_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function radarPlot_createClass(Constructor, protoProps, staticProps) { if (protoProps) radarPlot_defineProperties(Constructor.prototype, protoProps); if (staticProps) radarPlot_defineProperties(Constructor, staticProps); return Constructor; }

function radarPlot_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radarPlot_setPrototypeOf(subClass, superClass); }

function radarPlot_setPrototypeOf(o, p) { radarPlot_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radarPlot_setPrototypeOf(o, p); }

function radarPlot_createSuper(Derived) { var hasNativeReflectConstruct = radarPlot_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = radarPlot_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = radarPlot_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return radarPlot_possibleConstructorReturn(this, result); }; }

function radarPlot_possibleConstructorReturn(self, call) { if (call && (radarPlot_typeof(call) === "object" || typeof call === "function")) { return call; } return radarPlot_assertThisInitialized(self); }

function radarPlot_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function radarPlot_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function radarPlot_getPrototypeOf(o) { radarPlot_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radarPlot_getPrototypeOf(o); }

function radarPlot_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var CATEGORY_LABEL_PADDING = 35;

var radarPlot_RadarPlot = /*#__PURE__*/function (_Component) {
  radarPlot_inherits(RadarPlot, _Component);

  var _super = radarPlot_createSuper(RadarPlot);

  function RadarPlot() {
    var _this;

    radarPlot_classCallCheck(this, RadarPlot);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    radarPlot_defineProperty(radarPlot_assertThisInitialized(_this), "models", {
      plot: [],
      dot: [],
      label: []
    });

    return _this;
  }

  radarPlot_createClass(RadarPlot, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'plot';
      this.name = 'radar';
    }
  }, {
    key: "render",
    value: function render(state) {
      var _ref, _options$plot;

      var layout = state.layout,
          axes = state.axes,
          options = state.options;
      this.rect = layout.plot;
      var categories = (_ref = state.categories) !== null && _ref !== void 0 ? _ref : [];
      var renderOptions = this.makeRenderOptions(axes.radialAxis, (_options$plot = options.plot) === null || _options$plot === void 0 ? void 0 : _options$plot.type, categories);
      this.models = {
        plot: this.renderPlot(renderOptions),
        dot: this.renderCategoryDot(renderOptions),
        label: this.renderCategoryLabel(renderOptions)
      };
    }
  }, {
    key: "makeRenderOptions",
    value: function makeRenderOptions(radialAxis) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'spiderweb';
      var categories = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var labels = radialAxis.labels,
          axisSize = radialAxis.axisSize,
          centerX = radialAxis.centerX,
          centerY = radialAxis.centerY;
      return {
        type: type,
        categories: categories,
        degree: 360 / categories.length,
        centerX: centerX,
        centerY: centerY,
        seriesRadius: axisSize,
        radiusRange: getRadialRadiusValues(labels, axisSize).slice(1, labels.length)
      };
    }
  }, {
    key: "renderPlot",
    value: function renderPlot(renderOptions) {
      return renderOptions.type === 'spiderweb' ? this.makeSpiderwebPlot(renderOptions) : this.makeCirclePlot(renderOptions);
    }
  }, {
    key: "makeSpiderwebPlot",
    value: function makeSpiderwebPlot(renderOptions) {
      var degree = renderOptions.degree,
          centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          categories = renderOptions.categories,
          radiusRange = renderOptions.radiusRange;
      return radiusRange.map(function (radius) {
        var points = categories.map(function (_, index) {
          return getRadialPosition(centerX, centerY, radius, calculateDegreeToRadian(degree * index));
        });
        return {
          type: 'polygon',
          color: 'rgba(0, 0, 0, 0.05)',
          lineWidth: 1,
          points: points
        };
      });
    }
  }, {
    key: "makeCirclePlot",
    value: function makeCirclePlot(renderOptions) {
      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          radiusRange = renderOptions.radiusRange;
      return radiusRange.map(function (radius) {
        return {
          type: 'circle',
          color: 'rgba(0, 0, 0, 0)',
          style: ['plot'],
          radius: radius,
          x: centerX,
          y: centerY
        };
      });
    }
  }, {
    key: "renderCategoryDot",
    value: function renderCategoryDot(renderOptions) {
      var degree = renderOptions.degree,
          centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          categories = renderOptions.categories,
          seriesRadius = renderOptions.seriesRadius;
      return categories.map(function (_, index) {
        var _getRadialPosition = getRadialPosition(centerX, centerY, seriesRadius, calculateDegreeToRadian(degree * index)),
            x = _getRadialPosition.x,
            y = _getRadialPosition.y;

        return {
          type: 'rect',
          color: 'rgba(0, 0, 0, .5)',
          width: 4,
          height: 4,
          x: x - 2,
          y: y - 2
        };
      });
    }
  }, {
    key: "renderCategoryLabel",
    value: function renderCategoryLabel(renderOptions) {
      var degree = renderOptions.degree,
          centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          categories = renderOptions.categories,
          seriesRadius = renderOptions.seriesRadius;
      var radius = seriesRadius + CATEGORY_LABEL_PADDING;
      return categories.map(function (text, index) {
        return radarPlot_objectSpread({
          type: 'label',
          style: ['default', {
            textAlign: 'center'
          }],
          text: text
        }, getRadialPosition(centerX, centerY, radius, calculateDegreeToRadian(degree * index)));
      });
    }
  }]);

  return RadarPlot;
}(component_Component);


// CONCATENATED MODULE: ./src/component/radialAxis.ts























function radialAxis_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radialAxis_typeof = function _typeof(obj) { return typeof obj; }; } else { radialAxis_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radialAxis_typeof(obj); }

function radialAxis_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function radialAxis_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radialAxis_ownKeys(Object(source), true).forEach(function (key) { radialAxis_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radialAxis_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function radialAxis_toConsumableArray(arr) { return radialAxis_arrayWithoutHoles(arr) || radialAxis_iterableToArray(arr) || radialAxis_unsupportedIterableToArray(arr) || radialAxis_nonIterableSpread(); }

function radialAxis_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function radialAxis_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return radialAxis_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return radialAxis_arrayLikeToArray(o, minLen); }

function radialAxis_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function radialAxis_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return radialAxis_arrayLikeToArray(arr); }

function radialAxis_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function radialAxis_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function radialAxis_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function radialAxis_createClass(Constructor, protoProps, staticProps) { if (protoProps) radialAxis_defineProperties(Constructor.prototype, protoProps); if (staticProps) radialAxis_defineProperties(Constructor, staticProps); return Constructor; }

function radialAxis_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radialAxis_setPrototypeOf(subClass, superClass); }

function radialAxis_setPrototypeOf(o, p) { radialAxis_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radialAxis_setPrototypeOf(o, p); }

function radialAxis_createSuper(Derived) { var hasNativeReflectConstruct = radialAxis_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = radialAxis_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = radialAxis_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return radialAxis_possibleConstructorReturn(this, result); }; }

function radialAxis_possibleConstructorReturn(self, call) { if (call && (radialAxis_typeof(call) === "object" || typeof call === "function")) { return call; } return radialAxis_assertThisInitialized(self); }

function radialAxis_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function radialAxis_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function radialAxis_getPrototypeOf(o) { radialAxis_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radialAxis_getPrototypeOf(o); }

function radialAxis_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var radialAxis_padding = {
  X: 5,
  Y: 1
};
var RADIAL_AXIS_LABEL_RECT_BORDER_RADIUS = 7;

function filterDisplayLabels(labels) {
  return labels.slice(1, labels.length - 1);
}

var radialAxis_RadialAxis = /*#__PURE__*/function (_Component) {
  radialAxis_inherits(RadialAxis, _Component);

  var _super = radialAxis_createSuper(RadialAxis);

  function RadialAxis() {
    var _this;

    radialAxis_classCallCheck(this, RadialAxis);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    radialAxis_defineProperty(radialAxis_assertThisInitialized(_this), "models", []);

    return _this;
  }

  radialAxis_createClass(RadialAxis, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'axis';
      this.name = 'radial';
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout,
          axes = _ref.axes;
      this.rect = layout.plot;

      if (!axes.radialAxis) {
        return;
      }

      var _ref2 = axes.radialAxis,
          axisSize = _ref2.axisSize,
          centerX = _ref2.centerX,
          centerY = _ref2.centerY,
          labels = _ref2.labels,
          maxLabelWidth = _ref2.maxLabelWidth,
          maxLabelHeight = _ref2.maxLabelHeight,
          labelInterval = _ref2.labelInterval;
      var radiusRange = filterDisplayLabels(getRadialRadiusValues(labels, axisSize));
      var width = maxLabelWidth + radialAxis_padding.X * 2;
      var height = maxLabelHeight + radialAxis_padding.Y * 2;
      var viewLabels = filterDisplayLabels(labels);
      this.models = viewLabels.reduce(function (positions, text, index) {
        return index % labelInterval ? positions : [].concat(radialAxis_toConsumableArray(positions), [radialAxis_objectSpread({
          type: 'rectLabel',
          text: text,
          style: ['rectLabel'],
          width: width,
          height: height,
          borderRadius: RADIAL_AXIS_LABEL_RECT_BORDER_RADIUS,
          backgroundColor: '#f3f3f3'
        }, getRadialPosition(centerX, centerY, radiusRange[index], calculateDegreeToRadian(0)))]);
      }, []);
    }
  }]);

  return RadialAxis;
}(component_Component);


// CONCATENATED MODULE: ./src/charts/radarChart.ts



















function radarChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radarChart_typeof = function _typeof(obj) { return typeof obj; }; } else { radarChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radarChart_typeof(obj); }

function radarChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function radarChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radarChart_ownKeys(Object(source), true).forEach(function (key) { radarChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radarChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function radarChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function radarChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function radarChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) radarChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) radarChart_defineProperties(Constructor, staticProps); return Constructor; }

function radarChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { radarChart_get = Reflect.get; } else { radarChart_get = function _get(target, property, receiver) { var base = radarChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return radarChart_get(target, property, receiver || target); }

function radarChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = radarChart_getPrototypeOf(object); if (object === null) break; } return object; }

function radarChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radarChart_setPrototypeOf(subClass, superClass); }

function radarChart_setPrototypeOf(o, p) { radarChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radarChart_setPrototypeOf(o, p); }

function radarChart_createSuper(Derived) { var hasNativeReflectConstruct = radarChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = radarChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = radarChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return radarChart_possibleConstructorReturn(this, result); }; }

function radarChart_possibleConstructorReturn(self, call) { if (call && (radarChart_typeof(call) === "object" || typeof call === "function")) { return call; } return radarChart_assertThisInitialized(self); }

function radarChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function radarChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function radarChart_getPrototypeOf(o) { radarChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radarChart_getPrototypeOf(o); }

function radarChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }























/**
 * @class
 * @classdesc Radar Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Radar Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<number>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Radar Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.showDot=false] - Whether to show dot or not.
 *       @param {boolean} [props.options.series.showArea=false] - Whether to fill area or not.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.type] - Radar plot type. 'spiderweb', 'circle' is available.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Radar Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var radarChart_RadarChart = /*#__PURE__*/function (_Chart) {
  radarChart_inherits(RadarChart, _Chart);

  var _super = radarChart_createSuper(RadarChart);

  function RadarChart(_ref) {
    var _this;

    var el = _ref.el,
        _options = _ref.options,
        _data = _ref.data;

    radarChart_classCallCheck(this, RadarChart);

    _this = _super.call(this, {
      el: el,
      options: _options,
      series: {
        radar: _data.series
      },
      categories: _data.categories,
      modules: [store_dataRange, store_scale, store_axes]
    });

    radarChart_defineProperty(radarChart_assertThisInitialized(_this), "addData", function (data, category) {
      _this.animationControlFlag.updating = true;

      _this.resetSeries();

      _this.store.dispatch('addData', {
        data: data,
        category: category
      });
    });

    radarChart_defineProperty(radarChart_assertThisInitialized(_this), "setOptions", function (options) {
      _this.dispatchOptionsEvent('initOptions', options);
    });

    radarChart_defineProperty(radarChart_assertThisInitialized(_this), "updateOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', options);
    });

    radarChart_defineProperty(radarChart_assertThisInitialized(_this), "showTooltip", function (seriesInfo) {
      _this.eventBus.emit('showTooltip', radarChart_objectSpread(radarChart_objectSpread({}, seriesInfo), {}, {
        state: _this.store.state
      }));
    });

    radarChart_defineProperty(radarChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  radarChart_createClass(RadarChart, [{
    key: "initialize",
    value: function initialize() {
      radarChart_get(radarChart_getPrototypeOf(RadarChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(title_Title);
      this.componentManager.add(legend_Legend);
      this.componentManager.add(radarPlot_RadarPlot);
      this.componentManager.add(radialAxis_RadialAxis);
      this.componentManager.add(radarSeries_RadarSeries);
      this.componentManager.add(exportMenu_ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(hoveredSeries_HoveredSeries);
      this.componentManager.add(selectedSeries_SelectedSeries);
      this.componentManager.add(tooltip_Tooltip, {
        chartEl: this.el
      });
      this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, polygon_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<number>} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addSeries",

    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          radar: series
        },
        categories: categories
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }]);

  return RadarChart;
}(chart_Chart);


// CONCATENATED MODULE: ./src/helpers/squarifier.ts
















function squarifier_toConsumableArray(arr) { return squarifier_arrayWithoutHoles(arr) || squarifier_iterableToArray(arr) || squarifier_unsupportedIterableToArray(arr) || squarifier_nonIterableSpread(); }

function squarifier_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function squarifier_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return squarifier_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return squarifier_arrayLikeToArray(o, minLen); }

function squarifier_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function squarifier_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return squarifier_arrayLikeToArray(arr); }

function squarifier_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




function calculateScale(values, width, height) {
  return width * height / calculator_sum(values);
}

function isVerticalStack(_ref) {
  var height = _ref.height,
      width = _ref.width;
  return height < width;
}

function selectBaseSize(baseBound) {
  return isVerticalStack(baseBound) ? baseBound.height : baseBound.width;
}

function makeBaseData(seriesItems, baseBound) {
  var width = baseBound.width,
      height = baseBound.height;
  var scale = calculateScale(pluck(seriesItems, 'data'), width, height);
  return seriesItems.map(function (seriesItem) {
    return {
      id: seriesItem.id,
      weight: seriesItem.data * scale
    };
  }).sort(function (a, b) {
    return b.weight - a.weight;
  });
}
/**
 * Calculate worst aspect ratio.
 * Referred function worst() in https://www.win.tue.nl/~vanwijk/stm.pdf
 */


function worst(total, min, max, baseSize) {
  var sumSquare = total * total;
  var sizeSquare = baseSize * baseSize;
  return Math.max(sizeSquare * max / sumSquare, sumSquare / (sizeSquare * min));
}

function changedStackDirection(total, weights, baseSize, newWeight) {
  var minWeight = Math.min.apply(Math, squarifier_toConsumableArray(weights));
  var maxWeight = Math.max.apply(Math, squarifier_toConsumableArray(weights));
  var beforeWorst = worst(total, minWeight, maxWeight, baseSize);
  var newWorst = worst(total + newWeight, Math.min(minWeight, newWeight), Math.max(maxWeight, newWeight), baseSize);
  return newWorst >= beforeWorst;
}

function calculateFixedSize(baseSize, total, rows) {
  if (!total) {
    var weights = pluck(rows, 'weight');
    total = calculator_sum(weights);
  }

  return total / baseSize;
}

function addBounds(startPosition, rows, fixedSize, callback) {
  rows.reduce(function (storedPosition, rowDatum) {
    var dynamicSize = rowDatum.weight / fixedSize;
    callback(dynamicSize, storedPosition, rowDatum.id);
    return storedPosition + dynamicSize;
  }, startPosition);
}

function addBound(boundMap, id, rect) {
  boundMap[id] = rect;
}

function addBoundsForVerticalStack(boundMap, rows, baseBound, baseSize, total) {
  var fixedWidth = calculateFixedSize(baseSize, total, rows);
  addBounds(baseBound.y, rows, fixedWidth, function (dynamicHeight, storedTop, id) {
    addBound(boundMap, id, {
      x: baseBound.x,
      y: storedTop,
      width: fixedWidth,
      height: dynamicHeight
    });
  });
  baseBound.x += fixedWidth;
  baseBound.width -= fixedWidth;
}

function addBoundsForHorizontalStack(boundMap, rows, baseBound, baseSize, total) {
  var fixedHeight = calculateFixedSize(baseSize, total, rows);
  addBounds(baseBound.x, rows, fixedHeight, function (dynamicWidth, storedLeft, id) {
    addBound(boundMap, id, {
      x: storedLeft,
      y: baseBound.y,
      width: dynamicWidth,
      height: fixedHeight
    });
  });
  baseBound.y += fixedHeight;
  baseBound.height -= fixedHeight;
}

function getAddingBoundsFunction(baseBound) {
  if (isVerticalStack(baseBound)) {
    return addBoundsForVerticalStack;
  }

  return addBoundsForHorizontalStack;
}

function squarify(layout, seriesItems) {
  var baseBound = layout;
  var baseData = makeBaseData(seriesItems, baseBound);
  var row = [];
  var baseSize, addBoundsFunc;
  var boundMap = {};
  baseData.forEach(function (datum) {
    var weights = pluck(row, 'weight');
    var totalWeight = calculator_sum(weights);

    if (row.length && changedStackDirection(totalWeight, weights, baseSize, datum.weight)) {
      addBoundsFunc(boundMap, row, baseBound, baseSize, totalWeight);
      row = [];
    }

    if (!row.length) {
      baseSize = selectBaseSize(baseBound);
      addBoundsFunc = getAddingBoundsFunction(baseBound);
    }

    row.push(datum);
  });

  if (row.length) {
    addBoundsFunc(boundMap, row, baseBound, baseSize);
  }

  return boundMap;
}
// CONCATENATED MODULE: ./src/component/treemapSeries.ts


























function treemapSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { treemapSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { treemapSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return treemapSeries_typeof(obj); }

function treemapSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function treemapSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { treemapSeries_ownKeys(Object(source), true).forEach(function (key) { treemapSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { treemapSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function treemapSeries_toConsumableArray(arr) { return treemapSeries_arrayWithoutHoles(arr) || treemapSeries_iterableToArray(arr) || treemapSeries_unsupportedIterableToArray(arr) || treemapSeries_nonIterableSpread(); }

function treemapSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function treemapSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return treemapSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return treemapSeries_arrayLikeToArray(o, minLen); }

function treemapSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function treemapSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return treemapSeries_arrayLikeToArray(arr); }

function treemapSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function treemapSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function treemapSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function treemapSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) treemapSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) treemapSeries_defineProperties(Constructor, staticProps); return Constructor; }

function treemapSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) treemapSeries_setPrototypeOf(subClass, superClass); }

function treemapSeries_setPrototypeOf(o, p) { treemapSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return treemapSeries_setPrototypeOf(o, p); }

function treemapSeries_createSuper(Derived) { var hasNativeReflectConstruct = treemapSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = treemapSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = treemapSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return treemapSeries_possibleConstructorReturn(this, result); }; }

function treemapSeries_possibleConstructorReturn(self, call) { if (call && (treemapSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return treemapSeries_assertThisInitialized(self); }

function treemapSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function treemapSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function treemapSeries_getPrototypeOf(o) { treemapSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return treemapSeries_getPrototypeOf(o); }

function treemapSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }











var treemapSeries_TreemapSeries = /*#__PURE__*/function (_Component) {
  treemapSeries_inherits(TreemapSeries, _Component);

  var _super = treemapSeries_createSuper(TreemapSeries);

  function TreemapSeries() {
    var _this;

    treemapSeries_classCallCheck(this, TreemapSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "models", {
      series: [],
      layer: []
    });

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "responders", void 0);

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "theme", void 0);

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "activatedResponders", []);

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "zoomable", void 0);

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.emitMouseEvent([]);
    });

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var seriesIndex = _ref.seriesIndex;

      if (!isNumber(seriesIndex)) {
        return;
      }

      var model = _this.responders.find(function (_ref2) {
        var indexes = _ref2.indexes;
        return last(indexes) === seriesIndex;
      });

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: [model],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "showTooltip", function (_ref3) {
      var seriesIndex = _ref3.seriesIndex;

      if (!isNumber(seriesIndex)) {
        return;
      }

      var model = _this.responders.find(function (_ref4) {
        var indexes = _ref4.indexes;
        return last(indexes) === seriesIndex;
      });

      if (model) {
        _this.emitMouseEvent([model]);
      }
    });

    return _this;
  }

  treemapSeries_createClass(TreemapSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'treemap';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "getAllChildSeries",
    value: function getAllChildSeries(series, parentId) {
      var _this2 = this;

      var allChildSeries = [];
      series.forEach(function (data) {
        if (data.parentId === parentId) {
          allChildSeries.push(data);

          if (data.hasChild) {
            var res = _this2.getAllChildSeries(series, data.id);

            allChildSeries.push.apply(allChildSeries, treemapSeries_toConsumableArray(res));
          }
        }
      });
      return allChildSeries;
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var _options$series$zooma, _options$series;

      var layout = chartState.layout,
          treemapSeries = chartState.treemapSeries,
          colorValueScale = chartState.colorValueScale,
          options = chartState.options,
          theme = chartState.theme,
          treemapZoomId = chartState.treemapZoomId;

      if (!treemapSeries.length) {
        throw new Error(message.noDataError(this.name));
      }

      var currentTreemapZoomId = treemapZoomId.cur;
      var series = this.getAllChildSeries(treemapSeries, currentTreemapZoomId);
      this.theme = theme.series.treemap;
      this.rect = layout.plot;
      this.selectable = this.getSelectableOption(options);
      this.models = this.renderTreemapSeries(series, options, colorValueScale, currentTreemapZoomId);
      this.zoomable = (_options$series$zooma = (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.zoomable) !== null && _options$series$zooma !== void 0 ? _options$series$zooma : false;

      if (getDataLabelsOptions(options, this.name).visible) {
        var _options$series$dataL, _options$series2, _options$series2$data;

        var useTreemapLeaf = (_options$series$dataL = (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : (_options$series2$data = _options$series2.dataLabels) === null || _options$series2$data === void 0 ? void 0 : _options$series2$data.useTreemapLeaf) !== null && _options$series$dataL !== void 0 ? _options$series$dataL : false;
        var dataLabelModel = this.makeDataLabel(useTreemapLeaf, currentTreemapZoomId);
        this.renderDataLabels(dataLabelModel);
      }

      this.responders = this.makeTreemapSeriesResponder(currentTreemapZoomId);
    }
  }, {
    key: "makeTreemapSeriesResponder",
    value: function makeTreemapSeriesResponder(treemapCurrentDepthParentId) {
      var tooltipData = this.makeTooltipData();
      var series = this.models.series;

      if (this.zoomable) {
        series = series.filter(function (_ref5) {
          var parentId = _ref5.parentId;
          return parentId === treemapCurrentDepthParentId;
        });
      }

      return series.map(function (m, idx) {
        return treemapSeries_objectSpread(treemapSeries_objectSpread({}, m), {}, {
          data: tooltipData[idx],
          thickness: boxDefault.HOVER_THICKNESS,
          style: ['shadow']
        });
      });
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData() {
      return this.models.series.map(function (_ref6) {
        var label = _ref6.label,
            data = _ref6.data,
            color = _ref6.color;
        return {
          label: label,
          color: color,
          value: data
        };
      });
    }
  }, {
    key: "makeBoundMap",
    value: function makeBoundMap(series, parentId, layout) {
      var _this3 = this;

      var boundMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var seriesItems = series.filter(function (item) {
        return item.parentId === parentId;
      });
      boundMap = treemapSeries_objectSpread(treemapSeries_objectSpread({}, boundMap), squarify(treemapSeries_objectSpread({}, layout), seriesItems));
      seriesItems.forEach(function (seriesItem) {
        boundMap = _this3.makeBoundMap(series, seriesItem.id, boundMap[seriesItem.id], boundMap);
      });
      return boundMap;
    }
  }, {
    key: "makeDataLabel",
    value: function makeDataLabel(useTreemapLeaf, treemapCurrentDepthParentId) {
      var series = useTreemapLeaf ? this.models.series.filter(function (_ref7) {
        var hasChild = _ref7.hasChild;
        return !hasChild;
      }) : this.models.series.filter(function (_ref8) {
        var parentId = _ref8.parentId;
        return parentId === treemapCurrentDepthParentId;
      });
      var dataLabelTheme = this.theme.dataLabels;
      return series.map(function (m) {
        return treemapSeries_objectSpread(treemapSeries_objectSpread({}, m), {}, {
          type: 'treemapSeriesName',
          value: m.label,
          direction: 'left',
          plot: {
            x: 0,
            y: 0,
            size: 0
          },
          theme: treemapSeries_objectSpread(treemapSeries_objectSpread({}, dataLabelTheme), {}, {
            color: dataLabelTheme.useSeriesColor ? m.color : dataLabelTheme.color
          })
        });
      });
    }
  }, {
    key: "getColor",
    value: function getColor(treemapSeries, colors) {
      var indexes = treemapSeries.indexes;
      var colorIdx = first(indexes);
      return colors[colorIdx];
    }
  }, {
    key: "getOpacity",
    value: function getOpacity(treemapSeries) {
      var indexes = treemapSeries.indexes,
          depth = treemapSeries.depth;
      var idx = last(indexes);
      return indexes.length === 1 ? 0 : Number((0.1 * depth + 0.05 * idx).toFixed(2));
    }
  }, {
    key: "renderTreemapSeries",
    value: function renderTreemapSeries(seriesData, options, colorValueScale, treemapCurrentDepthParentId) {
      var _options$series$useCo,
          _options$series3,
          _this4 = this,
          _options$series4;

      var layer = [];
      var boundMap = this.makeBoundMap(seriesData, treemapCurrentDepthParentId, treemapSeries_objectSpread(treemapSeries_objectSpread({}, this.rect), {}, {
        x: 0,
        y: 0
      }));
      var _this$theme = this.theme,
          colors = _this$theme.colors,
          startColor = _this$theme.startColor,
          endColor = _this$theme.endColor,
          borderWidth = _this$theme.borderWidth,
          borderColor = _this$theme.borderColor;
      var startRGB, distances;
      var useColorValue = (_options$series$useCo = (_options$series3 = options.series) === null || _options$series3 === void 0 ? void 0 : _options$series3.useColorValue) !== null && _options$series$useCo !== void 0 ? _options$series$useCo : false;

      if (useColorValue && startColor && endColor) {
        startRGB = hexToRGB(startColor);
        distances = makeDistances(startRGB, hexToRGB(endColor));
      }

      var series = Object.keys(boundMap).map(function (id) {
        var treemapSeries = seriesData.find(function (item) {
          return item.id === id;
        });
        var colorRatio;

        if (useColorValue) {
          colorRatio = getColorRatio(colorValueScale.limit, treemapSeries.colorValue);
        }

        return treemapSeries_objectSpread(treemapSeries_objectSpread(treemapSeries_objectSpread({}, treemapSeries), boundMap[id]), {}, {
          type: 'rect',
          colorRatio: colorRatio,
          color: useColorValue ? getSpectrumColor(colorRatio, distances, startRGB) : _this4.getColor(treemapSeries, colors),
          opacity: useColorValue ? 0 : _this4.getOpacity(treemapSeries),
          thickness: borderWidth,
          borderColor: borderColor
        });
      });

      if (!((_options$series4 = options.series) === null || _options$series4 === void 0 ? void 0 : _options$series4.useColorValue)) {
        layer = series.map(function (m) {
          return treemapSeries_objectSpread(treemapSeries_objectSpread({}, m), {}, {
            color: getRGBA('#000000', m.opacity)
          });
        });
      }

      return {
        series: series,
        layer: layer
      };
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _this5 = this;

      return responders.map(function (responder) {
        return deepMergedCopy(responder, treemapSeries_objectSpread(treemapSeries_objectSpread({}, _this5.theme[type]), {}, {
          style: ['shadow']
        }));
      });
    }
  }, {
    key: "onClick",
    value: function onClick(_ref9) {
      var responders = _ref9.responders;

      if (responders.length) {
        if (this.zoomable) {
          var _responders$ = responders[0],
              id = _responders$.id,
              hasChild = _responders$.hasChild;

          if (hasChild) {
            this.emitMouseEvent([]);
            this.store.dispatch('setTreemapZoomId', id);
            this.eventBus.emit('resetSelectedSeries');
          } else if (this.selectable) {
            this.eventBus.emit('renderSelectedSeries', {
              models: this.getRespondersWithTheme(responders, 'select'),
              name: this.name
            });
          }
        } else if (this.selectable) {
          var deepestNode = getDeepestNode(responders);
          this.eventBus.emit('renderSelectedSeries', {
            models: this.getRespondersWithTheme(deepestNode, 'select'),
            name: this.name
          });
        }
      }
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref10) {
      var responders = _ref10.responders;
      var deepestNode = getDeepestNode(responders);
      this.activatedResponders = deepestNode;
      this.emitMouseEvent(deepestNode);
    }
  }, {
    key: "emitMouseEvent",
    value: function emitMouseEvent(responders) {
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getRespondersWithTheme(responders, 'hover'),
        name: this.name
      });
      this.eventBus.emit('seriesPointHovered', {
        models: responders,
        name: this.name
      });
      this.eventBus.emit('renderSpectrumTooltip', responders);
      this.eventBus.emit('needDraw');
    }
  }]);

  return TreemapSeries;
}(component_Component);


// CONCATENATED MODULE: ./src/component/backButton.ts














function backButton_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { backButton_typeof = function _typeof(obj) { return typeof obj; }; } else { backButton_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return backButton_typeof(obj); }

function backButton_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function backButton_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function backButton_createClass(Constructor, protoProps, staticProps) { if (protoProps) backButton_defineProperties(Constructor.prototype, protoProps); if (staticProps) backButton_defineProperties(Constructor, staticProps); return Constructor; }

function backButton_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) backButton_setPrototypeOf(subClass, superClass); }

function backButton_setPrototypeOf(o, p) { backButton_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return backButton_setPrototypeOf(o, p); }

function backButton_createSuper(Derived) { var hasNativeReflectConstruct = backButton_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = backButton_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = backButton_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return backButton_possibleConstructorReturn(this, result); }; }

function backButton_possibleConstructorReturn(self, call) { if (call && (backButton_typeof(call) === "object" || typeof call === "function")) { return call; } return backButton_assertThisInitialized(self); }

function backButton_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function backButton_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function backButton_getPrototypeOf(o) { backButton_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return backButton_getPrototypeOf(o); }

function backButton_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var backButton_BackButton = /*#__PURE__*/function (_Component) {
  backButton_inherits(BackButton, _Component);

  var _super = backButton_createSuper(BackButton);

  function BackButton() {
    var _this;

    backButton_classCallCheck(this, BackButton);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    backButton_defineProperty(backButton_assertThisInitialized(_this), "responders", void 0);

    backButton_defineProperty(backButton_assertThisInitialized(_this), "models", void 0);

    return _this;
  }

  backButton_createClass(BackButton, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'backButton';
      this.name = 'backButton';
    }
  }, {
    key: "onClick",
    value: function onClick(_ref) {
      var responders = _ref.responders;

      if (responders.length) {
        this.store.dispatch('zoomBack');
        this.eventBus.emit('resetSelectedSeries');
      }
    }
  }, {
    key: "render",
    value: function render(_ref2, computed) {
      var options = _ref2.options,
          layout = _ref2.layout;

      if (!isUsingResetButton(options)) {
        return;
      }

      this.rect = layout.resetButton;
      this.isShow = computed.isTreemapSeriesZooming;
      this.models = this.isShow ? [{
        type: 'backButton',
        x: 0,
        y: 0
      }] : [];
      this.responders = this.isShow ? [{
        type: 'rect',
        x: 0,
        y: 0,
        width: BUTTON_RECT_SIZE,
        height: BUTTON_RECT_SIZE
      }] : [];
    }
  }]);

  return BackButton;
}(component_Component);


// CONCATENATED MODULE: ./src/charts/treemapChart.ts



















function treemapChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { treemapChart_typeof = function _typeof(obj) { return typeof obj; }; } else { treemapChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return treemapChart_typeof(obj); }

function treemapChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function treemapChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { treemapChart_ownKeys(Object(source), true).forEach(function (key) { treemapChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { treemapChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function treemapChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function treemapChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function treemapChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) treemapChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) treemapChart_defineProperties(Constructor, staticProps); return Constructor; }

function treemapChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { treemapChart_get = Reflect.get; } else { treemapChart_get = function _get(target, property, receiver) { var base = treemapChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return treemapChart_get(target, property, receiver || target); }

function treemapChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = treemapChart_getPrototypeOf(object); if (object === null) break; } return object; }

function treemapChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) treemapChart_setPrototypeOf(subClass, superClass); }

function treemapChart_setPrototypeOf(o, p) { treemapChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return treemapChart_setPrototypeOf(o, p); }

function treemapChart_createSuper(Derived) { var hasNativeReflectConstruct = treemapChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = treemapChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = treemapChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return treemapChart_possibleConstructorReturn(this, result); }; }

function treemapChart_possibleConstructorReturn(self, call) { if (call && (treemapChart_typeof(call) === "object" || typeof call === "function")) { return call; } return treemapChart_assertThisInitialized(self); }

function treemapChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function treemapChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function treemapChart_getPrototypeOf(o) { treemapChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return treemapChart_getPrototypeOf(o); }

function treemapChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






















/**
 * @class
 * @classdesc Treemap Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Treemap Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.label - Data name.
 *       @param {number} [props.data.series.data] - data value.
 *       @param {number} [props.data.series.colorValue] - color value. If you use the useColorValue option, the color is painted based on this value.
 *       @param {Array<Object>} [props.data.series.children] - Child element value.
 *   @param {Object} [props.options] - Options for making Treemap Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.useColorValue] - Whether to use color value or not.
 *       @param {boolean} [props.options.series.zoomable] - Whether to use zoom feature or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {boolean} [props.options.legend.visible=false] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Treemap Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var treemapChart_TreemapChart = /*#__PURE__*/function (_Chart) {
  treemapChart_inherits(TreemapChart, _Chart);

  var _super = treemapChart_createSuper(TreemapChart);

  function TreemapChart(props) {
    var _this;

    treemapChart_classCallCheck(this, TreemapChart);

    _this = _super.call(this, {
      el: props.el,
      options: props.options,
      series: {
        treemap: props.data.series
      },
      modules: [store_treemapSeriesData, store_colorValueScale]
    });

    treemapChart_defineProperty(treemapChart_assertThisInitialized(_this), "hideSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    });

    treemapChart_defineProperty(treemapChart_assertThisInitialized(_this), "showSeriesDataLabel", function () {
      _this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    });

    treemapChart_defineProperty(treemapChart_assertThisInitialized(_this), "setOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('initOptions', options);
    });

    treemapChart_defineProperty(treemapChart_assertThisInitialized(_this), "updateOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', options);
    });

    treemapChart_defineProperty(treemapChart_assertThisInitialized(_this), "showTooltip", function (seriesInfo) {
      _this.eventBus.emit('showTooltip', treemapChart_objectSpread(treemapChart_objectSpread({}, seriesInfo), {}, {
        state: _this.store.state
      }));
    });

    treemapChart_defineProperty(treemapChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  treemapChart_createClass(TreemapChart, [{
    key: "initialize",
    value: function initialize() {
      treemapChart_get(treemapChart_getPrototypeOf(TreemapChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(title_Title);
      this.componentManager.add(spectrumLegend_SpectrumLegend);
      this.componentManager.add(treemapSeries_TreemapSeries);
      this.componentManager.add(exportMenu_ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(hoveredSeries_HoveredSeries);
      this.componentManager.add(selectedSeries_SelectedSeries);
      this.componentManager.add(dataLabels_DataLabels);
      this.componentManager.add(tooltip_Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(backButton_BackButton);
      this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, spectrumLegend_namespaceObject, brushes_resetButton_namespaceObject]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   label: 'Documents',
     *   children: [
     *     {label: 'A', data: 20},
     *     {label: 'B', data: 40},
     *   ],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data, dataInfo) {
      this.resetSeries();
      this.store.dispatch('addTreemapSeries', treemapChart_objectSpread({
        data: data
      }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData(
     *   series: [
     *     {
     *       label: 'Documents',
     *       children: [
     *         {label: 'A', data: 20},
     *         {label: 'B', data: 40},
     *       ],
     *     },
     *     {
     *       label: 'Documents',
     *       data: 30,
     *     }
     *   ]
     * );
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          treemap: data.series
        }
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }]);

  return TreemapChart;
}(chart_Chart);


// CONCATENATED MODULE: ./src/component/boxPlotSeries.ts


























function boxPlotSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { boxPlotSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { boxPlotSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return boxPlotSeries_typeof(obj); }

function boxPlotSeries_toConsumableArray(arr) { return boxPlotSeries_arrayWithoutHoles(arr) || boxPlotSeries_iterableToArray(arr) || boxPlotSeries_unsupportedIterableToArray(arr) || boxPlotSeries_nonIterableSpread(); }

function boxPlotSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxPlotSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function boxPlotSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return boxPlotSeries_arrayLikeToArray(arr); }

function boxPlotSeries_slicedToArray(arr, i) { return boxPlotSeries_arrayWithHoles(arr) || boxPlotSeries_iterableToArrayLimit(arr, i) || boxPlotSeries_unsupportedIterableToArray(arr, i) || boxPlotSeries_nonIterableRest(); }

function boxPlotSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxPlotSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return boxPlotSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return boxPlotSeries_arrayLikeToArray(o, minLen); }

function boxPlotSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function boxPlotSeries_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function boxPlotSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function boxPlotSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function boxPlotSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { boxPlotSeries_ownKeys(Object(source), true).forEach(function (key) { boxPlotSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { boxPlotSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function boxPlotSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function boxPlotSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function boxPlotSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) boxPlotSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) boxPlotSeries_defineProperties(Constructor, staticProps); return Constructor; }

function boxPlotSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) boxPlotSeries_setPrototypeOf(subClass, superClass); }

function boxPlotSeries_setPrototypeOf(o, p) { boxPlotSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return boxPlotSeries_setPrototypeOf(o, p); }

function boxPlotSeries_createSuper(Derived) { var hasNativeReflectConstruct = boxPlotSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = boxPlotSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = boxPlotSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return boxPlotSeries_possibleConstructorReturn(this, result); }; }

function boxPlotSeries_possibleConstructorReturn(self, call) { if (call && (boxPlotSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return boxPlotSeries_assertThisInitialized(self); }

function boxPlotSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function boxPlotSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function boxPlotSeries_getPrototypeOf(o) { boxPlotSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return boxPlotSeries_getPrototypeOf(o); }

function boxPlotSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var MIN_BAR_WIDTH = 5;

function getPadding(tickDistance, barWidth, seriesLength) {
  return (tickDistance - barWidth * seriesLength) / (seriesLength + 1);
}

function getDefaultColor(defaultColor, color) {
  return color !== null && color !== void 0 ? color : defaultColor;
}

var boxPlotSeries_BoxPlotSeries = /*#__PURE__*/function (_Component) {
  boxPlotSeries_inherits(BoxPlotSeries, _Component);

  var _super = boxPlotSeries_createSuper(BoxPlotSeries);

  function BoxPlotSeries() {
    var _this;

    boxPlotSeries_classCallCheck(this, BoxPlotSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "models", {
      series: []
    });

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "drawModels", void 0);

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "responders", void 0);

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "activatedResponders", []);

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "eventDetectType", 'point');

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "tooltipRectMap", void 0);

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "theme", void 0);

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var index = _ref.index,
          seriesIndex = _ref.seriesIndex,
          state = _ref.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.boxPlot[seriesIndex].name;

      var models = _this.getRespondersWithTheme(_this.tooltipRectMap["".concat(name, "-").concat(index)], 'select');

      _this.eventBus.emit('renderSelectedSeries', {
        models: models,
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "showTooltip", function (_ref2) {
      var index = _ref2.index,
          seriesIndex = _ref2.seriesIndex,
          state = _ref2.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.boxPlot[seriesIndex].name;

      var models = _this.getRespondersWithTheme(_this.tooltipRectMap["".concat(name, "-").concat(index)], 'hover');

      _this.eventBus.emit('renderHoveredSeries', {
        models: models,
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.activatedResponders = models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  boxPlotSeries_createClass(BoxPlotSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'boxPlot';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "render",
    value: function render(state) {
      var _options$series;

      var layout = state.layout,
          axes = state.axes,
          series = state.series,
          scale = state.scale,
          legend = state.legend,
          options = state.options,
          theme = state.theme;

      if (!series.boxPlot) {
        throw new Error(message.noDataError(this.name));
      }

      if (options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }

      this.theme = theme.series.boxPlot;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var categories = state.categories;
      var tickDistance = axes.xAxis.tickDistance;
      var _scale$yAxis$limit = scale.yAxis.limit,
          min = _scale$yAxis$limit.min,
          max = _scale$yAxis$limit.max;
      var boxPlotData = series.boxPlot.data;
      var seriesLength = boxPlotData.length;

      var renderOptions = boxPlotSeries_objectSpread({
        ratio: this.rect.height / (max - min),
        tickDistance: tickDistance
      }, this.getBarWidths(tickDistance, seriesLength));

      var boxPlotModelData = this.makeBoxPlots(boxPlotData, renderOptions);
      var seriesModels = this.renderSeriesModels(boxPlotModelData);
      this.models.series = seriesModels;

      if (!this.drawModels) {
        this.drawModels = {
          series: seriesModels.map(function (m) {
            var model = boxPlotSeries_objectSpread({}, m);

            if (m.type === 'rect') {
              model.y = m.y + m.height;
              model.height = 0;
            }

            return model;
          })
        };
      }

      var tooltipData = this.makeTooltipModel(boxPlotData, categories);
      this.tooltipRectMap = this.makeTooltipRectMap(boxPlotModelData, tooltipData);
      this.responders = this.eventDetectType === 'grouped' ? this.makeGroupedResponderModel(boxPlotModelData) : this.makeDefaultResponderModel(boxPlotModelData, tooltipData);
    }
  }, {
    key: "makeTooltipRectMap",
    value: function makeTooltipRectMap(boxPlotModelData, tooltipData) {
      var _this2 = this;

      var result = {};
      boxPlotModelData.forEach(function (m, tooltipIndex) {
        if (!isNull(m)) {
          var propName = "".concat(m.name, "-").concat(m.index);

          if (!result[propName]) {
            result[propName] = [];
          }

          result[propName].push(boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, _this2.makeHoveredModel(m)), {}, {
            data: tooltipData[tooltipIndex]
          }));
        }
      });
      return result;
    }
  }, {
    key: "makeGroupedResponderModel",
    value: function makeGroupedResponderModel(boxPlotModelData) {
      var _this3 = this;

      var result = [];
      boxPlotModelData.forEach(function (m) {
        var type = m.type,
            index = m.index,
            name = m.name;
        var propName = "".concat(name, "-").concat(index);

        if (type === 'boxPlot' && !result[propName]) {
          var _ref3 = m,
              boxPlotDetection = _ref3.boxPlotDetection;
          result.push(boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({
            type: 'rect',
            name: propName
          }, boxPlotDetection), {}, {
            y: 0,
            height: _this3.rect.height
          }));
        }
      });
      return result;
    }
  }, {
    key: "makeDefaultResponderModel",
    value: function makeDefaultResponderModel(boxPlotModelData, tooltipDataArr) {
      var _this4 = this;

      return boxPlotModelData.map(function (m, index) {
        return boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, _this4.makeHoveredModel(m)), {}, {
          data: tooltipDataArr[index],
          color: getRGBA(m.color, 1)
        });
      });
    }
  }, {
    key: "makeHoveredModel",
    value: function makeHoveredModel(model) {
      var point = model.type === 'boxPlot' && model.rect ? {
        x: model.rect.x,
        y: model.rect.y
      } : {
        x: model.x,
        y: model.y
      };

      var hoveredModel = boxPlotSeries_objectSpread({}, model);

      if (model.type === 'boxPlot') {
        ['lowerWhisker', 'upperWhisker', 'maximum', 'minimum', 'median'].forEach(function (prop) {
          if (model[prop]) {
            model[prop].detectionSize = 3;
          }
        });
        model.color = getRGBA(hoveredModel.color, 1);
      }

      return boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, hoveredModel), point);
    }
  }, {
    key: "getResponderModelFromMap",
    value: function getResponderModelFromMap(responders) {
      if (!responders.length) {
        return [];
      }

      var propName = responders[0].name;
      return this.tooltipRectMap[propName];
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref4) {
      var responders = _ref4.responders;

      if (this.eventDetectType === 'grouped') {
        var models = this.getResponderModelFromMap(responders);
        this.eventBus.emit('renderHoveredSeries', {
          models: this.getRespondersWithTheme(models, 'select'),
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.activatedResponders = models;
      } else {
        this.eventBus.emit('renderHoveredSeries', {
          models: this.getRespondersWithTheme(responders, 'hover'),
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.activatedResponders = responders;
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref5) {
      var responders = _ref5.responders;

      if (this.selectable) {
        var models;

        if (this.eventDetectType === 'grouped') {
          models = this.getRespondersWithTheme(this.getResponderModelFromMap(responders), 'select');
        } else {
          models = this.getRespondersWithTheme(responders, 'select');
        }

        this.eventBus.emit('renderSelectedSeries', {
          models: models,
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "renderSeriesModels",
    value: function renderSeriesModels(boxPlots) {
      var seriesModels = [];
      boxPlots.forEach(function (model) {
        var type = model.type,
            name = model.name;

        if (type === 'boxPlot') {
          ['maximum', 'minimum', 'rect', 'median', 'upperWhisker', 'lowerWhisker'].forEach(function (prop) {
            seriesModels.push(boxPlotSeries_objectSpread({
              name: name
            }, model[prop]));
          });
        } else {
          seriesModels.push(boxPlotSeries_objectSpread({}, model));
        }
      });
      return seriesModels;
    }
  }, {
    key: "makeBoxPlots",
    value: function makeBoxPlots(seriesData, renderOptions) {
      var _this5 = this;

      var ratio = renderOptions.ratio,
          barWidth = renderOptions.barWidth;
      var boxPlotModels = [];
      var seriesLength = seriesData.length;
      var dot = this.theme.dot;
      seriesData.forEach(function (_ref6, seriesIndex) {
        var outliers = _ref6.outliers,
            data = _ref6.data,
            name = _ref6.name,
            color = _ref6.color;

        var seriesColor = _this5.getSeriesColor(name, color);

        (data !== null && data !== void 0 ? data : []).forEach(function (datum, dataIndex) {
          if (!isNull(datum)) {
            var startX = _this5.getStartX(seriesIndex, dataIndex, renderOptions, seriesLength);

            var rect = _this5.getRect(datum, startX, seriesColor, renderOptions);

            boxPlotModels.push(boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({
              type: 'boxPlot',
              color: seriesColor,
              name: name,
              rect: rect,
              median: _this5.getMedian(datum, startX, seriesColor, renderOptions),
              minimum: _this5.getMinimum(datum, startX, seriesColor, renderOptions),
              maximum: _this5.getMaximum(datum, startX, seriesColor, renderOptions)
            }, _this5.getWhisker(datum, startX, seriesColor, renderOptions, rect)), {}, {
              index: dataIndex,
              boxPlotDetection: {
                x: startX,
                width: barWidth
              }
            }));
          }
        });
        var _ref7 = dot,
            dotColor = _ref7.color,
            radius = _ref7.radius,
            borderColor = _ref7.borderColor,
            borderWidth = _ref7.borderWidth,
            useSeriesColor = _ref7.useSeriesColor;
        (outliers !== null && outliers !== void 0 ? outliers : []).forEach(function (datum) {
          var _datum = boxPlotSeries_slicedToArray(datum, 2),
              dataIndex = _datum[0],
              value = _datum[1];

          var startX = _this5.getStartX(seriesIndex, dataIndex, renderOptions, seriesLength);

          boxPlotModels.push({
            type: 'circle',
            name: name,
            x: startX + barWidth / 2,
            y: _this5.getYPos(value, ratio),
            radius: radius,
            style: [{
              strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : seriesColor,
              lineWidth: borderWidth
            }],
            color: useSeriesColor ? seriesColor : dotColor,
            index: dataIndex
          });
        });
      });
      return boxPlotModels;
    }
  }, {
    key: "makeTooltipModel",
    value: function makeTooltipModel(seriesData, categories) {
      var tooltipData = [];
      seriesData.forEach(function (_ref8) {
        var outliers = _ref8.outliers,
            data = _ref8.data,
            name = _ref8.name,
            color = _ref8.color;
        (data !== null && data !== void 0 ? data : []).forEach(function (datum, dataIndex) {
          if (!isNull(datum)) {
            var boxPlotData = boxPlotSeries_toConsumableArray(datum).reverse();

            tooltipData.push({
              label: name,
              color: color,
              value: ['Maximum', 'Upper Quartile', 'Median', 'Lower Quartile', 'Minimum'].reduce(function (acc, title, index) {
                var value = boxPlotData[index];
                return isNull(value) ? acc : [].concat(boxPlotSeries_toConsumableArray(acc), [{
                  title: title,
                  value: value
                }]);
              }, []),
              category: categories[dataIndex],
              templateType: 'boxPlot'
            });
          }
        });
        (outliers !== null && outliers !== void 0 ? outliers : []).forEach(function (datum) {
          if (!isNull(datum)) {
            var _datum2 = boxPlotSeries_slicedToArray(datum, 2),
                dataIndex = _datum2[0],
                dataValue = _datum2[1];

            tooltipData.push({
              label: name,
              color: color,
              value: [{
                title: 'Outlier',
                value: dataValue
              }],
              category: categories[dataIndex],
              templateType: 'boxPlot'
            });
          }
        });
      });
      return tooltipData;
    }
  }, {
    key: "getStartX",
    value: function getStartX(seriesIndex, dataIndex, renderOptions, seriesLength) {
      var tickDistance = renderOptions.tickDistance,
          barWidth = renderOptions.barWidth;
      var padding = getPadding(tickDistance, barWidth, seriesLength);
      return dataIndex * tickDistance + (seriesIndex + 1) * padding + barWidth * seriesIndex;
    }
  }, {
    key: "getYPos",
    value: function getYPos(value, ratio, lineWidth) {
      return isNumber(lineWidth) ? crispPixel(this.rect.height - value * ratio, lineWidth) : this.rect.height - value * ratio;
    }
  }, {
    key: "getBarWidths",
    value: function getBarWidths(tickDistance, seriesLength) {
      var _this$theme = this.theme,
          barThemeWidth = _this$theme.barWidth,
          barWidthRatios = _this$theme.barWidthRatios;
      var barRatio = barWidthRatios.barRatio,
          minMaxBarRatio = barWidthRatios.minMaxBarRatio;
      var defaultBarWidth = Math.max((tickDistance - getBoxTypeSeriesPadding(tickDistance) * (2 + (seriesLength - 1))) / seriesLength, MIN_BAR_WIDTH);
      var barWidth = barThemeWidth ? calculateSizeWithPercentString(tickDistance / seriesLength, barThemeWidth) : defaultBarWidth;
      return {
        barWidth: barWidth * barRatio,
        minMaxBarWidth: barWidth * minMaxBarRatio
      };
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _this$theme$type = this.theme[type],
          color = _this$theme$type.color,
          rect = _this$theme$type.rect,
          dot = _this$theme$type.dot,
          line = _this$theme$type.line,
          shadowColor = _this$theme$type.shadowColor,
          shadowOffsetX = _this$theme$type.shadowOffsetX,
          shadowOffsetY = _this$theme$type.shadowOffsetY,
          shadowBlur = _this$theme$type.shadowBlur;
      var _ref9 = line,
          whisker = _ref9.whisker,
          median = _ref9.median,
          maximum = _ref9.maximum,
          minimum = _ref9.minimum;
      var _ref10 = dot,
          dotColor = _ref10.color,
          radius = _ref10.radius,
          borderColor = _ref10.borderColor,
          borderWidth = _ref10.borderWidth,
          useSeriesColor = _ref10.useSeriesColor;
      return responders.map(function (m) {
        var modelType = m.type,
            data = m.data;
        var seriesColor = m.color;
        var model;

        if (modelType === 'circle') {
          seriesColor = data.color;
          model = boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, m), {}, {
            radius: radius,
            color: useSeriesColor ? seriesColor : dotColor,
            style: [{
              strokeStyle: getDefaultColor(seriesColor, borderColor),
              lineWidth: borderWidth
            }]
          });
        } else {
          var _ref11 = m,
              seriesRect = _ref11.rect,
              upperWhisker = _ref11.upperWhisker,
              lowerWhisker = _ref11.lowerWhisker,
              seriesMedian = _ref11.median,
              seriesMaximum = _ref11.maximum,
              seriesMinimum = _ref11.minimum;
          model = boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, m), {}, {
            rect: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, seriesRect), {}, {
              color: color !== null && color !== void 0 ? color : getRGBA(seriesColor, 1),
              thickness: rect.borderWidth,
              borderColor: rect.borderColor,
              style: [{
                shadowColor: shadowColor,
                shadowOffsetX: shadowOffsetX,
                shadowOffsetY: shadowOffsetY,
                shadowBlur: shadowBlur
              }]
            }),
            upperWhisker: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, upperWhisker), {}, {
              strokeStyle: getDefaultColor(seriesColor, whisker.color),
              lineWidth: whisker.lineWidth
            }),
            lowerWhisker: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, lowerWhisker), {}, {
              strokeStyle: getDefaultColor(seriesColor, whisker.color),
              lineWidth: whisker.lineWidth
            }),
            median: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, seriesMedian), {}, {
              strokeStyle: getDefaultColor(seriesColor, median.color),
              lineWidth: median.lineWidth
            }),
            maximum: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, seriesMaximum), {}, {
              strokeStyle: getDefaultColor(seriesColor, maximum.color),
              lineWidth: maximum.lineWidth
            }),
            minimum: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, seriesMinimum), {}, {
              strokeStyle: getDefaultColor(seriesColor, minimum.color),
              lineWidth: minimum.lineWidth
            })
          });
        }

        return model;
      });
    }
  }, {
    key: "getRect",
    value: function getRect(datum, startX, seriesColor, _ref12) {
      var barWidth = _ref12.barWidth,
          ratio = _ref12.ratio;
      var rect = this.theme.rect;

      var _datum3 = boxPlotSeries_slicedToArray(datum, 4),
          lowerQuartile = _datum3[1],
          highQuartile = _datum3[3];

      return {
        type: 'rect',
        x: startX,
        y: this.getYPos(highQuartile, ratio),
        width: barWidth,
        height: (highQuartile - lowerQuartile) * ratio,
        thickness: rect.borderWidth,
        borderColor: rect.borderColor,
        color: seriesColor
      };
    }
  }, {
    key: "getWhisker",
    value: function getWhisker(datum, startX, seriesColor, _ref13, rect) {
      var barWidth = _ref13.barWidth,
          ratio = _ref13.ratio;

      var _datum4 = boxPlotSeries_slicedToArray(datum, 5),
          minimum = _datum4[0],
          maximum = _datum4[4];

      var _ref14 = this.theme.line.whisker,
          lineWidth = _ref14.lineWidth,
          color = _ref14.color;
      var x = crispPixel(startX + barWidth / 2, lineWidth);
      return {
        upperWhisker: {
          type: 'line',
          x: x,
          y: this.getYPos(maximum, ratio, lineWidth),
          x2: x,
          y2: rect.y,
          strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
          lineWidth: lineWidth
        },
        lowerWhisker: {
          type: 'line',
          x: x,
          y: this.getYPos(minimum, ratio, lineWidth),
          x2: x,
          y2: crispPixel(rect.y + rect.height, lineWidth),
          strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
          lineWidth: lineWidth
        }
      };
    }
  }, {
    key: "getMedian",
    value: function getMedian(datum, startX, seriesColor, _ref15) {
      var barWidth = _ref15.barWidth,
          ratio = _ref15.ratio;
      var median = datum[2];
      var _ref16 = this.theme.line.median,
          lineWidth = _ref16.lineWidth,
          color = _ref16.color;
      return {
        type: 'line',
        x: crispPixel(startX, lineWidth),
        y: this.getYPos(median, ratio, lineWidth),
        x2: crispPixel(startX + barWidth, lineWidth),
        y2: this.getYPos(median, ratio, lineWidth),
        strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
        lineWidth: lineWidth
      };
    }
  }, {
    key: "getMinimum",
    value: function getMinimum(datum, startX, seriesColor, _ref17) {
      var barWidth = _ref17.barWidth,
          ratio = _ref17.ratio,
          minMaxBarWidth = _ref17.minMaxBarWidth;
      var minimum = datum[0];
      var _ref18 = this.theme.line.minimum,
          lineWidth = _ref18.lineWidth,
          color = _ref18.color;
      return {
        type: 'line',
        x: crispPixel(startX + (barWidth - minMaxBarWidth) / 2, lineWidth),
        y: this.getYPos(minimum, ratio, lineWidth),
        x2: crispPixel(startX + (barWidth - minMaxBarWidth) / 2 + minMaxBarWidth, lineWidth),
        y2: this.getYPos(minimum, ratio, lineWidth),
        strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
        lineWidth: lineWidth
      };
    }
  }, {
    key: "getMaximum",
    value: function getMaximum(datum, startX, seriesColor, _ref19) {
      var barWidth = _ref19.barWidth,
          ratio = _ref19.ratio,
          minMaxBarWidth = _ref19.minMaxBarWidth;
      var maximum = datum[4];
      var _ref20 = this.theme.line.maximum,
          lineWidth = _ref20.lineWidth,
          color = _ref20.color;
      return {
        type: 'line',
        x: crispPixel(startX + (barWidth - minMaxBarWidth) / 2, lineWidth),
        y: this.getYPos(maximum, ratio, lineWidth),
        x2: crispPixel(startX + (barWidth - minMaxBarWidth) / 2 + minMaxBarWidth, lineWidth),
        y2: this.getYPos(maximum, ratio, lineWidth),
        strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
        lineWidth: lineWidth
      };
    }
  }, {
    key: "getSeriesColor",
    value: function getSeriesColor(seriesName, seriesColor) {
      var _this$theme2 = this.theme,
          select = _this$theme2.select,
          areaOpacity = _this$theme2.areaOpacity;
      var active = this.activeSeriesMap[seriesName];
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      var selectedOpacity = active ? select.areaOpacity : select.restSeries.areaOpacity;
      var opacity = selected ? selectedOpacity : areaOpacity;
      return getRGBA(seriesColor, opacity);
    }
  }]);

  return BoxPlotSeries;
}(component_Component);


// CONCATENATED MODULE: ./src/brushes/boxPlot.ts








function boxPlot_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function boxPlot_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { boxPlot_ownKeys(Object(source), true).forEach(function (key) { boxPlot_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { boxPlot_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function boxPlot_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


function boxPlot(ctx, model) {
  var rectModel = model.rect,
      upperWhisker = model.upperWhisker,
      lowerWhisker = model.lowerWhisker,
      median = model.median,
      minimum = model.minimum,
      maximum = model.maximum;

  if (minimum) {
    basic_line(ctx, boxPlot_objectSpread({
      type: 'line'
    }, minimum));
  }

  if (lowerWhisker) {
    basic_line(ctx, boxPlot_objectSpread({
      type: 'line'
    }, lowerWhisker));
  }

  if (rectModel) {
    basic_rect(ctx, boxPlot_objectSpread({
      type: 'rect'
    }, rectModel));
  }

  if (upperWhisker) {
    basic_line(ctx, boxPlot_objectSpread({
      type: 'line'
    }, upperWhisker));
  }

  if (maximum) {
    basic_line(ctx, boxPlot_objectSpread({
      type: 'line'
    }, maximum));
  }

  if (median) {
    basic_line(ctx, boxPlot_objectSpread({
      type: 'line'
    }, median));
  }
}
// CONCATENATED MODULE: ./src/charts/boxPlotChart.ts



















function boxPlotChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { boxPlotChart_typeof = function _typeof(obj) { return typeof obj; }; } else { boxPlotChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return boxPlotChart_typeof(obj); }

function boxPlotChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function boxPlotChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { boxPlotChart_ownKeys(Object(source), true).forEach(function (key) { boxPlotChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { boxPlotChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function boxPlotChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function boxPlotChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function boxPlotChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) boxPlotChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) boxPlotChart_defineProperties(Constructor, staticProps); return Constructor; }

function boxPlotChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { boxPlotChart_get = Reflect.get; } else { boxPlotChart_get = function _get(target, property, receiver) { var base = boxPlotChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return boxPlotChart_get(target, property, receiver || target); }

function boxPlotChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = boxPlotChart_getPrototypeOf(object); if (object === null) break; } return object; }

function boxPlotChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) boxPlotChart_setPrototypeOf(subClass, superClass); }

function boxPlotChart_setPrototypeOf(o, p) { boxPlotChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return boxPlotChart_setPrototypeOf(o, p); }

function boxPlotChart_createSuper(Derived) { var hasNativeReflectConstruct = boxPlotChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = boxPlotChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = boxPlotChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return boxPlotChart_possibleConstructorReturn(this, result); }; }

function boxPlotChart_possibleConstructorReturn(self, call) { if (call && (boxPlotChart_typeof(call) === "object" || typeof call === "function")) { return call; } return boxPlotChart_assertThisInitialized(self); }

function boxPlotChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function boxPlotChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function boxPlotChart_getPrototypeOf(o) { boxPlotChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return boxPlotChart_getPrototypeOf(o); }

function boxPlotChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
























/**
 * @class
 * @classdesc BoxPlot Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making BoxPlot Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<Array<number>>} props.data.series.data - Series data.
 *       @param {Array<Array<number>>} props.data.series.outliers - Series outliers data.
 *   @param {Object} [props.options] - Options for making BoxPlot Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'grouped', 'point' is available.
 *     @param {Object} [props.options.xAxis]
 *       @param {Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object} [props.options.yAxis]
 *       @param {Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|BoxPlot Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var boxPlotChart_BoxPlotChart = /*#__PURE__*/function (_Chart) {
  boxPlotChart_inherits(BoxPlotChart, _Chart);

  var _super = boxPlotChart_createSuper(BoxPlotChart);

  function BoxPlotChart(_ref) {
    var _this;

    var el = _ref.el,
        _options = _ref.options,
        _ref$data = _ref.data,
        series = _ref$data.series,
        categories = _ref$data.categories;

    boxPlotChart_classCallCheck(this, BoxPlotChart);

    _this = _super.call(this, {
      el: el,
      options: _options,
      series: {
        boxPlot: series
      },
      categories: categories,
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });

    boxPlotChart_defineProperty(boxPlotChart_assertThisInitialized(_this), "addData", function (data, category) {
      _this.animationControlFlag.updating = true;

      _this.resetSeries();

      _this.store.dispatch('addData', {
        data: data,
        category: category
      });
    });

    boxPlotChart_defineProperty(boxPlotChart_assertThisInitialized(_this), "setOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('initOptions', options);
    });

    boxPlotChart_defineProperty(boxPlotChart_assertThisInitialized(_this), "updateOptions", function (options) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', options);
    });

    boxPlotChart_defineProperty(boxPlotChart_assertThisInitialized(_this), "showTooltip", function (seriesInfo) {
      _this.eventBus.emit('showTooltip', boxPlotChart_objectSpread(boxPlotChart_objectSpread({}, seriesInfo), {}, {
        state: _this.store.state
      }));
    });

    boxPlotChart_defineProperty(boxPlotChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  boxPlotChart_createClass(BoxPlotChart, [{
    key: "initialize",
    value: function initialize() {
      boxPlotChart_get(boxPlotChart_getPrototypeOf(BoxPlotChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(title_Title);
      this.componentManager.add(plot_Plot);
      this.componentManager.add(legend_Legend);
      this.componentManager.add(boxPlotSeries_BoxPlotSeries);
      this.componentManager.add(axis_Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(axis_Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(axisTitle_AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(exportMenu_ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(hoveredSeries_HoveredSeries);
      this.componentManager.add(selectedSeries_SelectedSeries);
      this.componentManager.add(tooltip_Tooltip, {
        chartEl: this.el
      });
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, boxPlot_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<<Array<number>>} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([[10, 20], [30, 40]], '6');
     */

  }, {
    key: "addSeries",

    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Array<number>>} data.data - Array of data to be added.
     *   @param {Array<Array<number>>} data.outliers - Series outliers data.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [
     *     [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     *   ],
     *   outliers: [
     *     [0, 14000],
     *     [2, 10000],
     *   ]
     * });
     */
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'newSeries',
     *       data: [
     *         [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     *       ],
     *       outliers: [
     *         [0, 14000],
     *         [2, 10000],
     *       ]
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          boxPlot: series
        },
        categories: categories
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }]);

  return BoxPlotChart;
}(chart_Chart);


// CONCATENATED MODULE: ./src/index.ts
function src_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function src_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


















var src_Chart = function Chart() {
  src_classCallCheck(this, Chart);
};

src_defineProperty(src_Chart, "lineChart", function (props) {
  return new lineChart_LineChart(props);
});

src_defineProperty(src_Chart, "areaChart", function (props) {
  return new areaChart_AreaChart(props);
});

src_defineProperty(src_Chart, "barChart", function (props) {
  return new barChart_BarChart(props);
});

src_defineProperty(src_Chart, "boxPlotChart", function (props) {
  return new boxPlotChart_BoxPlotChart(props);
});

src_defineProperty(src_Chart, "columnChart", function (props) {
  return new columnChart_ColumnChart(props);
});

src_defineProperty(src_Chart, "pieChart", function (props) {
  return new pieChart_PieChart(props);
});

src_defineProperty(src_Chart, "heatmapChart", function (props) {
  return new heatmapChart_HeatmapChart(props);
});

src_defineProperty(src_Chart, "bubbleChart", function (props) {
  return new bubbleChart_BubbleChart(props);
});

src_defineProperty(src_Chart, "scatterChart", function (props) {
  return new scatterChart_ScatterChart(props);
});

src_defineProperty(src_Chart, "bulletChart", function (props) {
  return new bulletChart_BulletChart(props);
});

src_defineProperty(src_Chart, "radarChart", function (props) {
  return new radarChart_RadarChart(props);
});

src_defineProperty(src_Chart, "treemapChart", function (props) {
  return new treemapChart_TreemapChart(props);
});

src_defineProperty(src_Chart, "nestedPieChart", function (props) {
  return new nestedPieChart_NestedPieChart(props);
});

src_defineProperty(src_Chart, "lineAreaChart", function (props) {
  return new lineAreaChart_LineAreaChart(props);
});

src_defineProperty(src_Chart, "lineScatterChart", function (props) {
  return new lineScatterChart_LineScatterChart(props);
});

src_defineProperty(src_Chart, "columnLineChart", function (props) {
  return new columnLineChart_ColumnLineChart(props);
});




/***/ })
/******/ ])["default"];
});